<!DOCTYPE html>

<html>
<head>
  <title>chap02.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap02.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-2-">第2章 なぜ関数型プログラミングが重要か</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
  <span class="hljs-keyword">return</span> (arg) =&gt; {
    <span class="hljs-keyword">return</span> f(g(arg));
  };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="2-2-">2.2 関数型プログラミングの特徴</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数型プログラミングの特徴'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3 id="-">ファーストクラスオブジェクトとしての関数</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'ファーストクラスオブジェクトとしての関数'</span>, () =&gt; {
    it(<span class="hljs-string">'数値はファーストクラスオブジェクトである'</span>, (next) =&gt; {
      <span class="hljs-comment">/*  #@range_begin(number_as_first_class_citizen) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>値を変数にバインドする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> zero = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Haskell Curry"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>値をデータ構造に埋めこむ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> birthday = {
        year: <span class="hljs-number">1999</span>,
        month: <span class="hljs-number">1</span>,
        day: <span class="hljs-number">12</span>
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>関数から値を返す</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> birthYear = (birthdayObject) =&gt; {
        <span class="hljs-keyword">return</span> birthdayObject.year;
      };
      <span class="hljs-comment">/* #@range_end(number_as_first_class_citizen) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>値を関数に渡す</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expect(
        <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        birthYear(birthday)
      ).to.eql(
        <span class="hljs-number">1999</span>
      );
      next();
    });
    it(<span class="hljs-string">'関数は変数にバインドできる'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(function_bound_to_variable) */</span>
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_end(function_bound_to_variable) */</span>
      expect(
        succ(<span class="hljs-number">1</span>) <span class="hljs-comment">// 変数succを用いてλ式を呼びだす</span>
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">'関数をオブジェクトに埋めこむ'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(function_embedded_in_object) */</span>
      <span class="hljs-keyword">var</span> math = {
        add: (n,m) =&gt; {
          <span class="hljs-keyword">return</span> n + m;
        }
      };
      expect(
        math.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      <span class="hljs-comment">/* #@range_end(function_embedded_in_object) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3 id="-">高階関数</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'高階関数'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>forEach文によるsumの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'forEach文によるsumの定義'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(sum_forEach) */</span>
        <span class="hljs-keyword">var</span> sum = (array) =&gt; {
          <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
          array.forEach((item) =&gt; { <span class="hljs-comment">// forEachに関数を渡す</span>
            result = result + item;
          });
          <span class="hljs-keyword">return</span> result;
        };
        <span class="hljs-comment">/* #@range_end(sum_forEach)  */</span>
        expect(
          sum([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
        ).to.eql(
          <span class="hljs-number">10</span>
        );
        next();
      });
      describe(<span class="hljs-string">'関数を返す'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>adderを定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'adderを定義する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(adder_definition) */</span>
          <span class="hljs-keyword">var</span> adder = (n) =&gt; {
            <span class="hljs-keyword">return</span> (m) =&gt; { <span class="hljs-comment">// 関数を返す</span>
              <span class="hljs-keyword">return</span> n + m;
            };
          };
          <span class="hljs-comment">/* #@range_end(adder_definition) */</span>
          <span class="hljs-keyword">var</span> succ = adder(<span class="hljs-number">1</span>);
          expect(
            succ(<span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">'reduceを定義する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(reduce_definition) */</span>
          <span class="hljs-keyword">var</span> reduce = (init,glue) =&gt; {
            <span class="hljs-keyword">return</span> (array) =&gt; { <span class="hljs-comment">// 関数が返る</span>
              <span class="hljs-keyword">if</span>(array.length === <span class="hljs-number">0</span>){
                <span class="hljs-keyword">return</span> init;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> accumulator = glue(array[<span class="hljs-number">0</span>], init);
                <span class="hljs-keyword">var</span> tail = array.slice(<span class="hljs-number">1</span>,array.length);
                <span class="hljs-keyword">return</span> reduce(accumulator,glue)(tail);
              }
            };
          };
          <span class="hljs-comment">/* #@range_end(reduce_definition) */</span>
          <span class="hljs-comment">/* #@range_begin(function_returning_function_test) */</span>
          <span class="hljs-keyword">var</span> adder = (x,y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
          <span class="hljs-keyword">var</span> sum = reduce(<span class="hljs-number">0</span>,adder);
          expect(
            sum([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">10</span>
          );
          <span class="hljs-comment">/* #@range_end(function_returning_function_test) */</span>
          next();
        });
      });
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="-">参照透過性</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'参照透過性'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3 id="-">参照透明性が成立する場面</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'参照透明性が成立する場面'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4 id="-">値の参照透過性</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'値の参照透過性'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(number_has_referential_transparency) */</span>
      expect(
        <span class="hljs-number">2</span>
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-comment">/* #@range_end(number_has_referential_transparency) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h4 id="-">変数の参照透過性</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'変数の参照透明性'</span>, () =&gt; {
      it(<span class="hljs-string">'変数が参照透明性を持つ場合'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(variable_is_referential_transparent) */</span>
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
        expect(
          x 
        ).to.eql(
          x
        );
        <span class="hljs-keyword">var</span> y = x;
        expect(
          y
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(variable_is_referential_transparent) */</span>
        next();
      });
      it(<span class="hljs-string">'変数は参照透明性を持つとは限らない'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(variable_isnt_referential_transparent) */</span>
        <span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">var</span> bar = foo;
        foo = <span class="hljs-number">3</span>;
        expect(
          foo
        ).to.not.eql(
          bar
        );
        <span class="hljs-comment">/* #@range_end(variable_isnt_referential_transparent) */</span>
        next();
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h4 id="-">関数の参照透過性</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'関数の参照透明性'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>succ関数は参照透明性を持つ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'succ関数は参照透明性を持つ'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> succ = (x) =&gt; {
          <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
        };
        expect(
          succ(<span class="hljs-number">1</span>)
        ).to.eql(
          succ(<span class="hljs-number">1</span>)
        );
        expect(
          succ(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1回目の実行</span>
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          succ(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2回目の実行</span>
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
    });
    describe(<span class="hljs-string">'参照透明な関数では同値なものは置換可能である'</span>, () =&gt; {
      it(<span class="hljs-string">'同じ引数のsquare関数は置換可能である'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(equals_replacement)  */</span>
        <span class="hljs-keyword">var</span> square = (n) =&gt; {
          <span class="hljs-keyword">return</span> n * n;
        };
        <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> a = b;
        expect(
          square(a)
        ).to.eql(
          square(b)
        );
        expect(
          square(b)
        ).to.eql(
          square(a)
        );
        expect(
          square(a)
        ).to.eql(
          square(a)
        );
        expect(
          square(b)
        ).to.eql(
          square(b)
        );
        <span class="hljs-comment">/* #@range_end(equals_replacement)  */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h3 id="-">参照透過性を破壊するもの</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'参照透過性を破壊するもの'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>可変なデータは参照透明性を破壊する</p>
<pre><code>node&gt; <span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>];
node&gt; array
[ <span class="hljs-number">1</span> ]
node&gt; array.push(<span class="hljs-number">2</span>);
<span class="hljs-number">2</span>
node&gt; array
[ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'可変なデータは参照透明性を破壊する'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>];
      expect(
        array
      ).to.eql(
        [<span class="hljs-number">1</span>]
      );
      array.push(<span class="hljs-number">2</span>);
      expect(
        array
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>代入操作は参照透明性を破壊する</p>
<pre><code>node&gt; <span class="hljs-keyword">var</span> one = <span class="hljs-number">1</span>;
node&gt; <span class="hljs-keyword">var</span> ichi = one;
node&gt; ichi === one;
<span class="hljs-literal">true</span>
node&gt; one = <span class="hljs-number">2</span>;
<span class="hljs-number">2</span>
node&gt; ichi === one;
<span class="hljs-literal">false</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'代入操作は参照透明性を破壊する'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(assignment_breaks_referential_transparency) */</span>
      <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> add = (y) =&gt; {
        x = x + <span class="hljs-number">1</span>; <span class="hljs-comment">// 代入で変数を更新する</span>
        <span class="hljs-keyword">return</span> x + y;
      };
      <span class="hljs-comment">/* #@range_end(assignment_breaks_referential_transparency)  */</span>
      expect(
        add(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">'参照不透明な関数では同値なものは置換できない'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(unequals_replacement)  */</span>
      <span class="hljs-keyword">var</span> wrapper = (f) =&gt; {
        <span class="hljs-keyword">return</span> (args) =&gt; {
          <span class="hljs-keyword">return</span> f.call(f, args);
        };
      };
      <span class="hljs-keyword">var</span> now = (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now();
      };
      <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> a = b;
      <span class="hljs-keyword">var</span> aResult = wrapper(now)(a);
      <span class="hljs-comment">/* #@range_end(unequals_replacement)  */</span>
      next();
    });
    it(<span class="hljs-string">'Date.now関数は参照透明性を持たない'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(datenow_is_not_transparent) */</span>
      <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Date</span>.now();
      <span class="hljs-comment">/* 時間を1秒進める */</span>
      <span class="hljs-keyword">var</span> sleep = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sleep-async'</span>)();
      sleep.sleep(<span class="hljs-number">2000</span>, () =&gt; {
        expect(
          a
        ).to.not.eql( <span class="hljs-comment">/* 等しくないことをテストしている */</span>
          <span class="hljs-built_in">Date</span>.now()
        );
      });
      <span class="hljs-comment">/* #@range_end(datenow_is_not_transparent) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>命令型な階乗関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'命令型な階乗関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(imperative_factorial) */</span>
      <span class="hljs-keyword">var</span> factorial = (n) =&gt; {
        <span class="hljs-comment">/* 変数resultに結果が入る */</span>
        <span class="hljs-keyword">var</span> result = <span class="hljs-number">1</span>;             
        <span class="hljs-comment">/* 変数timesは反復の回数を数える */</span>
        <span class="hljs-keyword">var</span> times = <span class="hljs-number">1</span>;              
        <span class="hljs-comment">/* while文は反復を処理する */</span>
        <span class="hljs-keyword">while</span>(times &lt; n + <span class="hljs-number">1</span>) {      
          <span class="hljs-comment">/* 変数resultを代入で更新する */</span>
          result = result * times;  
          <span class="hljs-comment">/* 変数timesを代入で更新する */</span>
          times = times + <span class="hljs-number">1</span>;        
        }
        <span class="hljs-keyword">return</span> result;
      };
      <span class="hljs-comment">/* #@range_end(imperative_factorial) */</span>
      expect(
        factorial(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        factorial(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-number">6</span>
      );
      expect(
        factorial(<span class="hljs-number">4</span>)
      ).to.eql(
        <span class="hljs-number">24</span>
      );
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>副作用と入出力</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'副作用と入出力'</span>, () =&gt; {
    it(<span class="hljs-string">'ファイル入出力が参照透明性を破壊する例'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(fileio_breaks_referential_transparency)  */</span>
      <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
      <span class="hljs-keyword">var</span> read = (path) =&gt; {
        <span class="hljs-keyword">var</span> readValue = fs.readFileSync(path);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(readValue);
      };
      <span class="hljs-keyword">var</span> write = (path, n) =&gt; {
        fs.writeFileSync(path, n);
        <span class="hljs-keyword">return</span> n;
      };
      <span class="hljs-comment">/* #@range_end(fileio_breaks_referential_transparency)  */</span>
      write(<span class="hljs-string">'test/resources/io.txt'</span>, <span class="hljs-number">1</span>);
      expect(
        read(<span class="hljs-string">'test/resources/io.txt'</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      write(<span class="hljs-string">'test/resources/io.txt'</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ここでファイルに値を書きこむ</span>
      expect(
        read(<span class="hljs-string">'test/resources/io.txt'</span>)
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
  });
  describe(<span class="hljs-string">'副作用の種類'</span>, () =&gt; {
    describe(<span class="hljs-string">'副作用としての代入'</span>, () =&gt; {
      it(<span class="hljs-string">'配列は参照透明性を破壊する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(array_destroys_referential_transparency) */</span>
        <span class="hljs-keyword">var</span> array = [];
        array.push(<span class="hljs-number">1</span>);
        expect(
          array.pop()
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        array.push(<span class="hljs-number">2</span>);
        expect(
          array.pop()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(array_destroys_referential_transparency) */</span>
        next();
      });
      it(<span class="hljs-string">'配列の状態を表示する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(array_destroys_referential_transparency_log) */</span>
        <span class="hljs-keyword">var</span> add = (n,m) =&gt; {
          <span class="hljs-keyword">return</span> n + m;
        };
        <span class="hljs-keyword">var</span> array = [];
        array.push(<span class="hljs-number">1</span>);
        <span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [ 1 ]</span>
        expect(
          add(array.pop(),<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        array.push(<span class="hljs-number">2</span>);
        <span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [ 2 ]</span>
        expect(
          add(array.pop(),<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(array_destroys_referential_transparency_log) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3 id="-">参照透明性を保証する</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'参照透明性を保証する'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h4 id="-">値の参照透過性を保証する（可変なデータの排除）</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'値の参照透過性を保証する（可変なデータの排除）'</span>, () =&gt;  {
      it(<span class="hljs-string">'不変なデータ型'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_datatype) */</span>
        <span class="hljs-keyword">var</span> empty =  (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        };
        <span class="hljs-keyword">var</span> get = (key, obj) =&gt; {
          <span class="hljs-keyword">return</span> obj(key);
        };
        <span class="hljs-keyword">var</span> set = (key, value, obj) =&gt; {
          <span class="hljs-keyword">return</span> (key2) =&gt; {
            <span class="hljs-keyword">if</span>(key === key2) {
              <span class="hljs-keyword">return</span> value;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> get(key2,obj);
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(immutable_datatype) */</span>
        next();
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h4 id="-">変数の参照透過性を保証する(代入の排除)</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'変数の参照透過性を保証する(代入の排除)'</span>, () =&gt; {
      it(<span class="hljs-string">'命令型プログラミングによる乗算'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(imperative_addition) */</span>
        <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
          <span class="hljs-keyword">var</span> times = <span class="hljs-number">0</span>;          
          <span class="hljs-keyword">var</span> result = x;         

          <span class="hljs-comment">/* while文で反復を処理する */</span>
          <span class="hljs-keyword">while</span>(times &lt; y){       
            result = result + <span class="hljs-number">1</span>;
            times = times + <span class="hljs-number">1</span>;    
          };
          <span class="hljs-keyword">return</span> result;
        };
        <span class="hljs-comment">/* #@range_end(imperative_addition) */</span>
        expect(
          add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
        ).to.eql(
          <span class="hljs-number">5</span>
        );
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">4</span>;
        <span class="hljs-keyword">var</span> y = <span class="hljs-number">5</span>;
        expect(
          add(x,y)
        ).to.eql(
          <span class="hljs-number">9</span>
        );
        expect(
          x
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        next();
      });
      it(<span class="hljs-string">'関数型プログラミングによる乗算'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(functional_addition) */</span>
        <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
          <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">1</span>){
            <span class="hljs-keyword">return</span> x;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* 新しい引数でadd関数を再帰的に呼び出す */</span>
            <span class="hljs-keyword">return</span> add(x + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>); 
          }
        };
        <span class="hljs-comment">/* #@range_end(functional_addition) */</span>
        expect(add(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)).to.eql(<span class="hljs-number">3</span>);
        expect(add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)).to.eql(<span class="hljs-number">4</span>);
        expect(add(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)).to.eql(<span class="hljs-number">5</span>);
        expect(add(<span class="hljs-number">12</span>,<span class="hljs-number">5</span>)).to.eql(<span class="hljs-number">17</span>);
        next();
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4 id="-">関数の参照透過性を保証する（副作用の分離）</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'関数の参照透過性を保証する（副作用の分離）'</span>, () =&gt;  {
      it(<span class="hljs-string">'副作用が分離されていないコード'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(age_sideeffect) */</span>
        <span class="hljs-keyword">var</span> age = (birthYear) =&gt; {
          <span class="hljs-comment">/* todayは現時点の日付データ */</span>
          <span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
          <span class="hljs-comment">/* getFullYear関数は日付データにもとづいて現時点の西暦を返す */</span>
          <span class="hljs-keyword">var</span> thisYear = today.getFullYear(); 
          <span class="hljs-keyword">return</span> thisYear - birthYear;
        };
        <span class="hljs-comment">/* #@range_end(age_sideeffect) */</span>
        next();
      });
      it(<span class="hljs-string">'副作用が分離されているコード'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(age_without_sideeffect) */</span>
        <span class="hljs-keyword">var</span> age = (birthYear, thisYear) =&gt; {
          <span class="hljs-keyword">return</span> thisYear - birthYear;
        };
        <span class="hljs-comment">/* #@range_end(age_without_sideeffect) */</span>
        next();
      });
      it(<span class="hljs-string">'画面出力を分離する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(tap_console_log) */</span>
        <span class="hljs-keyword">var</span> tap = (target, sideEffect) =&gt; {
          sideEffect(target);
          <span class="hljs-keyword">return</span> target;
        };
        <span class="hljs-keyword">var</span> logger = (value) =&gt;{
          <span class="hljs-built_in">console</span>.log(value);
        };
        <span class="hljs-comment">/* #@range_end(tap_console_log) */</span>
        next();
      });
      describe(<span class="hljs-string">'副作用を関数のスコープに閉じこめる'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(action) */</span>
        <span class="hljs-keyword">var</span> action = (io) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; { <span class="hljs-comment">// 入出力を関数で包み込む</span>
            <span class="hljs-keyword">return</span> io;
          };
        };
        <span class="hljs-comment">/* #@range_end(action) */</span>
        <span class="hljs-comment">/* #@range_begin(reader_and_writer) */</span>
        <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// ファイルを操作するライブラリーfsをロードする</span>
        <span class="hljs-keyword">var</span> read = (path) =&gt; { <span class="hljs-comment">// ファイルを読み込む操作を関数で包みこむ</span>
          <span class="hljs-keyword">return</span> fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
        };
        <span class="hljs-keyword">var</span> write = (path, content) =&gt; { <span class="hljs-comment">// ファイルを書き込む操作を関数で包みこむ</span>
          <span class="hljs-keyword">return</span> fs.writeFileSync(path,content);
        };
        <span class="hljs-keyword">var</span> reader = (path) =&gt; { <span class="hljs-comment">// ファイルを読み込む操作を関数で包みこむ</span>
          <span class="hljs-keyword">return</span> action(fs.readFileSync(path, <span class="hljs-string">'utf8'</span>));
        };
        <span class="hljs-keyword">var</span> writer = (path, content) =&gt; { <span class="hljs-comment">// ファイルを書き込む操作を関数で包みこむ</span>
          <span class="hljs-keyword">return</span> action(fs.writeFileSync(path,content));
        };
        <span class="hljs-comment">/* #@range_end(reader_and_writer) */</span>
        <span class="hljs-comment">/* #@range_begin(fileio_actions) */</span>
        <span class="hljs-keyword">var</span> fileio_actions = () =&gt; {
          write(<span class="hljs-string">'test/resources/test.txt'</span>, <span class="hljs-number">1</span>);
          read(<span class="hljs-string">'test/resources/test.txt'</span>);
          write(<span class="hljs-string">'test/resources/test.txt'</span>, <span class="hljs-number">2</span>);
          <span class="hljs-keyword">return</span> read(<span class="hljs-string">'test/resources/test.txt'</span>);
        };
        <span class="hljs-comment">/* #@range_end(fileio_actions) */</span>
        expect(
          fileio_actions()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          fileio_actions()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>describe(‘状態モナド’, () =&gt; {
  var bind = (operate, continues) =&gt; {
    return (stack) =&gt; {
      var newState = operate(stack);
      return continues(newState.value)(newState.stack);
    };
  };
  var unit = (n) =&gt; {
    return (stack) =&gt; {
      return {
        value: n,
        stack: stack
      };
    };
  };
  var push = (n) =&gt; {
    return (stack) =&gt; {
      return unit(undefined)([n].concat(stack));
    };
  };
  var pop = () =&gt; {
    return (stack) =&gt; {
      return unit(stack[0])(stack.slice(1,stack.length));
    };
  };
  var run = (operate, initState) =&gt; {
    return operate(initState);
  };
  var empty = [];</p>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>  it(‘状態を明示化する’, (next) =&gt;{
    /<em> #@range_begin(explicit_state) </em>/
    var push = (n,stack) =&gt; {
      return {
        value: undefined,
        stack: [n].concat(stack)
      };
    };
    var pop = (stack) =&gt; {
      return {
        value: stack[0],
        stack: stack.slice(1,stack.length)
      };
    };
    var empty = [];
    var state1 = push(2, empty);
    var state2 = push(3, state1.stack);
    var state3 = pop(state2.stack);
    var state4 = pop(state3.stack);
    expect(
      state4.value
    ).to.eql(
      2
    );
    /<em> #@range_end(explicit_state) </em>/
    next();
  });
  it(‘継続を用いる’, (next) =&gt;{
    var push = (n,stack) =&gt; {
      return unit(undefined)([n].concat(stack));
    };
    var pop = (stack) =&gt; {
      return unit(stack[0])(stack.slice(1,stack.length));
    };</p>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <pre><code><span class="hljs-comment">/* #@range_begin(bind_defined_by_continuation) */</span>
<span class="hljs-keyword">var</span> bind = (state, continues) =&gt; {
  <span class="hljs-keyword">return</span> continues(state);
};
expect(
  bind(push(<span class="hljs-number">2</span>,empty), (state1) =&gt; {
    <span class="hljs-keyword">return</span> bind(push(<span class="hljs-number">3</span>, state1.stack), (state2) =&gt;{
      <span class="hljs-keyword">return</span> bind(pop(state2.stack), (state3) =&gt; {
        <span class="hljs-keyword">return</span> bind(pop(state3.stack), (state4) =&gt; {
          <span class="hljs-keyword">return</span> state4;
        });
      });
    });
  })
).to.eql(
  {
    value: <span class="hljs-number">2</span>,
    stack: []
  }
);
<span class="hljs-comment">/* #@range_end(bind_defined_by_continuation) */</span>
next();
</code></pre><p>  });
  it(‘カリー化’, (next) =&gt;{
    /<em> #@range_begin(curring) </em>/
    var bind = (operate, continues) =&gt; {
      return (stack) =&gt; {
        var newState = operate(stack);
        return continues(newState)(newState.stack);
      };
    };
    var unit = (n) =&gt; {
      return (stack) =&gt; {
        return {
          value: n,
          stack: stack
        };
      };
    };
    var push = (n) =&gt; {
      return (stack) =&gt; {
        return unit(undefined)([n].concat(stack));
      };
    };
    var pop = () =&gt; {
      return (stack) =&gt; {
        return unit(stack[0])(stack.slice(1,stack.length));
      };
    };
    expect(
      bind(push(2), (state1) =&gt; {
        return bind(push(3), (state2) =&gt;{
          return bind(pop(), (state3) =&gt; {
            return bind(pop(), (state4) =&gt; {
              return (stack) =&gt; {
                return unit(state4.value)(stack);
              };
            });
          });
        });
      })(empty)
    ).to.eql(
      {
        value: 2,
        stack: []
      }
    );
    /<em> #@range_end(curring) </em>/
    next();
  });
  it(‘中間状態を隠蔽する’, (next) =&gt;{
    /<em> #@range_begin(hide_internal_state) </em>/
    var bind = (operate, continues) =&gt; {
      return (stack) =&gt; {
        var newState = operate(stack);
        return continues(newState.value)(newState.stack);
      };
    };
    var computation = bind(push(2), () =&gt; {
      return bind(push(3), () =&gt;{
        return bind(pop(), (state3) =&gt; {
          return bind(pop(), (state4) =&gt; {
            return unit(state4);
          });
        });
      });
    });
    expect(
      computation(empty)
    ).to.eql(
      {
        value: 2,
        stack: []
      }
    );
    /<em> #@range_end(hide_internal_state) </em>/
    next();
  });
  it(‘計算を合成する’, (next) =&gt;{
    /<em> #@range_begin(combining_monad) </em>/
    var computation1 = bind(push(2), () =&gt; {
      return bind(push(3), () =&gt; {
        return bind(push(4), () =&gt; {
          return unit();
        });
      });
    });
    var computation2 = bind(pop(), (state1) =&gt; {
      return bind(pop(), (state2) =&gt; {
        return unit(state2);
      });
    });
    var combine = (a, b) =&gt; {
      return (stack) =&gt; {
        var initialState = unit(undefined)(stack);
        var newState = a(stack);
        return b(newState.stack);
      };
    };
    expect(
      combine(computation1,computation2)(empty)
    ).to.eql(
      {
        value: 3,
        stack: [2]
      }
    );
    /<em> #@range_end(combining_monad) </em>/
    next();
  });
  it(‘逆ポーランド電卓’, (next) =&gt;{
    /<em> #@range_begin(revserse_polish) </em>/
    var add = bind(pop(), (state1) =&gt; {
      return bind(pop(), (state2) =&gt; {
        return unit(state1 + state2);
      });
    });
    var subtract = bind(pop(), (state1) =&gt; {
      return bind(pop(), (state2) =&gt; {
        return unit(state1 - state2);
      });
    });
    var multiply = bind(pop(), (state1) =&gt; {
      return bind(pop(), (state2) =&gt; {
        return unit(state1 <em> state2);
      });
    });
    var divide = bind(pop(), (state1) =&gt; {
      return bind(pop(), (state2) =&gt; {
        return unit(state1 / state2);
      });
    });
    expect(
      add([1,2])
    ).to.eql(
      {
        value: 3,
        stack: []
      }
    );
    /</em> #@range_end(revserse_polish) */
    next();
  });
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h2 id="-">関数型プログラミングの利点</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数型プログラミングの利点'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="-">高いモジュール性</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'モジュール性とは何か'</span>, () =&gt; {
    it(<span class="hljs-string">'名前空間としてのモジュール'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(module_as_namespace) */</span>
      <span class="hljs-comment">/* 数値計算のモジュール */</span>
      <span class="hljs-keyword">var</span> math = {
        add: (n, m) =&gt; { <span class="hljs-comment">// 数値の足し算</span>
          <span class="hljs-keyword">return</span> n + m;
        },
        multiply: (n, m) =&gt; {
          <span class="hljs-keyword">return</span> n * m;
        }
      };
      <span class="hljs-comment">/* 文字列操作のモジュール */</span>
      <span class="hljs-keyword">var</span> string = {
        add: (strL, strR) =&gt; { <span class="hljs-comment">// 文字列の連結</span>
          <span class="hljs-keyword">return</span> strL.concat(strR);
        },
        multiply: (str, nTimes) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      };
      <span class="hljs-comment">/* #@range_end(module_as_namespace) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4 id="-">部品の独立性</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'部品の独立性'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
        <span class="hljs-keyword">return</span> (arg) =&gt; {
          <span class="hljs-keyword">return</span> ! predicate(arg);
        };
      };
      <span class="hljs-keyword">var</span> array = {
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> [head].concat(tail);
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> [];
        },
        head: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> anArray[<span class="hljs-number">0</span>];
        },
        tail: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> anArray.slice(<span class="hljs-number">1</span>,array.length(anArray));
        },
        length: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> anArray.length;
        },
        isEmpty: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> array.length(anArray) === <span class="hljs-number">0</span>;
        },
        fromString: (str) =&gt; {
          <span class="hljs-keyword">if</span>(string.isEmpty(str)) {
            <span class="hljs-keyword">return</span> array.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> array.cons(string.head(str), 
                              array.fromString(string.tail(str)));
          }
        },
        takeWhile: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> (predicate) =&gt; {
            <span class="hljs-keyword">if</span>(array.isEmpty(anArray)){
              <span class="hljs-keyword">return</span> array.empty(); 
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> head = array.head(anArray);
              <span class="hljs-keyword">var</span> tail = array.tail(anArray);
              <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">return</span> array.cons(head,
                                  array.takeWhile(tail)(predicate));
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> array.empty();
              }
            }
          };
        },
        dropWhile: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> (predicate) =&gt; {
            <span class="hljs-keyword">if</span>(array.isEmpty(anArray)){
              <span class="hljs-keyword">return</span> [];
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> head = array.head(anArray);
              <span class="hljs-keyword">var</span> tail = array.tail(anArray);
              <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">return</span> array.dropWhile(tail)(predicate);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> anArray;
              }
            };
          };
        },
        span: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> (predicate) =&gt; {
            <span class="hljs-keyword">if</span>(array.isEmpty(anArray)){
              <span class="hljs-keyword">return</span> [];
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> head = array.head(anArray);
              <span class="hljs-keyword">var</span> tail = array.tail(anArray);
              <span class="hljs-keyword">return</span> [array.takeWhile(anArray)(predicate),
                      array.dropWhile(anArray)(predicate)];
            };
          };
        },
        <span class="hljs-keyword">break</span>: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> (predicate) =&gt; {
            <span class="hljs-keyword">return</span> array.span(anArray)(not(predicate));
          };
        },  
        lines: (xs) =&gt; {
          <span class="hljs-keyword">var</span> isNewline = (ch) =&gt; {
            <span class="hljs-keyword">return</span> ch === <span class="hljs-string">'\n'</span>;
          };
          <span class="hljs-keyword">var</span> apair = array.break(xs)(isNewline);
          <span class="hljs-keyword">var</span> ys = apair[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> zs = apair[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span>(array.isEmpty(zs)){
            <span class="hljs-keyword">return</span> [ys];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> head = array.head(zs);
            <span class="hljs-keyword">var</span> tail = array.tail(zs);
            <span class="hljs-keyword">return</span> array.cons(ys, array.lines(tail));
          };
        }
      };
      <span class="hljs-keyword">var</span> string = {
        head: (str) =&gt; {
          <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>];
        },
        tail: (str) =&gt; {
          <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">1</span>);
        },
        isEmpty: (str) =&gt; {
          <span class="hljs-keyword">return</span> str.length === <span class="hljs-number">0</span>;
        },
        add: (strL, strR) =&gt; {
          <span class="hljs-keyword">return</span> strL + strR;
        },
        toArray: (str) =&gt; {
          <span class="hljs-keyword">if</span>(string.isEmpty(str)) {
            <span class="hljs-keyword">return</span> [];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> array.cons(string.head(str),
                              string.toArray(string.tail(str)));
          }
        },
        fromArray: (anArray) =&gt; {
          <span class="hljs-keyword">return</span> anArray.reduce((accumulator, item) =&gt; {
            <span class="hljs-keyword">return</span> string.add(accumulator, item);
          }, <span class="hljs-string">""</span>);
        },
        lines: (str) =&gt; {
          <span class="hljs-keyword">var</span> isNewline = (ch) =&gt; {
            <span class="hljs-keyword">return</span> ch === <span class="hljs-string">'\n'</span>;
          };
          <span class="hljs-keyword">var</span> apair = array.break(array.fromString(str))(isNewline);
          <span class="hljs-keyword">var</span> ys = apair[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> zs = apair[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span>(array.isEmpty(zs)){
            <span class="hljs-keyword">return</span> [string.fromArray(ys)];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> tail = array.tail(zs);
            <span class="hljs-keyword">return</span> array.cons(string.fromArray(ys), 
                              string.lines(string.fromArray(tail)));
          };
        }
      };
      describe(<span class="hljs-string">'array'</span>, () =&gt; {
        it(<span class="hljs-string">'array#head'</span>, (next) =&gt; {
          expect(
            array.head([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          next();
        });
        it(<span class="hljs-string">'array#tail'</span>, (next) =&gt; {
          expect(
            array.tail([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
          );
          next();
        });
        it(<span class="hljs-string">'array#cons'</span>, (next) =&gt; {
          expect(
            array.cons(<span class="hljs-number">0</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])
          ).to.eql(
            [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
          );
          next();
        });
        it(<span class="hljs-string">'array#fromString'</span>, (next) =&gt; {
          expect(
            array.fromString(<span class="hljs-string">"123"</span>)
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
          );
          next();
        });
        it(<span class="hljs-string">'array#takeWhile'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; 
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          <span class="hljs-keyword">var</span> odd = not(even);
          expect(
            array.takeWhile(theArray)(odd)
          ).to.eql(
            [<span class="hljs-number">1</span>]
          );
          next();
        });
        it(<span class="hljs-string">'array#dropWhile'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; 
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          <span class="hljs-keyword">var</span> odd = not(even);
          expect(
            array.dropWhile(theArray)(odd)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
          );
          next();
        });
        it(<span class="hljs-string">'array#span'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; 
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          expect(
            array.span(theArray)(even)
          ).to.eql(
            [[],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
          );
          <span class="hljs-keyword">var</span> odd = not(even);
          expect(
            array.span(theArray)(odd)
          ).to.eql(
            [[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
          );
          next();
        });
        it(<span class="hljs-string">'array#break'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; 
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          expect(
            array.break(theArray)(even)
          ).to.eql(
            [[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
          );
          <span class="hljs-keyword">var</span> odd = not(even);
          expect(
            array.break(theArray)(odd)
          ).to.eql(
            [[],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
          );
          <span class="hljs-keyword">var</span> isNewline = (ch) =&gt; {
            <span class="hljs-keyword">return</span> ch === <span class="hljs-string">'\n'</span>;
          };
          expect(
            array.break([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'\n'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>])(isNewline)
          ).to.eql(
            [[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>],[<span class="hljs-string">'\n'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>]]
          );
          next();
        });
        it(<span class="hljs-string">'array#lines'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theArray = array.fromString(<span class="hljs-string">"abc\ndef"</span>); 
          expect(
            array.lines(theArray)
          ).to.eql(
            [ [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> ], [ <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span> ] ]
          );
          next();
        });
      });
      describe(<span class="hljs-string">'string'</span>, () =&gt; {
        it(<span class="hljs-string">'string#head'</span>, (next) =&gt; {
          expect(
            string.head(<span class="hljs-string">"abc"</span>)
          ).to.eql(
            <span class="hljs-string">'a'</span>
          );
          next();
        });
        it(<span class="hljs-string">'string#tail'</span>, (next) =&gt; {
          expect(
            string.tail(<span class="hljs-string">"abc"</span>)
          ).to.eql(
            <span class="hljs-string">"bc"</span>
          );
          next();
        });
        it(<span class="hljs-string">'string#fromArray'</span>, (next) =&gt; {
          expect(
            string.fromArray([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])
          ).to.eql(
            <span class="hljs-string">"abc"</span>
          );
          next();
        });
        it(<span class="hljs-string">'string#toArray'</span>, (next) =&gt; {
          expect(
            string.toArray(<span class="hljs-string">"abc"</span>)
          ).to.eql(
            [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]
          );
          next();
        });
        it(<span class="hljs-string">'string#lines'</span>, (next) =&gt; {
          expect(
            string.lines(<span class="hljs-string">"abc\ndef"</span>)
          ).to.eql(
            [ <span class="hljs-string">'abc'</span>, <span class="hljs-string">'def'</span> ]
          );
          next();
        });
      });
    });
    it(<span class="hljs-string">'統一的なインターフェイス'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(books_as_array) */</span>
      <span class="hljs-keyword">var</span> books = [
        {name: <span class="hljs-string">"こころ"</span>, author: [<span class="hljs-string">"夏目漱石"</span>], genre: <span class="hljs-string">"文学"</span>},
        {name: <span class="hljs-string">"夢十夜"</span>, author: [<span class="hljs-string">"夏目漱石"</span>], genre: <span class="hljs-string">"文学"</span>},
        {name: <span class="hljs-string">"ソクラテスの弁明"</span>, author: [<span class="hljs-string">"プラトン"</span>], genre: <span class="hljs-string">"哲学"</span>},
        {name: <span class="hljs-string">"国家"</span>, author: [<span class="hljs-string">"プラトン"</span>], genre: <span class="hljs-string">"哲学"</span>},
        {name: <span class="hljs-string">"プログラミング言語C"</span>, author: [<span class="hljs-string">"カーニハン"</span>,<span class="hljs-string">"リッチー"</span>], genre: <span class="hljs-string">"コンピュータ"</span>},

        {name: <span class="hljs-string">"計算機プログラムの構造と解釈"</span>, author: [<span class="hljs-string">"サスマン"</span>,<span class="hljs-string">"エイベルソン"</span>], genre: <span class="hljs-string">"コンピュータ"</span>},
      ];
      <span class="hljs-comment">/* #@range_end(books_as_array) */</span>
      <span class="hljs-keyword">var</span> get = (object) =&gt; {
        <span class="hljs-keyword">return</span> (key) =&gt; {
          <span class="hljs-keyword">return</span> object[key];
        };
      };
      <span class="hljs-comment">/* #@range_begin(pluck) */</span>
      <span class="hljs-keyword">var</span> pluck = (key) =&gt; {
        <span class="hljs-keyword">return</span> (object) =&gt; {
          <span class="hljs-keyword">return</span> object[key];
        };
      };
      <span class="hljs-comment">/* #@range_end(pluck) */</span>
      <span class="hljs-comment">/* #@range_begin(mapWith) */</span>
      <span class="hljs-keyword">var</span> mapWith = (func) =&gt; {
        <span class="hljs-keyword">return</span> (array) =&gt; {
          <span class="hljs-keyword">return</span> array.map(func);
        };
      };
      <span class="hljs-comment">/* #@range_end(mapWith) */</span>
      <span class="hljs-keyword">var</span> multiplier = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">return</span> n * m;
        };
      };
      <span class="hljs-keyword">var</span> square = (n) =&gt; {
        <span class="hljs-keyword">return</span> multiplier(n)(n);
      };
      expect(
        mapWith(square)([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>]
      );
      expect(
        <span class="hljs-comment">/* #@range_begin(mapWith_pluck) */</span>
        mapWith(pluck(<span class="hljs-string">"name"</span>))(books)
        <span class="hljs-comment">/* #@range_end(mapWith_pluck) */</span>
      ).to.eql(
        [<span class="hljs-string">'こころ'</span>,<span class="hljs-string">'夢十夜'</span>,<span class="hljs-string">'ソクラテスの弁明'</span>,<span class="hljs-string">'国家'</span>,<span class="hljs-string">'プログラミング言語C'</span>,<span class="hljs-string">'計算機プログラムの構造と解釈'</span>]
      );
      <span class="hljs-comment">/* #@range_begin(filterWith) */</span>
      <span class="hljs-keyword">var</span> filterWith = (predicate) =&gt; {
        <span class="hljs-keyword">return</span> (array) =&gt; {
          <span class="hljs-keyword">return</span> array.filter(predicate);
        };
      };
      <span class="hljs-comment">/* #@range_end(filterWith) */</span>
      <span class="hljs-keyword">var</span> isEqual = (a,b) =&gt; {
        <span class="hljs-keyword">return</span> a === b;
      };
      expect(
        <span class="hljs-comment">/* #@range_begin(filterWith_pluck) */</span>
        filterWith((book) =&gt; { 
          <span class="hljs-keyword">return</span> pluck(<span class="hljs-string">"genre"</span>)(book) ===  <span class="hljs-string">"文学"</span>;
        })(books)
        <span class="hljs-comment">/* #@range_end(filterWith_pluck) */</span>
      ).to.eql(
        <span class="hljs-comment">/* #@range_begin(filterWith_pluck_result) */</span>
        [
          {name: <span class="hljs-string">"こころ"</span>, author: [<span class="hljs-string">"夏目漱石"</span>], genre: <span class="hljs-string">"文学"</span>},
          {name: <span class="hljs-string">"夢十夜"</span>, author: [<span class="hljs-string">"夏目漱石"</span>], genre: <span class="hljs-string">"文学"</span>},
        ]
        <span class="hljs-comment">/* #@range_end(filterWith_pluck_result) */</span>
      );
      expect(
        <span class="hljs-comment">/* #@range_begin(map_filter) */</span>
        mapWith(pluck(<span class="hljs-string">"name"</span>))(filterWith((book) =&gt; { 
          <span class="hljs-keyword">return</span> pluck(<span class="hljs-string">"genre"</span>)(book) ===  <span class="hljs-string">"哲学"</span>;
        })(books))
        <span class="hljs-comment">/* #@range_end(map_filter) */</span>
      ).to.eql(
        <span class="hljs-comment">/* #@range_begin(map_filter_result) */</span>
        [<span class="hljs-string">"ソクラテスの弁明"</span>, <span class="hljs-string">"国家"</span>]
        <span class="hljs-comment">/* #@range_end(map_filter_result) */</span>
      );
      
      <span class="hljs-comment">/* #@range_begin(doesContain) */</span>
      <span class="hljs-keyword">var</span> doesContain = (value) =&gt; {
        <span class="hljs-keyword">return</span> (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
            <span class="hljs-keyword">return</span> accumulator || (item === value);
          },<span class="hljs-literal">false</span>);
        };
      };
      <span class="hljs-comment">/* #@range_end(doesContain) */</span>
      <span class="hljs-keyword">var</span> doesMatch = (predicate) =&gt; {
        <span class="hljs-keyword">return</span> (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
            <span class="hljs-keyword">return</span> accumulator || predicate(item);
          },<span class="hljs-literal">false</span>);
        };
      };
      expect(
        <span class="hljs-comment">/* #@range_begin(filterWith_doesContain) */</span>
        filterWith((book) =&gt; { 
          <span class="hljs-keyword">return</span> doesContain(<span class="hljs-string">"カーニハン"</span>)(pluck(<span class="hljs-string">"author"</span>)(book));
        })(books)
        <span class="hljs-comment">/* #@range_end(filterWith_doesContain) */</span>
      ).to.eql(
        <span class="hljs-comment">/* #@range_begin(filterWith_doesContain_result) */</span>
        [
          {name: <span class="hljs-string">"プログラミング言語C"</span>, author: [<span class="hljs-string">"カーニハン"</span>,<span class="hljs-string">"リッチー"</span>], genre: <span class="hljs-string">"コンピュータ"</span>},
        ]
        <span class="hljs-comment">/* #@range_end(filterWith_doesContain_result) */</span>
      );
      <span class="hljs-comment">/* #@range_begin(findWith) */</span>
      <span class="hljs-keyword">var</span> findWith = (predicate) =&gt; {
        <span class="hljs-keyword">return</span> (array) =&gt; {
          <span class="hljs-keyword">return</span> array.filter(predicate)[<span class="hljs-number">0</span>];
        };
      };
      <span class="hljs-comment">/* #@range_end(findWith) */</span>
      expect(
        findWith((book) =&gt; { 
          <span class="hljs-keyword">return</span> pluck(<span class="hljs-string">"genre"</span>)(book) === <span class="hljs-string">"哲学"</span>;
        })(books)
      ).to.eql(
        {name: <span class="hljs-string">"ソクラテスの弁明"</span>, author: [<span class="hljs-string">"プラトン"</span>], genre: <span class="hljs-string">"哲学"</span>}
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h4 id="-">部品の汎用性</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'部品の汎用性'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>it(‘単純なインターフェイス’, (next) =&gt; {
  var constant = (any) =&gt; {
    return (_) =&gt; {
      return any;
    };
  };
  /<em> #@range_begin(add_uncurried) </em>/
  var add = (n,m) =&gt; {
    return n + m;
  };
  /<em> #@range_end(add_uncurried) </em>/
  expect(
    add(1,2)
  ).to.eql(
    3
  );
  /<em> #@range_begin(add_curried) </em>/
  var adder = (n) =&gt; {
    return (m) =&gt; {
      return n + m;
    };
  };
  /<em> #@range_end(add_curried) </em>/
  expect(
    adder(1)(2)
  ).to.eql(
    3
  );
  /<em> #@range_begin(succ_defined) </em>/
  var succ = adder(1); 
  /<em> #@range_end(succ_defined) </em>/
  expect(
    succ(1)
  ).to.eql(
    2
  );
  /<em> #@range_begin(multiply_uncurried) </em>/
  var multiply = (n,m) =&gt; {
    return n <em> m;
  };
  /</em> #@range_end(multiply_uncurried) <em>/
  expect(
    multiply(2,3)
  ).to.eql(
    6
  );
  /</em> #@range_begin(multiply_curried) <em>/
  var multiplier = (n) =&gt; {
    return (m) =&gt; {
      return n </em> m;
    };
  };
  /<em> #@range_end(multiply_curried) </em>/
  var square = (n) =&gt; {
    return multiply(n,n);
  };
  var cube = (n) =&gt; {
    return multiplier(n)(square(n));
  };
  expect(
    cube(2)
  ).to.eql(
    8
  );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'reduceによる反復処理の汎用化'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>forEachメソッドによるsumの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'forEachメソッドによるsumの定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(sum_in_array_while) */</span>
          <span class="hljs-keyword">var</span> sum = (array) =&gt; {
            <span class="hljs-comment">/* 結果を格納する変数 */</span>
            <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
            <span class="hljs-comment">/* 反復した回数を格納する変数 */</span>
            <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; 
            <span class="hljs-keyword">while</span>(index &lt; array.length) {
              <span class="hljs-comment">/* 変数resultを代入で更新する */</span>
              result = result + array[index];
              <span class="hljs-comment">/* 反復回数を更新する */</span>
              index = index + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">return</span> result;
          };
          <span class="hljs-comment">/* #@range_end(sum_in_array_while)  */</span>
          expect(
            sum([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">10</span>
          );
          expect(
            sum([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">10</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>reduceメソッドによるsumの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'reduceメソッドによるsumの定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(sum_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> sum = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce(<span class="hljs-comment">/* 第1引数に関数を渡す */</span>
              (accumulator, item) =&gt; { 
                <span class="hljs-keyword">return</span> accumulator + item; <span class="hljs-comment">/* 足し算を実行する */</span>
              },<span class="hljs-number">0</span>); <span class="hljs-comment">// 第2引数には、蓄積変数の初期値として0を渡す </span>
          };
          <span class="hljs-comment">/* #@range_end(sum_in_array_reduce)  */</span>
          expect(
            sum([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">10</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>product関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'product関数の定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(product_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> product = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> accumulator * item; <span class="hljs-comment">/* かけ算を実行する */</span>
            }, <span class="hljs-number">1</span>); <span class="hljs-comment">// 第2引数には、蓄積変数の初期値として1を渡す </span>
          };
          <span class="hljs-comment">/* #@range_end(product_in_array_reduce)  */</span>
          <span class="hljs-comment">/* #@range_begin(product_in_array_reduce_test) */</span>
          expect(
            product([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">24</span>
          );
          <span class="hljs-comment">/* #@range_end(product_in_array_reduce_test)  */</span>
          next();
        });
        it(<span class="hljs-string">'allの定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(all_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> all = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> accumulator &amp;&amp; item; <span class="hljs-comment">/* 論理和を実行する */</span>
            }); <span class="hljs-comment">/* 第2引数を指定していない場合は、
                   配列の先頭要素が変数accumulatorの初期値になる */</span>
          };
          <span class="hljs-comment">/* #@range_end(all_in_array_reduce)  */</span>
          expect(
            all([<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>])
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          expect(
            <span class="hljs-comment">/* #@range_begin(all_in_array_reduce_test) */</span>
            all([<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>])
            <span class="hljs-comment">/* #@range_end(all_in_array_reduce_test) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(all_in_array_reduce_test_result) */</span>
            <span class="hljs-literal">false</span>
            <span class="hljs-comment">/* #@range_end(all_in_array_reduce_test_result) */</span>
          );
          next();
        });
        it(<span class="hljs-string">'maxの定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(max_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> max = (array) =&gt; {
            <span class="hljs-keyword">var</span> bigger = (n,m) =&gt; {
              <span class="hljs-keyword">if</span>(n &gt; m) {
                <span class="hljs-keyword">return</span> n;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> m;
              };
            };
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> bigger(accumulator, item);
            });
          };
          <span class="hljs-comment">/* #@range_end(max_in_array_reduce)  */</span>
          expect(
            max([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          expect(
            max([<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>])
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          next();
        });
        it(<span class="hljs-string">'reverseの定義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(reverse_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> reverse = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, currentValue) =&gt; {
              <span class="hljs-keyword">return</span> [currentValue].concat(accumulator);
            },[]);
          };
          expect(reverse([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])).to.eql([<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);
          <span class="hljs-comment">/* #@range_end(reverse_in_array_reduce)  */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>map関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'map関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-comment">/* #@range_begin(map_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> map = (transform) =&gt; {
            <span class="hljs-keyword">return</span> (array) =&gt; {
              <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
                <span class="hljs-keyword">return</span> accumulator.concat(transform(item));
              },[]); <span class="hljs-comment">// 蓄積変数の初期値として空の配列[]を指定する</span>
            };
          };
          <span class="hljs-comment">/* #@range_end(map_in_array_reduce)  */</span>
          expect(
            map(succ)([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-keyword">var</span> constant = (any) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> any;
            };
          };
          <span class="hljs-keyword">var</span> alwaysOne = constant(<span class="hljs-number">1</span>); 
          expect(
            <span class="hljs-comment">/* #@range_begin(map_in_array_reduce_test) */</span>
            map(succ)([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])
            <span class="hljs-comment">/* #@range_end(map_in_array_reduce_test) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(map_in_array_reduce_test_result) */</span>
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]
            <span class="hljs-comment">/* #@range_end(map_in_array_reduce_test_result) */</span>
          );
          next();
        });
        it(<span class="hljs-string">'reduceによるfilterの定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
          };
          <span class="hljs-comment">/* #@range_begin(filter_in_array_reduce) */</span>
          <span class="hljs-keyword">var</span> filter = (array) =&gt; {
            <span class="hljs-keyword">return</span> (predicate) =&gt; {
              <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
                <span class="hljs-keyword">if</span>(predicate(item)) {
                  <span class="hljs-keyword">return</span> accumulator.concat(item);
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> accumulator;
                }
              },[]); <span class="hljs-comment">// 蓄積変数の初期値として空の配列[]を指定する</span>
            };
          };
          <span class="hljs-comment">/* #@range_end(filter_in_array_reduce)  */</span>
          expect(
            filter([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])(even)
          ).to.eql(
            [<span class="hljs-number">2</span>]
          );
          next();
        });
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h3 id="-">部品を組み合わせる</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'部品を組み合わせる'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h4 id="-">関数適用で部品を組み合わせる</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'関数適用で部品を組み合わせる'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> map = (transform) =&gt; {
          <span class="hljs-keyword">return</span> (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> accumulator.concat(transform(item));
            },[]); <span class="hljs-comment">// 蓄積変数の初期値として空の配列[]を指定する</span>
          };
        };
        <span class="hljs-keyword">var</span> sum = (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; { <span class="hljs-comment">// 第1引数に関数を渡す</span>
            <span class="hljs-keyword">return</span> accumulator + item;                 <span class="hljs-comment">// 足し算を実行する</span>
          },<span class="hljs-number">0</span>); <span class="hljs-comment">// 第2引数には、蓄積変数の初期値として0を渡す </span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>constant関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(constant) */</span>
        <span class="hljs-keyword">var</span> constant = (any) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; {
            <span class="hljs-keyword">return</span> any;
          };
        };
        <span class="hljs-keyword">var</span> alwaysOne = constant(<span class="hljs-number">1</span>); 
        <span class="hljs-comment">/* #@range_end(constant) */</span>
        <span class="hljs-comment">/* #@range_begin(map_alwaysOne) */</span>
        expect(
          map(alwaysOne)([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
        );
        <span class="hljs-comment">/* #@range_end(map_alwaysOne) */</span>
        <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
          <span class="hljs-keyword">return</span>  (x) =&gt; {
            <span class="hljs-keyword">return</span> (y) =&gt; {
              <span class="hljs-keyword">return</span> fun(y)(x);
            };
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>関数合成によるlength関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(array_length_in_composition) */</span>
        <span class="hljs-keyword">var</span> length = (array) =&gt; { <span class="hljs-comment">// 引数が配列であることを明示する</span>
          <span class="hljs-keyword">return</span> compose(sum,map(alwaysOne))(array);
        };
        <span class="hljs-comment">/* #@range_end(array_length_in_composition)  */</span>
        expect(
          length([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        next();
      });
      it(<span class="hljs-string">'adderからsucc関数を作る'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(succ_from_adder) */</span>
        <span class="hljs-keyword">var</span> adder = (m) =&gt; {
          <span class="hljs-keyword">return</span> (n) =&gt; {
            <span class="hljs-keyword">return</span> m + n;
          };
        };
        <span class="hljs-keyword">var</span> succ = adder(<span class="hljs-number">1</span>);
        <span class="hljs-comment">/* #@range_end(succ_from_adder)  */</span>
        expect(
          succ(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">'length関数を作る'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> map = (transform) =&gt; {
          <span class="hljs-keyword">return</span> (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> accumulator.concat(transform(item));
            },[]); <span class="hljs-comment">// 蓄積変数の初期値として空の配列[]を指定する</span>
          };
        };
        <span class="hljs-keyword">var</span> sum = (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; { <span class="hljs-comment">// 第1引数に関数を渡す</span>
            <span class="hljs-keyword">return</span> accumulator + item;                 <span class="hljs-comment">// 足し算を実行する</span>
          },<span class="hljs-number">0</span>); <span class="hljs-comment">// 第2引数には、蓄積変数の初期値として0を渡す </span>
        };
        <span class="hljs-keyword">var</span> constant = (any) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; {
            <span class="hljs-keyword">return</span> any;
          };
        };
        <span class="hljs-keyword">var</span> alwaysOne = constant(<span class="hljs-number">1</span>); 
        <span class="hljs-comment">/* #@range_begin(array_length) */</span>
        <span class="hljs-keyword">var</span> length = (array) =&gt; {
          <span class="hljs-keyword">return</span> sum(map(alwaysOne)(array));
        };
        <span class="hljs-comment">/* #@range_end(array_length)  */</span>
        expect(
          length([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h4 id="-">関数合成による処理の合成</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'関数合成による処理の合成'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>compose関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(function_compose) */</span>
        <span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(g(arg));
          };
        };
        <span class="hljs-comment">/* #@range_end(function_compose)  */</span>
        it(<span class="hljs-string">'関数合成でlength関数を作る(ポイントフリー版)'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> map = (transform) =&gt; {
            <span class="hljs-keyword">return</span> (array) =&gt; {
              <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
                <span class="hljs-keyword">return</span> accumulator.concat(transform(item));
              },[]); <span class="hljs-comment">// 蓄積変数の初期値として空の配列[]を指定する</span>
            };
          };
          <span class="hljs-keyword">var</span> sum = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; { <span class="hljs-comment">// 第1引数に関数を渡す</span>
              <span class="hljs-keyword">return</span> accumulator + item;                 <span class="hljs-comment">// 足し算を実行する</span>
            },<span class="hljs-number">0</span>); <span class="hljs-comment">// 第2引数には、蓄積変数の初期値として0を渡す </span>
          };
          <span class="hljs-keyword">var</span> constant = (any) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> any;
            };
          };
          <span class="hljs-keyword">var</span> alwaysOne = constant(<span class="hljs-number">1</span>); 
          <span class="hljs-comment">/* #@range_begin(flip_definition) */</span>
          <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
            <span class="hljs-keyword">return</span>  (x) =&gt; {
              <span class="hljs-keyword">return</span> (y) =&gt; {
                <span class="hljs-keyword">return</span> fun(y)(x);
              };
            };
          };
          <span class="hljs-comment">/* #@range_end(flip_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>関数合成によるlength関数の定義（ポイントフリースタイル）</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(array_length_in_composition_with_point_free_style) */</span>
          <span class="hljs-keyword">var</span> length = compose(sum,map(alwaysOne));
          <span class="hljs-comment">/* #@range_end(array_length_in_composition_with_point_free_style)  */</span>
          expect(
            length([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          next();
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>it(‘素数の計算’, (next) =&gt; {
  var match = (data, pattern) =&gt; {
    return data(pattern);
  };
  var stream = {
    empty: (<em>) =&gt; {
      return (pattern) =&gt; {
        return pattern.empty();
      };
    },
    cons: (head,tailThunk) =&gt; {
      return (pattern) =&gt; {
        return pattern.cons(head,tailThunk);
      };
    },
    /<em> head:: STREAM[T] =&gt; T </em>/
    /<em> ストリーム型headの定義は、リスト型headと同じ </em>/
    head: (astream) =&gt; {
      return match(astream,{
        empty: (</em>) =&gt; { return null; },
        cons: (value, tailThunk) =&gt; { return value; }
      });
    },
    /<em> tail:: STREAM[T] =&gt; STREAM[T] </em>/
    tail: (astream) =&gt; {
      return match(astream,{
        empty: (<em>) =&gt; { return null; },
        cons: (head, tailThunk) =&gt; {
          return tailThunk();  // ここで初めてサンクを評価する
        }
      });
    },
    take: (astream, n) =&gt; {
      return match(astream,{
        empty: (</em>) =&gt; {
          return list.empty();
        },
        cons: (head,tailThunk) =&gt; {
          if(n === 0) {
            return list.empty();
          } else {
            return list.cons(head,stream.take(tailThunk(),(n -1)));
          }
        }
      });
    }
  };
  var list = {
    empty: (<em>) =&gt; {
      return (pattern) =&gt; {
        return pattern.empty();
      };
    },
    cons: (value, list) =&gt; {
      return (pattern) =&gt; {
        return pattern.cons(value, list);
      };
    },
    isEmpty: (alist) =&gt; {
      return match(alist, { // match関数で分岐する
        empty: true,
        cons: (head, tail) =&gt; { // headとtailにそれぞれ先頭要素、末尾要素が入る
          return false;
        }
      });
    },
    head: (alist) =&gt; {
      return match(alist, {
        empty: null, // 空のリストには先頭要素はありません
        cons: (head, tail) =&gt; {
          return head;
        }
      });
    },
    tail: (alist) =&gt; {
      return match(alist, {
        empty: null,  // 空のリストには末尾要素はありません
        cons: (head, tail) =&gt; {
          return tail;
        }
      });
    },
    toArray: (alist) =&gt; {
      var toArrayAux = (alist,accumulator) =&gt; {
        return match(alist, {
          empty: (</em>) =&gt; {
            return accumulator;
          },
          cons: (head, tail) =&gt; {
            return toArrayAux(tail, accumulator.concat(head));
          }
        });
      };
      return toArrayAux(alist, []);
    }
  };
  var enumFrom = (n) =&gt; {
    return stream.cons(n, (<em>) =&gt; {
      return enumFrom(n + 1);
    });
  };
  var sieve = (astream) =&gt; {
    var head = stream.head(astream);
    var tail = stream.tail(astream);
    var mark = (astream, k, m) =&gt; {
      var head = stream.head(astream);
      var tail = stream.tail(astream);
      if(k === m) {
        return stream.cons(0,(</em>) =&gt; {
          return mark(tail, 1, m);
        });
      } else {
        return stream.cons(head, (<em>) =&gt; {
          return mark(tail, k+1, m);
        });
      }
    };
    if(head === 0) {
      return sieve(tail);
    } else {
      return stream.cons(head, (</em>) =&gt; {
        return sieve(mark(tail, 1, head));
      });
    }
  };
  expect(
    list.toArray(stream.take(sieve(enumFrom(2)), 10))
  ).to.eql(
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
  );
  next();
});</p>
<h4 id="-">関数による遅延評価</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'関数による遅延評価'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> take = (n, astream) =&gt; {
          <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> astream[<span class="hljs-number">0</span>];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> [astream[<span class="hljs-number">0</span>]].concat(take(n-<span class="hljs-number">1</span>, astream[<span class="hljs-number">1</span>]()));
          }
        };
        <span class="hljs-keyword">var</span> repeat = (n) =&gt; {
          <span class="hljs-keyword">return</span> [n, (_) =&gt; {
            <span class="hljs-keyword">return</span> repeat(n);
          }];
        };
        expect(
          take(<span class="hljs-number">3</span>, repeat(<span class="hljs-number">2</span>))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]
        );
        <span class="hljs-keyword">var</span> ones = repeat(<span class="hljs-number">1</span>);
        expect(
          take(<span class="hljs-number">2</span>, ones)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
        );
        <span class="hljs-keyword">var</span> replicate = (n, x) =&gt; {
          <span class="hljs-keyword">return</span> take(n, repeat(x));
        };
        expect(
          replicate(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)
        ).to.eql(
          [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]
        );
        <span class="hljs-keyword">var</span> upto = (m, n) =&gt; {
          <span class="hljs-keyword">if</span>(m &gt; n) {
            <span class="hljs-keyword">return</span> [];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> [m, (_) =&gt; {
              <span class="hljs-keyword">return</span> upto(m+<span class="hljs-number">1</span>,n);
            }];
          };
        };
        expect(
          take(<span class="hljs-number">3</span>, upto(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>filter関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(stream_filter) */</span>
        <span class="hljs-keyword">var</span> filter = (predicate) =&gt; {
          <span class="hljs-keyword">return</span> (aStream) =&gt; {
            <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>];
            <span class="hljs-comment">/* 先頭要素が条件に合致する場合 */</span>
            <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) { 
              <span class="hljs-keyword">return</span> [head, (_) =&gt; {
                <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
              }];
            } <span class="hljs-keyword">else</span> {                       
              <span class="hljs-comment">/* 先頭要素が条件に合致しない場合 */</span>
              <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(stream_filter) */</span>
        <span class="hljs-keyword">var</span> mod = (n,m) =&gt; {
          <span class="hljs-keyword">return</span> n % m;
        };
        <span class="hljs-keyword">var</span> even = (n) =&gt; {
          <span class="hljs-keyword">return</span> mod(n,<span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
        };
        <span class="hljs-keyword">var</span> adder = (m) =&gt; {
          <span class="hljs-keyword">return</span> (n) =&gt; {
            <span class="hljs-keyword">return</span> m + n;
          };
        };
        <span class="hljs-keyword">var</span> succ = adder(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">var</span> map = (aStream) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">return</span> [transform(head), (_) =&gt; {
              <span class="hljs-keyword">return</span> map(aStream[<span class="hljs-number">1</span>]())(transform);
            }];
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>無限ストリームの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(stream_iterate) */</span>
        <span class="hljs-keyword">var</span> iterate = (init) =&gt; {  <span class="hljs-comment">// 先頭の値を渡す</span>
          <span class="hljs-keyword">return</span> (step) =&gt; {       <span class="hljs-comment">// 次の値との差を計算する関数を渡す</span>
            <span class="hljs-keyword">return</span> [init, (_) =&gt; { <span class="hljs-comment">// ストリーム型を返す</span>
              <span class="hljs-keyword">return</span> iterate(step(init))(step);
            }];
          };
        };
        <span class="hljs-comment">/* #@range_end(stream_iterate) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>無限の偶数列</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(enumFrom_by_iterate) */</span>
        <span class="hljs-keyword">var</span> enumFrom = (n) =&gt; {
          <span class="hljs-keyword">return</span> iterate(n)(succ);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>自然数列を定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> naturals = enumFrom(<span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>偶数列を定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> twoStep = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">2</span>;
        };
        <span class="hljs-keyword">var</span> evenStream = iterate(<span class="hljs-number">2</span>)(twoStep);
        <span class="hljs-comment">/* #@range_end(enumFrom_by_iterate) */</span>
        expect(
          take(<span class="hljs-number">3</span>,filter(even)(enumFrom(<span class="hljs-number">2</span>)))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]
        );
        <span class="hljs-comment">/* #@range_begin(oddStream_from_iterate) */</span>
        <span class="hljs-keyword">var</span> twoStep = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">2</span>;
        };
        <span class="hljs-keyword">var</span> oddStream = iterate(<span class="hljs-number">1</span>)(twoStep);
        <span class="hljs-comment">/* #@range_end(oddStream_from_iterate) */</span>
        expect(
          take(<span class="hljs-number">3</span>,oddStream)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]
        );
        it(<span class="hljs-string">'遅延評価の説明'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> map = (transform) =&gt; {
            <span class="hljs-keyword">return</span> (array) =&gt; {
              <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
                <span class="hljs-keyword">return</span> accumulator.concat(transform(item));
              },[]); 
            };
          };
          <span class="hljs-keyword">var</span> sum = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; { <span class="hljs-comment">// 第1引数に関数を渡す</span>
              <span class="hljs-keyword">return</span> accumulator + item;                 <span class="hljs-comment">// 足し算を実行する</span>
            },<span class="hljs-number">0</span>); 
          };
          <span class="hljs-keyword">var</span> constant = (any) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> any;
            };
          };
          <span class="hljs-keyword">var</span> alwaysOne = constant(<span class="hljs-number">1</span>); 
          <span class="hljs-keyword">var</span> length = compose(sum,map(alwaysOne));
          expect(</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>正格評価の例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(strict_evaluation) */</span>
            length([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>+<span class="hljs-number">1</span>])
            <span class="hljs-comment">/* #@range_end(strict_evaluation) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(strict_evaluation_result) */</span>
            <span class="hljs-number">2</span>
            <span class="hljs-comment">/* #@range_end(strict_evaluation_result) */</span>
          );
          expect(</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>遅延評価の例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(lazy_evaluation) */</span>
            length([<span class="hljs-number">1</span>,(_) =&gt; {
                         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-number">1</span>; 
                   }])
            <span class="hljs-comment">/* #@range_end(lazy_evaluation) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(lazy_evaluation_result) */</span>
            <span class="hljs-number">2</span>
            <span class="hljs-comment">/* #@range_end(lazy_evaluation_result) */</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>無限の整数列</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'無限の整数列'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(enumFrom) */</span>
          <span class="hljs-keyword">var</span> enumFrom = (n) =&gt; {
            <span class="hljs-keyword">return</span> [n, (_) =&gt; { <span class="hljs-comment">// ストリームを返す</span>
              <span class="hljs-keyword">return</span> enumFrom(n + <span class="hljs-number">1</span>);
            }];
          };
          <span class="hljs-comment">/* #@range_end(enumFrom) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>無限の偶数列を作る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'無限の偶数列を作る'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(evenStream) */</span>
          <span class="hljs-keyword">var</span> evenFrom = (n) =&gt; {
            <span class="hljs-keyword">return</span> [n, (_) =&gt; {
              <span class="hljs-keyword">return</span> evenFrom(n + <span class="hljs-number">2</span>);
            }];
          };
          <span class="hljs-keyword">var</span> evenStream = evenFrom(<span class="hljs-number">2</span>); 
          <span class="hljs-comment">/* #@range_end(evenStream) */</span>
          expect(
            take(<span class="hljs-number">3</span>, evenStream)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>ストリームのフィルタリング</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'ストリームのフィルタリング'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(stream_filter) */</span>
          <span class="hljs-keyword">var</span> filter = (predicate) =&gt; {
            <span class="hljs-keyword">return</span> (aStream) =&gt; {
              <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ストリームの先頭要素を取り出す</span>
              <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) { <span class="hljs-comment">// 先頭要素headが条件に合致している場合</span>
                <span class="hljs-keyword">return</span> [head, (_) =&gt; {
                  <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
                }];
              } <span class="hljs-keyword">else</span> {                       <span class="hljs-comment">// 先頭要素headが条件に合致していない場合</span>
                <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
              }
            };
          };
          <span class="hljs-comment">/* #@range_end(stream_filter) */</span>
          <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
            <span class="hljs-keyword">return</span> (m) =&gt; {
              <span class="hljs-keyword">if</span>((n % m) === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            };
          };
          <span class="hljs-comment">/* #@range_begin(odd_stream) */</span>
          <span class="hljs-keyword">var</span> odd = (n) =&gt; {
            <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>; 
          };
          <span class="hljs-keyword">var</span> oddStream = filter(odd)(enumFrom(<span class="hljs-number">1</span>));
          <span class="hljs-comment">/* #@range_end(odd_stream) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>elemAt関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(stream_elemAt) */</span>
          <span class="hljs-keyword">var</span> elemAt = (n) =&gt; {
            <span class="hljs-keyword">return</span> (aStream) =&gt; {
              <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> aStream[<span class="hljs-number">0</span>];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> elemAt(n-<span class="hljs-number">1</span>)(aStream[<span class="hljs-number">1</span>]());
              };
            };
          };
          <span class="hljs-comment">/* #@range_end(stream_elemAt) */</span>
          expect(</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>3番目の偶数を求める</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(third_element_of_odd_stream) */</span>
            elemAt(<span class="hljs-number">3</span>)(oddStream)
            <span class="hljs-comment">/* #@range_end(third_element_of_odd_stream) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(third_element_of_odd_stream_result) */</span>
            <span class="hljs-number">5</span>
            <span class="hljs-comment">/* #@range_end(third_element_of_odd_stream_result) */</span>
          );
          expect(
            take(<span class="hljs-number">5</span>,filter(odd)(enumFrom(<span class="hljs-number">1</span>)))
          ).to.eql(
            [ <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span> ] 
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>filter関数で無限の偶数列を作る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(evenStream_by_filter) */</span>
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>; 
          };
          <span class="hljs-keyword">var</span> evenStream = filter(even)(enumFrom(<span class="hljs-number">1</span>));
          <span class="hljs-comment">/* #@range_end(evenStream_by_filter) */</span>
          expect(
            <span class="hljs-comment">/* #@range_begin(third_element_of_evenStream) */</span>
            elemAt(<span class="hljs-number">3</span>)(evenStream)
            <span class="hljs-comment">/* #@range_end(third_element_of_evenStream) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(third_element_of_evenStream_result) */</span>
            <span class="hljs-number">6</span>
            <span class="hljs-comment">/* #@range_end(third_element_of_evenStream_result) */</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>配列に対するelemAt関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'配列に対するelemAt関数'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(array_elemAt) */</span>
          <span class="hljs-keyword">var</span> elemAt = (n) =&gt; {
            <span class="hljs-keyword">return</span> (anArray) =&gt; {
              <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> anArray[<span class="hljs-number">0</span>];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> tail = anArray.slice(<span class="hljs-number">1</span>,anArray.length);
                <span class="hljs-keyword">return</span> elemAt(n-<span class="hljs-number">1</span>)(tail);
              };
            };
          };
          <span class="hljs-comment">/* #@range_end(array_elemAt) */</span>
          expect(
            <span class="hljs-comment">/* #@range_begin(third_element_of_evenArray) */</span>
            elemAt(<span class="hljs-number">3</span>)([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>])
            <span class="hljs-comment">/* #@range_end(third_element_of_evenArray) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(third_element_of_eventArray_result) */</span>
            <span class="hljs-number">6</span>
            <span class="hljs-comment">/* #@range_end(third_element_of_eventArray_result) */</span>
          );
          expect(</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>4番目の偶数を求める</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(fourth_element_of_evenArray) */</span>
            elemAt(<span class="hljs-number">4</span>)([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>])
            <span class="hljs-comment">/* #@range_end(fourth_element_of_evenArray) */</span>
          ).to.eql(
            <span class="hljs-comment">/* #@range_begin(fourth_element_of_evenArray_result) */</span>
            <span class="hljs-literal">undefined</span>
            <span class="hljs-comment">/* #@range_end(fourth_element_of_evenArray_result) */</span>
          );
          next();
        });
        describe(<span class="hljs-string">'ストリーム'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>ストリームの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          it(<span class="hljs-string">'ストリームの例'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(stream_example) */</span>
            <span class="hljs-keyword">var</span> aStream = [<span class="hljs-number">1</span>, (_) =&gt; { <span class="hljs-comment">// 後尾は無名関数で表現する</span>
              <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            }];
            <span class="hljs-comment">/* #@range_end(stream_example) */</span>
            expect(
              <span class="hljs-comment">/* #@range_begin(stream_head) */</span>
              aStream[<span class="hljs-number">0</span>] <span class="hljs-comment">// ストリームの先頭要素を取得する</span>
              <span class="hljs-comment">/* #@range_end(stream_head) */</span>
            ).to.eql(
              <span class="hljs-comment">/* #@range_begin(stream_head_result) */</span>
              <span class="hljs-number">1</span>
              <span class="hljs-comment">/* #@range_end(stream_head_result) */</span>
            );
            expect(
              <span class="hljs-comment">/* #@range_begin(stream_tail) */</span>
              aStream[<span class="hljs-number">1</span>]() <span class="hljs-comment">// 関数適用でストリームの後尾を取り出す</span>
              <span class="hljs-comment">/* #@range_end(stream_tail) */</span>
            ).to.eql(
              <span class="hljs-comment">/* #@range_begin(stream_tail_result) */</span>
              <span class="hljs-number">2</span>
              <span class="hljs-comment">/* #@range_end(stream_tail_result) */</span>
            );
            <span class="hljs-comment">/* #@range_begin(stream_ones) */</span>
            <span class="hljs-keyword">var</span> ones = [<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> ones;
            }];
            <span class="hljs-comment">/* #@range_end(stream_ones) */</span>
            expect(
              ones[<span class="hljs-number">0</span>]
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(
              ones[<span class="hljs-number">1</span>]()[<span class="hljs-number">0</span>]
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            next();
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>it(‘フィボナッチ数列’, (next) =&gt; {
  var take = (n) =&gt; {
    return (aStream) =&gt; {
      /<em> 再帰処理の終了条件 </em>/
      if(n === 1) { 
        return aStream[0];
      } else {
        /<em> take関数の再帰呼び出し </em>/
        return [aStream[0]].concat(take(n-1)(aStream<a href="">1</a>)); 
      }
    };
  };
  var fib = (a, b) =&gt; {
    return [a, (<em>) =&gt; {
      return fib(b, a + b);
    }];
  }; 
  expect(
    take(5)(fib(1, 1))
  ).to.eql(
    [ 1, 1 , 2, 3, 5]
  );
  next();
});
describe(‘円周率に関するライプニッツの法則’, () =&gt; {
  var multipleOf = (n,m) =&gt; {
    if((n % m) === 0) {
      return true;
    } else {
      return false;
    }
  };
  var even = (n) =&gt; {
    return multipleOf(n,2); // 偶数は2の倍数
  };
  var odd = (n) =&gt; {
    return not(multipleOf(n,2)); // 偶数は2の倍数
  };
  var not = (arg) =&gt; {
    return ! arg;
  };
  var remove = (predicate) =&gt; {
    return (aStream) =&gt; {
      return filter(compose(not,predicate))(aStream);
    };
  };
  var odds = filter(odd)(enumFrom(1));
  var take = (n) =&gt; {
    return (aStream) =&gt; {
      if(n === 1) { 
        return aStream[0];
      } else {
        return [aStream[0]].concat(take(n-1)(aStream<a href="">1</a>)); 
      }
    };
  };
  var map = (aStream,transform) =&gt; {
    var head = aStream[0];
    return [transform(head), (</em>) =&gt; {
      return map(aStream<a href="">1</a>, transform);
    }];
  };
  var iterate = (f,x) =&gt; {
    return [x, (<em>) =&gt; {
      return map(iterate(f,x), f);
    }];
  };
  var negate = (n) =&gt; {
    return 0 - n;
  };
  var foldr = (aStream, accumulator) =&gt; {
    return (glue) =&gt; {
      if(aStream.length === 0) {
        return accumulator;
      } else {
        var head = aStream[0];
        var tailThunk = aStream[1];
        return glue(head,foldr(tailThunk(),accumulator)(glue));
      }
    };
  };
  var append = (xs,ysThunk) =&gt; {
    if(xs.length === 0) {
      return ysThunk();
    } else {
      var x = xs[0];
      return [x, (</em>) =&gt; {
        return append(xs<a href="">1</a>, ysThunk);
      }];
    };
  };
  var concat = (xss) =&gt; {
    return foldr(xss,[])(append);
  };
  it(‘listSums’, (next) =&gt; {
    this.timeout(50000);
    /<em> #@range_begin(streams_for_leibnitz) </em>/
    /<em> [1,3,5,…] </em>/
    var oddStream = filter(odd)(enumFrom(1)); </p>

            </div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <pre><code><span class="hljs-comment">/* [1, -1, 1, -1...] */</span>
<span class="hljs-keyword">var</span> cycledStream = iterate((item) =&gt; { 
  <span class="hljs-keyword">return</span> - item; <span class="hljs-comment">// 符号を反転させる</span>
},<span class="hljs-number">1</span>);
<span class="hljs-comment">/* #@range_end(streams_for_leibnitz) */</span>
<span class="hljs-comment">// zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span>
<span class="hljs-comment">// zipWith' f [] _ = []</span>
<span class="hljs-comment">// zipWith' f _ [] = []</span>
<span class="hljs-comment">// zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span>
<span class="hljs-comment">/* #@range_begin(stream_zipWith) */</span>
<span class="hljs-keyword">var</span> zipWith = (glue) =&gt; {
  <span class="hljs-keyword">return</span> (xs, ys) =&gt; {
    <span class="hljs-keyword">if</span>(xs.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> []; 
    } 
    <span class="hljs-keyword">if</span>(ys.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> []; 
    } 
    <span class="hljs-keyword">return</span> [glue(xs[<span class="hljs-number">0</span>], ys[<span class="hljs-number">0</span>]), (_) =&gt; {
      <span class="hljs-keyword">return</span> zipWith(glue)(xs[<span class="hljs-number">1</span>](), ys[<span class="hljs-number">1</span>]());
    }];
  };
};
<span class="hljs-comment">/* #@range_end(stream_zipWith) */</span>
<span class="hljs-comment">/* #@range_begin(listSums) */</span>
<span class="hljs-keyword">var</span> listSums = (aStream) =&gt; {
  <span class="hljs-keyword">var</span> out = [aStream[<span class="hljs-number">0</span>], (_) =&gt; {
    <span class="hljs-keyword">return</span> zipWith((x,y) =&gt; { 
      <span class="hljs-keyword">return</span> x + y;
    })(aStream[<span class="hljs-number">1</span>](), out);
  }];
  <span class="hljs-keyword">return</span> out;
};
<span class="hljs-comment">/* #@range_end(listSums) */</span>
expect(
  take(<span class="hljs-number">3</span>)(listSums(enumFrom(<span class="hljs-number">1</span>)))
).to.eql(
  [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]
);
expect(
  take(<span class="hljs-number">4</span>)(listSums(enumFrom(<span class="hljs-number">1</span>)))
).to.eql(
  [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]
);
<span class="hljs-comment">/* #@range_begin(leibnitz_series) */</span>
<span class="hljs-keyword">var</span> leibnitzSeries = zipWith((x,y) =&gt; {
  <span class="hljs-keyword">return</span> x * <span class="hljs-number">1</span> / y; <span class="hljs-comment">// 逆数をとって、掛けあわせる</span>
})(cycledStream, oddStream);
<span class="hljs-comment">/* #@range_end(leibnitz_series) */</span>
expect(
  take(<span class="hljs-number">3</span>)(leibnitzSeries)
).to.eql(
  [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>/<span class="hljs-number">3</span>, <span class="hljs-number">1</span>/<span class="hljs-number">5</span>]
);
<span class="hljs-keyword">var</span> elemAt = (n) =&gt; {
  <span class="hljs-keyword">return</span> (aStream) =&gt; {
    <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> aStream[<span class="hljs-number">0</span>];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> elemAt(n-<span class="hljs-number">1</span>)(aStream[<span class="hljs-number">1</span>]());
    };
  };
};
expect(
  elemAt(<span class="hljs-number">3</span>)(enumFrom(<span class="hljs-number">1</span>))
).to.eql(
  <span class="hljs-number">3</span>
);
expect(
  elemAt(<span class="hljs-number">3</span>)(listSums(enumFrom(<span class="hljs-number">1</span>)))
).to.eql(
  <span class="hljs-number">6</span>
);
<span class="hljs-comment">/* #@range_begin(almostPi) */</span>
<span class="hljs-keyword">var</span> almostPi = (ntimes) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span> * elemAt(ntimes)(listSums(leibnitzSeries));
};
<span class="hljs-comment">/* #@range_end(almostPi) */</span>
expect(
<span class="hljs-comment">/* #@range_begin(pi_approximation) */</span>
almostPi(<span class="hljs-number">100</span>)
<span class="hljs-comment">/* #@range_end(pi_approximation) */</span>
).to.eql(
  <span class="hljs-comment">/* #@range_begin(pi_approximation_result) */</span>
  <span class="hljs-number">3.1315929035585537</span>
  <span class="hljs-comment">/* #@range_end(pi_approximation_result) */</span>
);
next();
</code></pre><p>  });
  it(‘タブロー化listSums’, (next) =&gt; {
    this.timeout(50000);
    var intStream = enumFrom(1); // [1,2,3,,,,]
    var oddStream = filter(odd)(intStream); // [1,3,5,…]
    var cycledStream = iterate((item) =&gt; { // [1, -1, 1, -1…]
      return negate(item);
    },1);
    // zipWith’ :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
    // zipWith’ f [] <em> = []
    // zipWith’ f </em> [] = []
    // zipWith’ f (x:xs) (y:ys) = f x y : zipWith’ f xs ys
    var zipWith = (fun) =&gt; {
      return (xs, ys) =&gt; {
        if(xs.length === 0) {
          return []; 
        } 
        if(ys.length === 0) {
          return []; 
        } 
        return [fun(xs[0], ys[0]), (<em>) =&gt; {
          return zipWith(fun)(xs<a href="">1</a>, ys<a href="">1</a>);
        }];
      };
    };
    var listSums = (aStream) =&gt; {
      if(aStream.length === 0){
        return [];
      } else {
        return [aStream[0], (</em>) =&gt; {
          return listSums([aStream[0]+aStream<a href="">1</a>[0], (<em>) =&gt; {
            return aStream<a href="">1</a><a href="">1</a>;
          }]);
        }];
      }
    };
    var leibnitzSeries = zipWith((x,y) =&gt; {
      return x <em> 1 /y;
    })(cycledStream, oddStream);
    var elemAt = (n) =&gt; {
      return (aStream) =&gt; {
        if(n === 1) {
          return aStream[0];
        } else {
          return elemAt(n-1)(aStream<a href="">1</a>);
        };
      };
    };
    expect(
      4 </em> elemAt(100)(listSums(leibnitzSeries))
    ).to.within(3.13, 3.15);
    next();
  });
  it(‘take’, (next) =&gt; {
    this.timeout(10000);
    var multipleOf = (n,m) =&gt; {
      if((n % m) === 0) {
        return true;
      } else {
        return false;
      }
    };
    expect(
      take(5)(iterate((item) =&gt; {
        return negate(item);
      },1))
    ).to.eql(
      [1, -1, 1, -1, 1]
    );
    expect(
      take(5)(iterate((item) =&gt; {
        if(item &gt; 0) {
          return -1 <em> (item + 2);
        } else {
          return -1 </em> (item - 2);
        }
      },1))
    ).to.eql(
      [1, -3, 5, -7, 9]
    );
    // cycle                   :: [a] -&gt; [a]
    // cycle []  = error “Prelude.cycle: empty list”
    // cycle xs  = xs’ where xs’ = xs ++ xs’
    var cycle = (aStream) =&gt; {
      return append(aStream,(</em>) =&gt; {
        return cycle(aStream);
      });
    };
    expect(
      take(4)(cycle([1, (<em>) =&gt; {
        return [-1, (</em>) =&gt; {
          return [];
        }];
      }]))
    ).to.eql(
      [1, -1, 1, -1]
    );
    // zipWith’ :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
    // zipWith’ f [] <em> = []
    // zipWith’ f </em> [] = []
    // zipWith’ f (x:xs) (y:ys) = f x y : zipWith’ f xs ys
    var zipWith = (fun) =&gt; {
      return (xs, ys) =&gt; {
        if(xs.length === 0) {
          return []; 
        } 
        if(ys.length === 0) {
          return []; 
        } 
        return [fun(xs[0], ys[0]), (_) =&gt; {
          return zipWith(fun)(xs<a href="">1</a>, ys<a href="">1</a>);
        }];
      };
    };
    var intStream = enumFrom(1);
    var oddStream = filter(odd)(intStream);
    var cycles = iterate((item) =&gt; {
      return negate(item);
    },1);
    var leibnitzSeries = zipWith((x,y) =&gt; {
      return x <em> 1 /y;
    })(cycles, oddStream);
    expect(
      take(3)(leibnitzSeries)
    ).to.eql(
      [1, -1/3, 1/5]
    );
    var at = (n, aStream) =&gt; {
      if(n === 1) {
        return aStream[0];
      } else {
        return at(n-1, aStream<a href="">1</a>);
      };
    };
    var multiplier = (n) =&gt; {
      return (m) =&gt; {
        return n </em> m;
      };
    };
    var pi = (times) =&gt; {
      return 4 * take(times)(leibnitzSeries).reduce((accumulator, item) =&gt; {
        return accumulator + item;
      }, 0);
    };
    expect(
      pi(1000)
    ).to.within(3.14, 3.15);</p>

            </div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <pre><code>next();
</code></pre><p>  });
});
it(‘エラトステネスのふるいによる素数の生成’, (next) =&gt; {
  /<em> #@range_begin(stream_filter) </em>/
  var filter = (predicate) =&gt; {
    return (aStream) =&gt; {
      var head = aStream[0];
      if(predicate(head) === true) {
        return [head, (_) =&gt; {
          return filter(predicate)(aStream<a href="">1</a>);
        }];
      } else {
        return filter(predicate)(aStream<a href="">1</a>);
      }
    };
  };
  /<em> #@range_end(stream_filter) </em>/
  /<em> #@range_begin(stream_remove) </em>/
  var not = (arg) =&gt; {
    return ! arg;
  };
  var remove = (predicate) =&gt; {
    return (aStream) =&gt; {
      return filter(compose(not,predicate))(aStream);
    };
  };
  /<em> #@range_end(stream_remove) </em>/
  /<em> #@range_begin(stream_take) </em>/
  var take = (n) =&gt; {
    return (aStream) =&gt; {
      /<em> 再帰処理の終了条件 </em>/
      if(n === 1) { 
        return aStream[0];
      } else {
        /<em> take関数の再帰呼び出し </em>/
        return [aStream[0]].concat(take(n-1)(aStream<a href="">1</a>)); 
      }
    };
  };
  /<em> #@range_end(stream_take) </em>/
  /<em> #@range_begin(multipleOf) </em>/
  var multipleOf = (n,m) =&gt; {
    if((n % m) === 0) {
      return true;
    } else {
      return false;
    }
  };
  /<em> #@range_end(multipleOf) </em>/
  expect(
    multipleOf(4,2)
  ).to.eql(
    true
  );
  expect(
    multipleOf(5,2)
  ).to.eql(
    false
  );
  var even = (n) =&gt; {
    return n % 2 === 0;
  };
  expect(((_) =&gt; { 
    /<em> #@range_begin(stream_remove_test) </em>/
    var even = (n) =&gt; {
      return multipleOf(n,2); // 偶数は2の倍数
    };
    take(5)(remove(even)(enumFrom(1)));
    /<em> #@range_end(stream_remove_test) </em>/
    return take(5)(remove(even)(enumFrom(1)));
  })()).to.eql(
    /<em> #@range_begin(stream_remove_test_result) </em>/
    [1,3,5,7,9]
    /<em> #@range_end(stream_remove_test_result) </em>/
  );
  expect(
    take(10000)(remove(even)(enumFrom(1))).length
  ).to.eql(
    10000
  );
  /<em> #@range_begin(eratosthenes_sieve) </em>/
  /<em> エラトステネスのふるい </em>/
  var sieve = (aStream) =&gt; {
    /<em> 変数primeは先頭にある素数 </em>/
    var prime = aStream[0];<br>    return [prime, (_) =&gt; {
      return sieve(remove( /<em> その素数の倍数を除去する </em>/
        (item) =&gt; { 
          return multipleOf(item, prime);<br>        }
      )(aStream<a href="">1</a>));
    }]; 
  };
  var primes = sieve(enumFrom(2)); // 無限の素数列
  /<em> #@range_end(eratosthenes_sieve) </em>/
  expect(
    /<em> #@range_begin(eratosthenes_sieve_test) </em>/
    take(10)(primes)
    /<em> #@range_end(eratosthenes_sieve_test) </em>/
  ).to.eql(
    /<em> #@range_begin(eratosthenes_sieve_test_result) </em>/
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
    /<em> #@range_end(eratosthenes_sieve_test_result) </em>/
  );
  expect(
    take(50)(primes)
  ).to.eql(
    [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229]
  );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        });
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h3 id="-">テストが容易である</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'テスト'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>単体テストの書き方の例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'単体テストの書き方の例'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      expect(
        succ(<span class="hljs-number">1</span>) <span class="hljs-comment">// テストしたい式を書く</span>
      ).to.eql(
        <span class="hljs-number">2</span>       <span class="hljs-comment">// 期待する結果を書く</span>
      );
      next();
    });
    it(<span class="hljs-string">'参照透過性のあるコードはテストが容易である'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> adder = (m) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">return</span> m + n;
        };
      };
      <span class="hljs-comment">/* #@range_begin(adder_test) */</span>
      expect(
        adder(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      <span class="hljs-comment">/* #@range_end(adder_test) */</span>
      next();
    });
    describe(<span class="hljs-string">'参照透過性のないコードはテストが困難である'</span>, () =&gt; {
      describe(<span class="hljs-string">'ゲームの勝敗の例'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>参照透過性のないコードのテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">"参照透過性のないコードのテスト"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(winner_with_sideeffect) */</span>
          <span class="hljs-keyword">var</span> winner = (playerL, playerR) =&gt; {
            <span class="hljs-keyword">if</span>(playerR.score &gt; playerL.score) {
              <span class="hljs-built_in">console</span>.log(playerR.name + <span class="hljs-string">"が勝者です"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(playerR.score &lt; playerL.score) {
              <span class="hljs-built_in">console</span>.log(playerL.name + <span class="hljs-string">"が勝者です"</span>);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"引き分けです"</span>);
            }
          }; 
          <span class="hljs-comment">/* #@range_end(winner_with_sideeffect) */</span>
          <span class="hljs-keyword">var</span> playerA = {
            name: <span class="hljs-string">'a'</span>,
            score: <span class="hljs-number">10</span>
          };
          <span class="hljs-keyword">var</span> playerB = {
            name: <span class="hljs-string">'b'</span>,
            score: <span class="hljs-number">20</span>
          };
          next();
        });
        it(<span class="hljs-string">"参照透過性のあるコードのテスト"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>winner関数の分離</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(winner_without_sideeffect) */</span>
          <span class="hljs-comment">/* 勝者を判定する */</span>
          <span class="hljs-keyword">var</span> judge = (playerL, playerR) =&gt; {
            <span class="hljs-keyword">if</span>(playerL.score &gt; playerR.score) {
              <span class="hljs-keyword">return</span> playerL;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(playerL.score &lt; playerR.score) {
              <span class="hljs-keyword">return</span> playerR;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
          }; 
          <span class="hljs-comment">/* 勝者を告げる文字列を生成する */</span>
          <span class="hljs-keyword">var</span> announce = (winner) =&gt; {
            <span class="hljs-keyword">if</span>(winner) {
              <span class="hljs-keyword">return</span> winner.name + <span class="hljs-string">"が勝者です"</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-string">"引き分けです"</span>;
            }
          };
          <span class="hljs-comment">/* 勝者を表示する */</span>
          <span class="hljs-keyword">var</span> displayWinner = (winner) =&gt; {
            <span class="hljs-built_in">console</span>.log(announce(winner));
          };
          <span class="hljs-comment">/* #@range_end(winner_without_sideeffect) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>副作用のない関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(announce_winner) */</span>
          <span class="hljs-keyword">var</span> socrates = {
            name: <span class="hljs-string">'ソクラテス'</span>,
            score: <span class="hljs-number">10</span>
          };
          <span class="hljs-keyword">var</span> plato = {
            name: <span class="hljs-string">'プラトン'</span>,
            score: <span class="hljs-number">20</span>
          };
          <span class="hljs-comment">/* 純粋な関数をテストする */</span>
          expect(
            announce(judge(socrates, plato))
          ).to.eql(
            <span class="hljs-string">"プラトンが勝者です"</span>
          );
          <span class="hljs-comment">/* #@range_end(announce_winner) */</span>
          next();
        });
      });
      it(<span class="hljs-string">'数学モジュールの例'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> math = {
          PI: <span class="hljs-number">3.14</span>
        };
        <span class="hljs-keyword">var</span> area = (radius) =&gt; {
          <span class="hljs-keyword">return</span> radius * radius * math.PI;
        };
        expect(
          area(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">3.14</span>
        );
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h3 id="-">コードの正しさを証明できる</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'コードの正しさを証明できる'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <h4 id="-">プロパティテストで正しさを検証する</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'プロパティテストで正しさを検証する'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> adder = (m) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">return</span> m + n;
        };
      };
      <span class="hljs-keyword">var</span> succ = adder(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">var</span> iterate = (step) =&gt; {
        <span class="hljs-keyword">return</span> (init) =&gt; {
          <span class="hljs-keyword">return</span> [init, (_) =&gt; {
            <span class="hljs-keyword">return</span> iterate(step)(step(init));
          }];
        };
      };
      <span class="hljs-keyword">var</span> take = (n) =&gt; {
        <span class="hljs-keyword">return</span> (aStream) =&gt; {
          <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> [];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> [aStream[<span class="hljs-number">0</span>]].concat(take(n-<span class="hljs-number">1</span>)(aStream[<span class="hljs-number">1</span>]()));
          }
        };
      };
      <span class="hljs-keyword">var</span> enumFrom = (from) =&gt; {
        <span class="hljs-keyword">return</span> iterate(succ)(from);
      };
      <span class="hljs-keyword">var</span> filter = (predicate) =&gt; {
        <span class="hljs-keyword">return</span> (aStream) =&gt; {
          <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">return</span> [head, (_) =&gt; {
              <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
            }];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> filter(predicate)(aStream[<span class="hljs-number">1</span>]());
          }
        };
      };
      it(<span class="hljs-string">'succ関数の性質テスト'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> elemAt = (n) =&gt; {
          <span class="hljs-keyword">return</span> (aStream) =&gt; {
            <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> aStream[<span class="hljs-number">0</span>];
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> elemAt(n-<span class="hljs-number">1</span>)(aStream[<span class="hljs-number">1</span>]());
            };
          };
        };
        <span class="hljs-keyword">var</span> scanl = (aStream) =&gt; {
          <span class="hljs-keyword">return</span> (glue) =&gt; {
            <span class="hljs-keyword">var</span> out = [aStream[<span class="hljs-number">0</span>], (_) =&gt; {
              <span class="hljs-keyword">return</span> zipWith(glue)(aStream[<span class="hljs-number">1</span>](), out);
            }];
            <span class="hljs-keyword">return</span> out;
          };
        };
        <span class="hljs-keyword">var</span> conjunction = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x &amp;&amp; y;  <span class="hljs-comment">// 論理和をとる</span>
        };
        <span class="hljs-keyword">var</span> zipWith = (glue) =&gt; {
          <span class="hljs-keyword">return</span> (xs, ys) =&gt; {
            <span class="hljs-keyword">if</span>(xs.length === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> []; 
            } 
            <span class="hljs-keyword">if</span>(ys.length === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> []; 
            } 
            <span class="hljs-keyword">return</span> [glue(xs[<span class="hljs-number">0</span>], ys[<span class="hljs-number">0</span>]), (_) =&gt; {
              <span class="hljs-keyword">return</span> zipWith(glue)(xs[<span class="hljs-number">1</span>](), ys[<span class="hljs-number">1</span>]());
            }];
          };
        };
        <span class="hljs-keyword">var</span> listAnd = (aStream) =&gt; {
          <span class="hljs-keyword">var</span> out = [aStream[<span class="hljs-number">0</span>], (_) =&gt; {
            <span class="hljs-keyword">return</span> zipWith((x,y) =&gt; { 
              <span class="hljs-keyword">return</span> x &amp;&amp; y;
            })(aStream[<span class="hljs-number">1</span>](), out);
          }];
          <span class="hljs-keyword">return</span> out;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>プロパティテストのための関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(succ_property) */</span>
        <span class="hljs-comment">/* ストリームのmap関数 */</span>
        <span class="hljs-keyword">var</span> map = (transform) =&gt; {
          <span class="hljs-keyword">return</span> (aStream) =&gt; {
            <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">return</span> [transform(head), (_) =&gt; {
              <span class="hljs-keyword">return</span> map(transform)(aStream[<span class="hljs-number">1</span>]());
            }];
          };
        };
        <span class="hljs-comment">/* ストリームの先頭から引数n分だけ取り出すtake関数 */</span>
        <span class="hljs-keyword">var</span> take = (n) =&gt; {
          <span class="hljs-keyword">return</span> (aStream) =&gt; {
            <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> [aStream[<span class="hljs-number">0</span>], (_) =&gt; {
                <span class="hljs-keyword">return</span> take(n-<span class="hljs-number">1</span>)(aStream[<span class="hljs-number">1</span>]());
              }];
            }
          };
        };
        <span class="hljs-comment">/* ストリームの全ての要素がtrueであるかを判定するall関数 */</span>
        <span class="hljs-keyword">var</span> all = (aStream) =&gt; {
          <span class="hljs-keyword">var</span> allHelper = (aStream, accumulator) =&gt; {
            <span class="hljs-keyword">var</span> head = aStream[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">var</span> newAccumulator = accumulator &amp;&amp; head;
            <span class="hljs-keyword">if</span>(aStream[<span class="hljs-number">1</span>]() === <span class="hljs-literal">null</span>){
              <span class="hljs-keyword">return</span> newAccumulator;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> allHelper(aStream[<span class="hljs-number">1</span>](), newAccumulator);
            } 
          };
          <span class="hljs-keyword">return</span> allHelper(aStream, <span class="hljs-literal">true</span>);
        };
        <span class="hljs-comment">/* 検証の対象となる命題 */</span>
        <span class="hljs-keyword">var</span> proposition = (n) =&gt; {
          <span class="hljs-keyword">return</span> succ(<span class="hljs-number">0</span>) + succ(n) === succ(succ(n));
        };
        <span class="hljs-comment">/* #@range_end(succ_property) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>succ関数のプロパティテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(succ_property_test) */</span>
        <span class="hljs-comment">/* 100個の整数について命題が正しいかをテストする */</span>
        expect(
          all(
            take(<span class="hljs-number">100</span>)(
              map(proposition)(enumFrom(<span class="hljs-number">0</span>))
            )
          )
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        <span class="hljs-comment">/* #@range_end(succ_property_test) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p><a href="http://akimichi.github.io/functionaljs/">目次に戻る</a> <a href="http://akimichi.github.io/functionaljs/chap03.spec.html">次章に移る</a> </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>});</pre></div></div>
            
        </li>
        
    </ul>
  <!-- <div id="footer">  目次に戻る。 </div> -->
  <!-- </div> -->
</body>
</html>
