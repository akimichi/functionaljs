<!DOCTYPE html>

<html>
<head>
  <title>chap05.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap05.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-">プログラムをコントロールする仕組み</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> truthy = (any) =&gt; {
  <span class="hljs-keyword">return</span> any !== <span class="hljs-literal">false</span> &amp;&amp; any != <span class="hljs-literal">null</span>;
};

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data.call(pattern, pattern);
};

<span class="hljs-keyword">var</span> list  = {
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head, tail) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(head, tail);
    };
  },
  head: (seq) =&gt; {
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (seq) =&gt; {
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (seq) =&gt; {
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },
  <span class="hljs-comment">/* list#append */</span>
  <span class="hljs-comment">/* append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T] */</span>
  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">if</span>(list.isEmpty(xs)){
        <span class="hljs-keyword">return</span> ys;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> list.cons(list.head(xs),(list.append(list.tail(xs))(ys)));
      }
    };
  },
  last: (seq) =&gt; {
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> match(tail, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> head;
          },
          cons: (head, _) =&gt; {
            <span class="hljs-keyword">return</span> list.last(tail);
          }
        });
      }
    });
  },
  <span class="hljs-comment">/* join:: LIST[LIST[T]] -&gt; LIST[T] */</span>
  join: (list_of_list) =&gt; {
    <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
      <span class="hljs-keyword">return</span> list.empty();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> list.append(list.head(list_of_list))(list.join(list.tail(list_of_list)));
    }
  },
  <span class="hljs-comment">/* foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T */</span>
  foldr: (seq) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> match(seq,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));
          }
        });
      };
    };
  },
  <span class="hljs-comment">/* map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T] */</span>
  map: (seq, transform) =&gt; {
    <span class="hljs-keyword">return</span> match(seq,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> list.empty();
      },
      cons: (x,xs) =&gt; {
        <span class="hljs-keyword">return</span> list.cons(transform(x),list.map(xs,transform));
      }
    });
  },
  <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
  reverse: (seq) =&gt; {
    <span class="hljs-keyword">var</span> reverseHelper = (seq, accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(seq, {
        empty: (_) =&gt; {  <span class="hljs-comment">// emptyの場合は、終了条件</span>
          <span class="hljs-keyword">return</span> accumulator;
        },
        cons: (head, tail) =&gt; { <span class="hljs-comment">// consの場合は、再帰的に呼び出す</span>
          <span class="hljs-keyword">return</span> reverseHelper(tail, list.cons(head, accumulator));
        }
      });
    };
    <span class="hljs-keyword">return</span> reverseHelper(seq, list.empty());
  },
  <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
  <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
  filter: (seq) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      expect(predicate).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">var</span> filterAux = (seq, accumulator) =&gt; {
        <span class="hljs-keyword">return</span> match(seq,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
              <span class="hljs-keyword">return</span> list.append(list.append(accumulator)(list.cons(head, list.empty())))(filterAux(tail, accumulator));
            } <span class="hljs-keyword">else</span>  {
              <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
            }
          }
        });
      };
      <span class="hljs-keyword">return</span> filterAux(seq, list.empty());
    };
  },
  <span class="hljs-comment">/* list#length */</span>
  length: (seq) =&gt; {
    <span class="hljs-keyword">return</span> match(seq,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },
      cons: (head,tail) =&gt; {
        <span class="hljs-keyword">return</span> list.foldr(seq)(<span class="hljs-number">0</span>)((item) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + accumulator;
          };
        });
      }
    });
  },
  any: (seq) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      expect(predicate).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> match(seq,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">if</span>(truthy(predicate(head))) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> list.any(tail)(predicate);
          }
        }
      });
    };
  },
  <span class="hljs-comment">/* #@range_end(list_filter) */</span>
  toArray: (seq) =&gt; {
    <span class="hljs-keyword">var</span> toArrayHelper = (seq,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(seq, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayHelper(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayHelper(seq, []);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="-">条文分岐の種類と特徴</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'条文分岐の種類と特徴'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3 id="-if-">条文分岐としてのif文</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'条件分岐としてのif文'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>偶数かどうかを判定する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'偶数かどうかを判定する'</span>, (next) =&gt; {
      <span class="hljs-comment">/* ##@range_begin(even_function)*/</span>
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">if</span>((n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>) { <span class="hljs-comment">// 2で割った余りが0の場合</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// 2で割った余りが0でない場合</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      <span class="hljs-comment">/* ##@range_end(even_function)*/</span>
      expect(
        even(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        even(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">"ネストされたif文で3つ以上の条件分岐を表現する"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(compare) */</span>
      <span class="hljs-keyword">var</span> compare =  (n,m) =&gt; {
        <span class="hljs-keyword">if</span> (n &gt; m) {     <span class="hljs-comment">// nがmよりも大きなケース</span>
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span>(n === m) {  <span class="hljs-comment">// ネストされたif文</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
          }
        }
      };
      <span class="hljs-comment">/* テスト */</span>
      <span class="hljs-comment">/* 3 は 2 よりも大きい */</span>
      expect(
        compare(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* 2 は 3 よりも小さい */</span>
      expect(
        compare(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
      ).to.eql(
          -<span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(compare) */</span>
      <span class="hljs-comment">/* 1 と 1 は等しい */</span>
      expect(
        compare(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      next();
    });
    it(<span class="hljs-string">"elseif文で3つ以上の条件分岐を表現する"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(elseif) */</span>
      <span class="hljs-keyword">var</span> compare =  (n,m) =&gt; {
        <span class="hljs-keyword">if</span> (n &gt; m) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === m) { <span class="hljs-comment">// elseにif文を続ける</span>
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span>  {
          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
      };
      <span class="hljs-comment">/* #@range_end(elseif) */</span>
      <span class="hljs-comment">/* テスト */</span>
      <span class="hljs-comment">/* 3 は 2 よりも大きい */</span>
      expect(
        compare(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* 1 と 1 は等しい */</span>
      expect(
        compare(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      <span class="hljs-comment">/* 2 は 3 よりも小さい */</span>
      expect(
        compare(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
      ).to.eql(
          -<span class="hljs-number">1</span>
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h5 id="if-">if文の問題点</h5>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'if文の問題点'</span>, () =&gt; {
      it(<span class="hljs-string">'returnで関数を抜ける'</span>, (next) =&gt; {
        <span class="hljs-comment">/* ##@range_begin(even_function_again) */</span>
        <span class="hljs-keyword">var</span> even = (n) =&gt; {
          <span class="hljs-keyword">if</span>((n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>) {
            <span class="hljs-comment">/* returnでeven関数を抜けてtrueを返す */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* returnでeven関数を抜けてfalseを返す */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      
          }
        };
        <span class="hljs-comment">/* ##@range_end(even_function_again) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="-switch-">条件分岐としてのswitch文</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'条件分岐としてのswitch文'</span>, () =&gt; {
    it(<span class="hljs-string">"switch文の問題点"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>可変なデータとのマッチング</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(switch_for_mutable) */</span>
      <span class="hljs-keyword">var</span> match_for_mutable = (array) =&gt; {
        <span class="hljs-keyword">switch</span>(array){
        <span class="hljs-keyword">case</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]: <span class="hljs-comment">// [1,2,3] とマッチさせたい</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">// マッチすれば、trueを返す</span>
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// マッチしなければ、falseを返す</span>
        }
      };
      <span class="hljs-comment">/* テスト */</span>
      expect(
        match_for_mutable([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
      ).to.eql(
        <span class="hljs-literal">false</span>  <span class="hljs-comment">// case [1,2,3] にはマッチしない</span>
      );
      <span class="hljs-comment">/* #@range_end(switch_for_mutable) */</span>
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h5 id="-">代数的データ型とパターンマッチ</h5>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'代数的データ型とパターンマッチ'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>代数的データ構造によるリスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'代数的データ構造によるリスト'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(list_in_algebraic_datatype) */</span>
      <span class="hljs-comment">/* リストの代数的データ型 */</span>
      <span class="hljs-keyword">var</span> empty = () =&gt; { <span class="hljs-comment">// 空のリスト</span>
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty();
        };
      };
      <span class="hljs-keyword">var</span> cons = (value, list) =&gt; { <span class="hljs-comment">// 空でないリスト</span>
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(value, list);
        };
      };
      <span class="hljs-comment">/* #@range_end(list_in_algebraic_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>代数的データ構造のmatch関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(match_in_algebraic_datatype) */</span>
      <span class="hljs-comment">/* 代数的データ型に対してパターンマッチを実現する関数 */</span>
      <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
        <span class="hljs-keyword">return</span> data(pattern);
      };
      <span class="hljs-comment">/* #@range_end(match_in_algebraic_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>リストの関数定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(list_function_using_algebraic_datatype) */</span>
      <span class="hljs-comment">/* isEmpty関数は、引数alistに渡されたリストが空のリストかどうかを
         判定する */</span>
      <span class="hljs-keyword">var</span> isEmpty = (alist) =&gt; {
        <span class="hljs-comment">/* match関数で分岐する */</span>
        <span class="hljs-keyword">return</span> match(alist, {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>emptyにマッチするケース</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          empty: (_) =&gt; {          
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>consにマッチするケース</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          cons: (head, tail) =&gt; {  <span class="hljs-comment">// headとtailにそれぞれ先頭と後尾が入る</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });
      };
      <span class="hljs-comment">/* head関数は、引数alistに渡されたリストの先頭の要素を返す */</span>
      <span class="hljs-keyword">var</span> head = (alist) =&gt; {
        <span class="hljs-keyword">return</span> match(alist, {
          <span class="hljs-comment">/* 空のリストに先頭要素はない */</span>
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> head;
          }
        });
      };
      <span class="hljs-comment">/* tail関数は、引数alistに渡されたリストの後尾のリストを返す */</span>
      <span class="hljs-keyword">var</span> tail = (alist) =&gt; {
        <span class="hljs-keyword">return</span> match(alist, {
          <span class="hljs-comment">/* 空のリストに後尾はない */</span>
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> tail;
          }
        });
      };
      <span class="hljs-comment">/* #@range_end(list_function_using_algebraic_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>代数的データ構造のリストの関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(list_in_algebraic_datatype_test) */</span>
      <span class="hljs-comment">/* emptyは空のリストか */</span>
      expect(
        isEmpty(empty())                    
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* cons(1,empty())は空のリストか */</span>
      expect(
        isEmpty(cons(<span class="hljs-number">1</span>,empty()))            
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      <span class="hljs-comment">/* cons(1,empty())の先頭要素は1である */</span>
      expect(
        head(cons(<span class="hljs-number">1</span>,empty()))               
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* cons(1,cons(2,empty()))の2番目の要素は2である */</span>
      expect(
        head(tail(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,empty())))) 
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-comment">/* #@range_end(list_in_algebraic_datatype_test) */</span>
      expect(
        isEmpty(tail(cons(<span class="hljs-number">1</span>,empty())))     <span class="hljs-comment">// [1]の末尾要素は空のリストである</span>
      ).to.be(
        <span class="hljs-literal">true</span>
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>再帰によるlength関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'再帰によるlength関数'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> empty = (_) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty(_);
        };
      };
      <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(x, xs);
        };
      };
      <span class="hljs-comment">/* #@range_begin(recursive_sum_without_accumulator) */</span>
      <span class="hljs-keyword">var</span> sum = (list) =&gt; {
        <span class="hljs-comment">/* 蓄積変数を持つ補助関数 */</span>
        <span class="hljs-keyword">var</span> sumHelper = (list, accumulator) =&gt; { 
          <span class="hljs-keyword">return</span> match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> accumulator;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> sumHelper(tail, accumulator + head);
            }
          });
        };
        <span class="hljs-keyword">return</span> sumHelper(list,<span class="hljs-number">0</span>); <span class="hljs-comment">// 補助関数を呼び出す</span>
      };
      <span class="hljs-comment">/* #@range_end(recursive_sum_without_accumulator) */</span>
      <span class="hljs-comment">/**** テスト ****/</span>
      expect(
        sum(empty())
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        sum(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,cons(<span class="hljs-number">3</span>,empty()))))
      ).to.eql(
        <span class="hljs-number">6</span>
      );
      next();
    });
  });
  it(<span class="hljs-string">'関数渡しで反復文を構築する'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
    <span class="hljs-comment">/* #@range_begin(loop)            */</span>
    <span class="hljs-keyword">var</span> loop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pred, accumulator, expression</span>)</span>{
      <span class="hljs-keyword">if</span>(pred(accumulator)){
        <span class="hljs-keyword">return</span> loop(pred, expression(accumulator), expression);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> accumulator;
      }
    };
    <span class="hljs-keyword">var</span> lessThan = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>{
        <span class="hljs-keyword">return</span> x &lt; n;
      };
    };
    <span class="hljs-keyword">var</span> succ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
      <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
    };
    expect(loop(lessThan(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>, succ)).to.eql(<span class="hljs-number">3</span>);
    <span class="hljs-comment">/* #@range_end(loop) */</span>
    next();
  });
  describe(<span class="hljs-string">'真理値'</span>, () =&gt; {
    it(<span class="hljs-string">'チャーチの真理値'</span>, (next) =&gt; {
      <span class="hljs-comment">/* ##@range_begin(church_truth) */</span>
      <span class="hljs-keyword">var</span> _true = (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
      };
      <span class="hljs-keyword">var</span> _false = (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> y;
        };
      };
      <span class="hljs-keyword">var</span> _ifElse = (pred) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> pred(x)(y);
          };
        };
      };
      <span class="hljs-keyword">var</span> _not = (x) =&gt; {
        <span class="hljs-keyword">return</span> (x(_false))(_true);
      };
      <span class="hljs-keyword">var</span> _and = (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> (x(y))(_false);
        };
      };
      <span class="hljs-keyword">var</span> _or = (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> (x(_true))(y);
        };
      };
      <span class="hljs-comment">/* ##@range_end(church_truth) */</span>
      <span class="hljs-comment">/* ##@range_begin(church_truth_test) */</span>
      expect(
        _true(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">1</span>
      );
      expect(
        _not(_true)(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">0</span>
      );
      expect(
        _and(_true)(_true)(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">1</span>
      );
      expect(
        _ifElse(_true)(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">1</span>
      );
      expect(
        _ifElse(_false)(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">0</span>
      );
      expect(((_) =&gt; {
        <span class="hljs-keyword">var</span> eq = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">if</span>(x === y) {
              <span class="hljs-keyword">return</span> _true;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> _false;
            }
          };
        };
        <span class="hljs-keyword">return</span> _ifElse(eq(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>))(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>);
      })()).to.be(
        <span class="hljs-number">1</span>
      );
      expect(
        _ifElse(_true)(_false)(_true)(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)
      ).to.be(
        <span class="hljs-number">0</span>
      );

      <span class="hljs-comment">/* ##@range_end(church_truth_test) */</span>
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2 id="-">反復処理の種類と特徴</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"反復処理の種類と特徴"</span>, () =&gt; {
  describe(<span class="hljs-string">"while文"</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>while文の例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"while文の例"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(while_counter) */</span>
      <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 変数の初期化</span>
      <span class="hljs-keyword">while</span> (counter &lt; <span class="hljs-number">10</span>) {   <span class="hljs-comment">// 反復の条件</span>
        counter = counter + <span class="hljs-number">1</span>; <span class="hljs-comment">// 変数の更新</span>
      }
      <span class="hljs-comment">/* テスト */</span>
      expect(
        counter
      ).to.eql(
        <span class="hljs-number">10</span>
      );
      <span class="hljs-comment">/* #@range_end(while_counter) */</span>
      next();
    });
  });
  it(<span class="hljs-string">"for文"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>for文の例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(for_example) */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-number">10</span>; counter += <span class="hljs-number">1</span>) {
      ;
    }
    <span class="hljs-comment">/* テスト */</span>
    expect(
      counter
    ).to.eql(
      <span class="hljs-number">10</span>
    );
    <span class="hljs-comment">/* #@range_end(for_example) */</span>
    next();
  });
  describe(<span class="hljs-string">'forEach文'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>forEachメソッドの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"forEach文によるlength"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(forEach_length) */</span>
      <span class="hljs-keyword">var</span> length = (array) =&gt; {
        <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
        array.forEach((element) =&gt; {
          result += <span class="hljs-number">1</span>;
        });
        <span class="hljs-keyword">return</span> result;
      };
      <span class="hljs-comment">/* テスト */</span>
      expect(
        length([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])
      ).to.eql(
        <span class="hljs-number">5</span>
      );
      <span class="hljs-comment">/* #@range_end(forEach_length) */</span>
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="-">再帰による反復処理</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'再帰による反復処理'</span>, () =&gt; {
  describe(<span class="hljs-string">'複利法の例'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>複利の計算</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(compound_interest) */</span>
    <span class="hljs-keyword">var</span> compoundInterest = (a, r, n) =&gt; {
      <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) { <span class="hljs-comment">// 初年度は利率がつかないので元金がそのまま返る</span>
        <span class="hljs-keyword">return</span> a;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">/* compoundInterestの再帰呼び出し */</span>
        <span class="hljs-keyword">return</span> compoundInterest(a, r, n - <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> + r); 
      }
    };
    <span class="hljs-comment">/* #@range_end(compound_interest) */</span>
    it(<span class="hljs-string">"複利の計算"</span>, (next) =&gt; {
      expect(
        compoundInterest(<span class="hljs-number">100000</span>, <span class="hljs-number">0.02</span>, <span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">102000</span>
      );
      expect(
        compoundInterest(<span class="hljs-number">100000</span>, <span class="hljs-number">0.02</span>, <span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">104040</span>  <span class="hljs-comment">// 10万円を預けてから2年後には10万4040円が銀行口座に入っている</span>
      );
      expect(
        compoundInterest(<span class="hljs-number">100000</span>, <span class="hljs-number">0.02</span>, <span class="hljs-number">25</span>)
      ).to.eql(
        <span class="hljs-number">164060.59944647306</span>
      );
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3 id="-">再帰呼び出しの条件</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'再帰呼び出しの条件'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>infiniteLoop関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* ##@range_begin(infiniteLoop) */</span>
    <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
      <span class="hljs-keyword">return</span> infiniteLoop(_);
    };
    <span class="hljs-comment">/* ##@range_end(infiniteLoop) */</span>
    it(<span class="hljs-string">'ifの非正格性'</span>, (next) =&gt; {
      <span class="hljs-comment">/* ##@range_begin(if_nonstrict) */</span>
      <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
        <span class="hljs-keyword">return</span> infiniteLoop(_);     <span class="hljs-comment">/* 同じ関数を実行するので無限ループになります */</span>
      };
      <span class="hljs-keyword">var</span> lessThanFive = (n) =&gt; {
        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">5</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> infiniteLoop(); <span class="hljs-comment">// ここが実行されると無限ループになります</span>
        }
      };
      <span class="hljs-comment">/* テスト */</span>
      expect(
        lessThanFive(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* このテストは実行されると無限ループになるのでコメントアウトしています
         expect(
         lessThanFive(10)
         ).to.eql(
         false // 無限ループ
         );
      */</span>
      <span class="hljs-comment">/* ##@range_end(if_nonstrict) */</span>
      next();
    });
    it(<span class="hljs-string">'再帰によるmap関数'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>第5章で紹介したリスト型</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> match = (exp, pattern) =&gt; {
        <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
      };
      <span class="hljs-keyword">var</span> empty = (_) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty(_);
        };
      };
      <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(x, xs);
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>再帰によるmap関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(recursive_map) */</span>
      <span class="hljs-keyword">var</span> map = (alist,transform) =&gt; {
        <span class="hljs-keyword">return</span> match(alist,{
          empty: (_) =&gt; { <span class="hljs-keyword">return</span> empty(); },  <span class="hljs-comment">// 終了条件で再帰を抜ける</span>
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">return</span> cons(transform(head),
                        map(tail,transform)); <span class="hljs-comment">// map関数の再帰呼び出し</span>
          }
        });
      };
      <span class="hljs-comment">/* #@range_end(recursive_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>再帰によるtoArray関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(recursive_toArray) */</span>
      <span class="hljs-keyword">var</span> toArray = (alist) =&gt; {
        <span class="hljs-comment">/* 補助関数 toArrayHelper */</span>
        <span class="hljs-keyword">var</span> toArrayHelper = (alist,accumulator) =&gt; {
          <span class="hljs-keyword">return</span> match(alist, {
            empty: (_) =&gt; { <span class="hljs-keyword">return</span> accumulator; },  <span class="hljs-comment">// 空のリストの場合は終了</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> toArrayHelper(tail,accumulator.concat(head));
            }
          });
        };
        <span class="hljs-keyword">return</span> toArrayHelper(alist,[]);
      };
      <span class="hljs-comment">/* #@range_end(recursive_toArray) */</span>
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      expect(
        toArray(map(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,cons(<span class="hljs-number">3</span>,empty()))),succ))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h3 id="-">再帰処理の利点</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'再帰処理の利点'</span>, () =&gt; {
    <span class="hljs-keyword">var</span> match = (exp, pattern) =&gt; {
      <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
    };
    <span class="hljs-keyword">var</span> empty = (_) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.empty(_);
      };
    };
    <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.cons(x, xs);
      };
    };
    <span class="hljs-keyword">var</span> isEmpty = (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      });
    };
    <span class="hljs-keyword">var</span> head = (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> head;
        }
      });
    };
    <span class="hljs-keyword">var</span> tail = (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> tail;
        }
      });
    };
    it(<span class="hljs-string">'蓄積変数を持つlength関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(recursive_length) */</span>
      <span class="hljs-keyword">var</span> length = (list, accumulator) =&gt; {
        <span class="hljs-keyword">return</span> match(list, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> length(tail, accumulator + <span class="hljs-number">1</span>); <span class="hljs-comment">// length関数を再帰的に呼び出す</span>
          }
        });
      };
      <span class="hljs-comment">/************************ テスト ************************/</span>
      expect(
        length(empty(), <span class="hljs-number">0</span>)                        <span class="hljs-comment">// []の長さは0</span>
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        length(cons(<span class="hljs-number">1</span>,empty()), <span class="hljs-number">0</span>)                <span class="hljs-comment">// [1]の長さは1</span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        length(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,cons(<span class="hljs-number">3</span>,empty()))),<span class="hljs-number">0</span>) <span class="hljs-comment">// [1,2,3]の長さは3</span>
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      <span class="hljs-comment">/* #@range_end(recursive_length) */</span>
      <span class="hljs-comment">/* #@range_begin(recursive_sum) */</span>
      <span class="hljs-keyword">var</span> sum = (alist, accumulator) =&gt; {
        <span class="hljs-keyword">return</span> match(alist, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-comment">/* sumの再帰呼び出し */</span>
            <span class="hljs-keyword">return</span> sum(tail, accumulator + head); 
          }
        });
      };
      <span class="hljs-comment">/* #@range_end(recursive_sum) */</span>
      <span class="hljs-comment">/**** テスト ****/</span>
      expect(
        sum(empty(), <span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        sum(cons(<span class="hljs-number">1</span>,empty()), <span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        sum(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,cons(<span class="hljs-number">3</span>,empty()))),<span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-number">6</span>
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h4 id="-">再帰処理と再帰的データ構造</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'再帰処理と再帰的データ構造'</span>, () =&gt; {
      describe(<span class="hljs-string">'再帰的データ構造としてのリスト'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>再帰によるlength関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'再帰によるlength関数'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(recursive_length_without_accumulator) */</span>
          <span class="hljs-keyword">var</span> length = (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, {
              <span class="hljs-comment">/* emptyの場合は、終了条件となる */</span>
              empty: (_) =&gt; {    
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
              },
              <span class="hljs-comment">/* consの場合は、length関数を再帰的に呼び出す */</span>
              cons: (head, tail) =&gt; { 
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + length(tail);
              }
            });
          };
          <span class="hljs-comment">/* #@range_end(recursive_length_without_accumulator) */</span>
          <span class="hljs-comment">/************************ テスト ************************/</span>
          expect(
            length(cons(<span class="hljs-number">1</span>,cons(<span class="hljs-number">2</span>,cons(<span class="hljs-number">3</span>,empty())))) <span class="hljs-comment">// [1,2,3]の長さは 3</span>
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>再帰によるappend関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'再帰によるappend関数'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(x, xs);
            };
          };
          <span class="hljs-keyword">var</span> toArray = (seq,callback) =&gt; {
            <span class="hljs-keyword">var</span> toArrayAux = (seq,accumulator) =&gt; {
              <span class="hljs-keyword">return</span> match(seq, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
                }
              });
            };
            <span class="hljs-keyword">return</span> toArrayAux(seq, []);
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>append :: (LIST[T], LIST[T]) -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(list_append) */</span>
          <span class="hljs-keyword">var</span> append = (xs, ys) =&gt; {
            <span class="hljs-keyword">return</span> match(xs,{
              <span class="hljs-comment">/* emptyの場合は、終了条件 */</span>
              empty: (_) =&gt; { 
                <span class="hljs-keyword">return</span> ys; <span class="hljs-comment">// xsが空の場合は、ysを返す</span>
              },
              <span class="hljs-comment">/* consの場合は、append関数を再帰的に呼び出す */</span>
              cons: (head, tail) =&gt; { 
                <span class="hljs-comment">/* xsとysを連結させる */</span>
                <span class="hljs-keyword">return</span> cons(head, append(tail,ys));
              }
            });
          };
          <span class="hljs-comment">/* #@range_end(list_append) */</span>
          
          <span class="hljs-comment">/* #@range_begin(list_append_test) */</span>
          <span class="hljs-keyword">var</span> xs = list.cons(<span class="hljs-number">1</span>,
                             list.cons(<span class="hljs-number">2</span>,
                                       list.empty()));
          <span class="hljs-keyword">var</span> ys = list.cons(<span class="hljs-number">3</span>,
                             list.cons(<span class="hljs-number">4</span>,
                                       list.empty()));
          expect(
            toArray(append(xs,ys)) <span class="hljs-comment">// toArray関数でリストを配列に変換する</span>
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_append_test) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>再帰によるreverse関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'再帰によるreverse関数'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> empty = (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty(_);
            };
          };
          <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(x, xs);
            };
          };
          <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
          <span class="hljs-keyword">var</span> reverse = (list) =&gt; {
            <span class="hljs-keyword">var</span> reverseHelper = (list, accumulator) =&gt; {
              <span class="hljs-keyword">return</span> match(list, {
                empty: (_) =&gt; {  <span class="hljs-comment">// emptyの場合は、終了条件</span>
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; { <span class="hljs-comment">// consの場合は、reverse関数を再帰的に呼び出す</span>
                  <span class="hljs-keyword">return</span> reverseHelper(tail, cons(head, accumulator));
                }
              });
            };
            <span class="hljs-keyword">return</span> reverseHelper(list, empty());
          };
          <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'再帰的データ構造としての数式'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(expression_algebraic_datatype) */</span>
        <span class="hljs-keyword">var</span> num = (n) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.num(n);
          };
        };
        <span class="hljs-keyword">var</span> add = (exp1, exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.add(exp1, exp2);
          };
        };
        <span class="hljs-keyword">var</span> mul = (exp1, exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.mul(exp1, exp2);
          };
        };
        <span class="hljs-comment">/* #@range_end(expression_algebraic_datatype) */</span>
        <span class="hljs-comment">/* #@range_begin(expression_algebraic_datatype_recursion) */</span>
        <span class="hljs-keyword">var</span> calculate = (exp) =&gt; {
          <span class="hljs-keyword">return</span> match(exp, { <span class="hljs-comment">// パターンマッチを実行する</span>
            num: (n) =&gt; {
              <span class="hljs-keyword">return</span> n;
            },
            add: (expL, expR) =&gt; {
              <span class="hljs-comment">/* calculateを再帰的に呼び出して足し算を実行する */</span>
              <span class="hljs-keyword">return</span> calculate(expL) + calculate(expR); 
            },
            mul: (expL, expR) =&gt; {
              <span class="hljs-comment">/* calculateを再帰的に呼び出してかけ算を実行する */</span>
              <span class="hljs-keyword">return</span> calculate(expL) * calculate(expR); 
            }
          });
        };
        <span class="hljs-comment">/**** テスト ****/</span>
        <span class="hljs-comment">/* 1 + (2 * 3) を計算する */</span>
        <span class="hljs-keyword">var</span> expression = add(num(<span class="hljs-number">1</span>),
                             mul(num(<span class="hljs-number">2</span>),
                                 num(<span class="hljs-number">3</span>)));
        expect(
          calculate(expression)
        ).to.eql(
          <span class="hljs-number">7</span>
        );
      });
      <span class="hljs-comment">/* #@range_end(expression_algebraic_datatype_recursion) */</span>
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h4 id="-">再帰処理と帰納法</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'再帰処理と帰納法'</span>, () =&gt; {
    <span class="hljs-keyword">var</span> length = (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: (_) =&gt; {    <span class="hljs-comment">// リストが空のときが終了条件となる</span>
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + length(tail);
        }
      });
    };
    <span class="hljs-keyword">var</span> append = (xs, ys) =&gt; {
      <span class="hljs-keyword">return</span> match(xs,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(head,
                           append(tail,ys));
        }
      });
    };
    it(<span class="hljs-string">'リストの長さに関する命題P'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> empty = (_) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty(_);
        };
      };
      <span class="hljs-keyword">var</span> cons = (x, xs) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(x, xs);
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>命題Pの単体テスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(statement_p_test) */</span>
      <span class="hljs-keyword">var</span> xs = cons(<span class="hljs-number">1</span>,
                    cons(<span class="hljs-number">2</span>,
                         empty()));
      <span class="hljs-keyword">var</span> ys = cons(<span class="hljs-number">3</span>,
                    cons(<span class="hljs-number">4</span>,
                         empty()));
      expect(
        length(append(xs, ys))  <span class="hljs-comment">// 命題Pの左辺</span>
      ).to.eql(
        length(xs) + length(ys) <span class="hljs-comment">// 命題Pの右辺</span>
      );
      <span class="hljs-comment">/* #@range_end(statement_p_test) */</span>
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><a href="http://akimichi.github.io/functionaljs/">目次に戻る</a> <a href="http://akimichi.github.io/functionaljs/chap06.spec.html">次章に移る</a> </p>

            </div>
            
        </li>
        
    </ul>
  <!-- <div id="footer">  目次に戻る。 </div> -->
  <!-- </div> -->
</body>
</html>
