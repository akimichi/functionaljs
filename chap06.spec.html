<!DOCTYPE html>

<html>
<head>
  <title>chap06.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap06.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-">関数を利用する</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data(pattern);
};


<span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = fun;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
      result = result(<span class="hljs-built_in">arguments</span>[i]);
    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-keyword">var</span> flip = (fun) =&gt; {
  <span class="hljs-keyword">return</span>  (f) =&gt; {
    <span class="hljs-keyword">return</span> (g) =&gt; {
      <span class="hljs-keyword">return</span> fun(g)(f);
    };
  };
};

<span class="hljs-keyword">var</span> id = (any) =&gt; {
  <span class="hljs-keyword">return</span> any;
};

<span class="hljs-keyword">var</span> compose = (f) =&gt; {
  <span class="hljs-keyword">return</span> (g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };
};

<span class="hljs-keyword">var</span> list = {
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, list) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, list);
    };
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> match(alist, { <span class="hljs-comment">// match関数で分岐する</span>
      empty: <span class="hljs-literal">true</span>,
      cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> match(alist, {
      empty: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> match(alist, {
      empty: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  toArray: (alist) =&gt; {
    <span class="hljs-keyword">var</span> toArrayAux = (alist,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(alist, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayAux(alist, []);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="-">関数の基本</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数の基本'</span>, () =&gt; {
  <span class="hljs-keyword">var</span> seq = {
    match: (data, pattern) =&gt; {
      <span class="hljs-keyword">return</span> data(pattern);
    },
    empty: (_) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.empty();
      };
    },
    cons: (value, list) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.cons(value, list);
      };
    },
    isEmpty: (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
        empty: <span class="hljs-literal">true</span>,
        cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      });
    },
    head: (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> head;
        }
      });
    },
    tail: (list) =&gt; {
      <span class="hljs-keyword">return</span> match(list, {
        empty: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> tail;
        }
      });
    }
  };
  <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
    <span class="hljs-keyword">return</span> infiniteLoop(_);
  };
  describe(<span class="hljs-string">'関数の定義'</span>, () =&gt; {
    it(<span class="hljs-string">'恒等関数の定義'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_function_definition) */</span>
      <span class="hljs-keyword">var</span> identity = (any) =&gt; {
        <span class="hljs-keyword">return</span> any;
      };
      <span class="hljs-comment">/* #@range_end(identity_function_definition) */</span>
      <span class="hljs-comment">/* #@range_begin(identity_function_test) */</span>
      expect(
        identity(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        identity(<span class="hljs-string">"a"</span>)
      ).to.eql(
        <span class="hljs-string">"a"</span>
      );
      <span class="hljs-comment">/* #@range_end(identity_function_test) */</span>
      next();
    });
    it(<span class="hljs-string">'succ関数の定義'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(succ_function_definition) */</span>
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_end(succ_function_definition) */</span>
      <span class="hljs-comment">/* テスト */</span>
      expect(
        succ(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 0 を引数にsucc関数を適用する</span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_begin(succ_function_test) */</span>
      <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-comment">// nは仮引数 </span>
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      expect(
        succ(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 数値1にsucc関数を適用する</span>
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-comment">/* #@range_end(succ_function_test) */</span>
      next();
    });
    it(<span class="hljs-string">'複数の引数を持つ関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(add_function_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>add:: (NUM, NUM) =&gt; NUM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> add = (n, m) =&gt; {
        <span class="hljs-keyword">return</span> n + m;
      };
      <span class="hljs-comment">/* #@range_end(add_function_definition) */</span>
      <span class="hljs-comment">/* テスト */</span>
      expect(
        add(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      next();
    });
    it(<span class="hljs-string">'引数を参照しない関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(constant_one_function) */</span>
      <span class="hljs-keyword">var</span> alwaysOne = (x) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_end(constant_one_function) */</span>
      expect(
        alwaysOne(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        alwaysOne(<span class="hljs-string">"a"</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_begin(left_function) */</span>
      <span class="hljs-keyword">var</span> left = (x,y) =&gt; {
        <span class="hljs-keyword">return</span> x;
      };
      <span class="hljs-comment">/* #@range_end(left_function) */</span>
      expect(
        left(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      next();
    });
    it(<span class="hljs-string">'関数の変数へのバインド'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(function_bound_to_variable) */</span>
      <span class="hljs-keyword">var</span> succ = (x) =&gt; {
        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_end(function_bound_to_variable) */</span>
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3 id="-">関数の適用</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'関数の適用'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="-">関数の評価戦略</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'関数の評価戦略'</span>, () =&gt; {
      it(<span class="hljs-string">'JavaScriptの正格評価'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(strict_evaluation_in_javascript) */</span>
        <span class="hljs-keyword">var</span> left = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
        <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
          <span class="hljs-keyword">return</span> infiniteLoop(_);
        };
        <span class="hljs-comment">/* このテストは無限ループになるのでコメントアウトしている
         expect(
           left(1, infiniteLoop())
         ).to.eql(
           1
         )
         */</span>
        <span class="hljs-comment">/* #@range_end(strict_evaluation_in_javascript) */</span>
        next();
      });
      it(<span class="hljs-string">'条件文と遅延評価'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(conditional_is_nonstrict) */</span>
        <span class="hljs-keyword">var</span> infiniteLoop = () =&gt; {
          <span class="hljs-keyword">return</span> infiniteLoop();
        };

        <span class="hljs-keyword">var</span> conditional = (n) =&gt; {
          <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* 条件文が真の場合には評価されない */</span>
            <span class="hljs-keyword">return</span> infiniteLoop();
          }
        };
        expect(
          conditional(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-literal">true</span> <span class="hljs-comment">// 無限ループに陥ることなく計算に成功する</span>
        );
        <span class="hljs-comment">/* #@range_end(conditional_is_nonstrict) */</span>
        next();
      });
      it(<span class="hljs-string">'乗算の遅延評価'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> infiniteLoop = () =&gt; {
          <span class="hljs-keyword">return</span> infiniteLoop();
        };
        <span class="hljs-comment">/* #@range_begin(multiply_lazy_evaluation) */</span>
        <span class="hljs-keyword">var</span> lazyMultiply = (funX,funY) =&gt; {
          <span class="hljs-keyword">var</span> x = funX();

          <span class="hljs-keyword">if</span>(x === <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">// xが0ならば、funYは評価しない</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> x * funY(); <span class="hljs-comment">// ここで初めてfunYを評価する</span>
          }
        };
        <span class="hljs-comment">/* #@range_end(multiply_lazy_evaluation) */</span>
        <span class="hljs-comment">/* #@range_begin(multiply_lazy_evaluation_test) */</span>
        expect(
          lazyMultiply((_) =&gt; {    <span class="hljs-comment">// 値を関数でラッピングする</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }, (_) =&gt; {
            <span class="hljs-keyword">return</span> infiniteLoop(); <span class="hljs-comment">// ここが評価されると無限ループに陥る</span>
          })
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        <span class="hljs-comment">/* #@range_end(multiply_lazy_evaluation_test) */</span>
        next();
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h4 id="-">サンクで無限を表現する</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'サンクで無限を表現する'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(definition_thunk_force) */</span>
      <span class="hljs-keyword">var</span> thunk = (func) =&gt; {
        <span class="hljs-keyword">return</span> (arg) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; { <span class="hljs-comment">// サンクを返す</span>
            <span class="hljs-keyword">return</span> func(arg);
          };
        };
      };
      <span class="hljs-keyword">var</span> force = (thunk) =&gt; {
        <span class="hljs-keyword">return</span> thunk();
      };
      <span class="hljs-comment">/* #@range_end(definition_thunk_force) */</span>
      it(<span class="hljs-string">'thunkによる遅延評価'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(nonstrict_function_via_thunk) */</span>
        <span class="hljs-keyword">var</span> multiply = (thunkX,thunkY) =&gt; {
          <span class="hljs-keyword">if</span>(force(thunkX) === <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> thunkX() * thunkY(); <span class="hljs-comment">// サンクを評価する</span>
          }
        };
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        expect(
          multiply((_) =&gt; { <span class="hljs-comment">// サンクで包む</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }, (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
          })
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        <span class="hljs-comment">/* #@range_end(nonstrict_function_via_thunk) */</span>
        next();
      });
      it(<span class="hljs-string">'thunkによる条件式'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(functionalIf_via_thunk) */</span>
        <span class="hljs-keyword">var</span> functionalIf = (predicate, trueClauseThunk, falseClauseThunk) =&gt; {
          <span class="hljs-keyword">if</span>(predicate){
            <span class="hljs-keyword">return</span> trueClauseThunk(); <span class="hljs-comment">// 判定式が真の場合に実行する</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> falseClauseThunk();  <span class="hljs-comment">// 判定式が真の場合に実行する</span>
          }
        };
        <span class="hljs-comment">/* テスト */</span>
        expect(
          functionalIf((<span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span>), (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
          }, (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
          })
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(functionalIf_via_thunk) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'thunkによるStream型'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(stream_with_thunk) */</span>
      <span class="hljs-keyword">var</span> stream = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
          };
        },
        <span class="hljs-comment">/* head:: STREAM[T] =&gt; T */</span>
        <span class="hljs-comment">/* ストリーム型headの定義は、リスト型headと同じ */</span>
        head: (astream) =&gt; {
          <span class="hljs-keyword">return</span> stream.match(astream,{
            empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
            cons: (value, tailThunk) =&gt; { <span class="hljs-keyword">return</span> value; }
          });
        },
        <span class="hljs-comment">/* tail:: STREAM[T] =&gt; STREAM[T] */</span>
        tail: (astream) =&gt; {
          <span class="hljs-keyword">return</span> stream.match(astream,{
            empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> tailThunk(); <span class="hljs-comment">// ここで初めてサンクを評価する</span>
            }
          });
        }
      };
      <span class="hljs-comment">/* #@range_end(stream_with_thunk) */</span>
      it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(stream_with_thunk_test) */</span>
        <span class="hljs-keyword">var</span> theStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; { <span class="hljs-comment">// 第2引数にサンクを渡す</span>
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {         <span class="hljs-comment">// 第2引数にサンクを渡す</span>
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        expect(
          stream.head(theStream)  <span class="hljs-comment">// ストリームの先頭要素を取り出す</span>
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(stream_with_thunk_test) */</span>
        next();
      });
      describe(<span class="hljs-string">"無限ストリーム"</span>, () =&gt; {
        <span class="hljs-keyword">var</span> stream = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
            };
          },
          <span class="hljs-comment">/* head:: STREAM[T] =&gt; T */</span>
          <span class="hljs-comment">/* ストリーム型headの定義は、リスト型headと同じ */</span>
          head: (astream) =&gt; {
            <span class="hljs-keyword">return</span> match(astream,{
              empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
              cons: (value, tailThunk) =&gt; { <span class="hljs-keyword">return</span> value; }
            });
          },
          <span class="hljs-comment">/* tail:: STREAM[T] =&gt; STREAM[T] */</span>
          tail: (astream) =&gt; {
            <span class="hljs-keyword">return</span> match(astream,{
              empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
              cons: (head, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> tailThunk();  <span class="hljs-comment">// ここで初めてサンクを評価する</span>
              }
            });
          },
          take: (astream, n) =&gt; {
            <span class="hljs-keyword">return</span> match(astream,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> list.empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> list.empty();
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> list.cons(head,stream.take(tailThunk(),(n -<span class="hljs-number">1</span>)));
                }
              }
            });
          }
        };
        <span class="hljs-comment">/* #@range_begin(infinite_ones) */</span>
        <span class="hljs-comment">/* ones = 1,1,1,1,... */</span>
        <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> ones; <span class="hljs-comment">// onesを再帰的に呼び出す</span>
        });
        <span class="hljs-comment">/* #@range_end(infinite_ones) */</span>
        <span class="hljs-comment">/* #@range_begin(infinite_integer) */</span>
        <span class="hljs-keyword">var</span> enumFrom = (n) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(n, (_) =&gt; {
            <span class="hljs-keyword">return</span> enumFrom(n + <span class="hljs-number">1</span>);
          });
        };
        <span class="hljs-comment">/* #@range_end(infinite_integer) */</span>
        <span class="hljs-comment">/* #@range_begin(infinite_ones_test) */</span>
        expect(
          stream.head(ones) <span class="hljs-comment">// 最初の要素を取りだす</span>
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          stream.head(stream.tail(ones))  <span class="hljs-comment">// 2番目の要素を取りだす</span>
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(infinite_ones_test) */</span>
        it(<span class="hljs-string">"素数列を作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> sieve = (astream) =&gt; {
            <span class="hljs-keyword">var</span> head = stream.head(astream);
            <span class="hljs-keyword">var</span> tail = stream.tail(astream);
            <span class="hljs-keyword">var</span> mark = (astream, k, m) =&gt; {
              <span class="hljs-keyword">var</span> head = stream.head(astream);
              <span class="hljs-keyword">var</span> tail = stream.tail(astream);
              <span class="hljs-keyword">if</span>(k === m) {
                <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">0</span>,(_) =&gt; {
                  <span class="hljs-keyword">return</span> mark(tail, <span class="hljs-number">1</span>, m);
                });
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> stream.cons(head, (_) =&gt; {
                  <span class="hljs-keyword">return</span> mark(tail, k+<span class="hljs-number">1</span>, m);
                });
              }
            };
            <span class="hljs-keyword">if</span>(head === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> sieve(tail);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> stream.cons(head, (_) =&gt; {
                <span class="hljs-keyword">return</span> sieve(mark(tail, <span class="hljs-number">1</span>, head));
              });
            }
          };
          expect(
            list.toArray(stream.take(sieve(enumFrom(<span class="hljs-number">2</span>)), <span class="hljs-number">10</span>))
          ).to.eql(
            [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>]
          );
          next();
        });
        it(<span class="hljs-string">"無限の整数列をテストする"</span>, (next) =&gt; {
          <span class="hljs-keyword">this</span>.timeout(<span class="hljs-number">3000</span>);
          <span class="hljs-keyword">var</span> list = {
            match: (data, pattern) =&gt; {
              <span class="hljs-keyword">return</span> data(pattern);
            },
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.empty();
              };
            },
            cons: (value, list) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.cons(value, list);
              };
            },
            isEmpty: (alist) =&gt; {
              <span class="hljs-keyword">return</span> match(alist, { <span class="hljs-comment">// match関数で分岐する</span>
                empty: <span class="hljs-literal">true</span>,
                cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });
            },
            head: (alist) =&gt; {
              <span class="hljs-keyword">return</span> match(alist, {
                empty: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> head;
                }
              });
            },
            tail: (alist) =&gt; {
              <span class="hljs-keyword">return</span> match(alist, {
                empty: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> tail;
                }
              });
            },
            <span class="hljs-comment">/* #@range_begin(list_toArray) */</span>
            toArray: (alist) =&gt; {
              <span class="hljs-keyword">var</span> toArrayHelper = (alist,accumulator) =&gt; {
                <span class="hljs-keyword">return</span> list.match(alist, {
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> toArrayHelper(tail,
                                         accumulator.concat(head));
                  }
                });
              };
              <span class="hljs-keyword">return</span> toArrayHelper(alist, []);
            }
            <span class="hljs-comment">/* #@range_end(list_toArray) */</span>
          };
          <span class="hljs-keyword">var</span> stream = {
            match: (data, pattern) =&gt; {
              <span class="hljs-keyword">return</span> data(pattern);
            },
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.empty();
              };
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
              };
            },
            head: (astream) =&gt; {
              <span class="hljs-keyword">return</span> match(astream,{
                empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
                cons: (value, tailThunk) =&gt; { <span class="hljs-keyword">return</span> value; }
              });
            },
            tail: (astream) =&gt; {
              <span class="hljs-keyword">return</span> match(astream,{
                empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
                cons: (head, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> tailThunk();  <span class="hljs-comment">// ここで初めてサンクを評価する</span>
                }
              });
            },
            <span class="hljs-comment">/* #@range_begin(stream_take) */</span>
            <span class="hljs-comment">/* take:: (STREAM[T], NUM) =&gt; LIST[T] */</span>
            take: (astream, n) =&gt; {
              <span class="hljs-keyword">return</span> stream.match(astream,{
                empty: (_) =&gt; {              <span class="hljs-comment">// ストリームが空のケース</span>
                  <span class="hljs-keyword">return</span> list.empty();
                },
                cons: (head,tailThunk) =&gt; {  <span class="hljs-comment">// ストリームが空でないケース </span>
                  <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> list.empty();
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> list.cons(head,   <span class="hljs-comment">// リストを生成する</span>
                                     stream.take(tailThunk(),(n -<span class="hljs-number">1</span>)));
                  }
                }
              });
            },
            <span class="hljs-comment">/* #@range_end(stream_take) */</span>
            <span class="hljs-comment">/* #@range_begin(stream_filter) */</span>
            <span class="hljs-comment">/* filter :: (STREAM[T], FUN[T =&gt; BOOL]) =&gt; STREAM[T] */</span>
            filter: (astream,predicate) =&gt; {
              <span class="hljs-keyword">return</span> match(astream,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.empty();
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">if</span>(predicate(head)){ <span class="hljs-comment">// 先頭の要素が条件に合致する場合、その要素を結果のリストの先頭に追加する</span>
                    <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                      <span class="hljs-keyword">return</span> stream.filter(tailThunk(),predicate);
                    });
                  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 先頭の要素が条件に合致しない場合、末尾要素に対してfilterを再帰的に呼び出す</span>
                    <span class="hljs-keyword">return</span> stream.filter(tailThunk(),predicate);
                  }
                }
              });
            }
            <span class="hljs-comment">/* #@range_end(stream_filter) */</span>
          };
          expect(
            stream.head(enumFrom(<span class="hljs-number">1</span>))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            stream.head(stream.tail(enumFrom(<span class="hljs-number">1</span>)))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_begin(infinite_integer_test) */</span>
          expect(
            list.toArray( <span class="hljs-comment">// ストリームを配列に変換する</span>
              stream.take(enumFrom(<span class="hljs-number">1</span>),<span class="hljs-number">4</span>) <span class="hljs-comment">// 無限の整数列から4個の要素を取り出す </span>
            )
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-comment">/* #@range_end(infinite_integer_test) */</span>
          <span class="hljs-comment">/* #@range_begin(stream_filter_test) */</span>
          expect(
            <span class="hljs-comment">/* 無限の整数列から最初の4つの要素を取り出し、それを配列に変換する */</span>
            list.toArray(stream.take(enumFrom(<span class="hljs-number">1</span>), <span class="hljs-number">4</span>))
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-comment">/* #@range_end(stream_filter_test) */</span>
          <span class="hljs-comment">/* #@range_begin(infinite_even_integer) */</span>
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          <span class="hljs-keyword">var</span> evenIntegers = stream.filter(enumFrom(<span class="hljs-number">1</span>),even);
          expect(
            list.toArray(stream.take(evenIntegers, <span class="hljs-number">4</span>))
          ).to.eql(
            [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span> ]
          );
          <span class="hljs-comment">/* #@range_end(infinite_even_integer) */</span>
          next();
        });
      });
    }); <span class="hljs-comment">// thunk</span>
    describe(<span class="hljs-string">'再帰的な関数適用'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> seq  = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        compose: (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(g(arg));
          };
        },
        flip: (fun) =&gt; {
          <span class="hljs-keyword">return</span>  (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> fun(g)(f);
            };
          };
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        },
        head: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            }
          });
        },
        tail: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            },
          });
        },
        isEmpty: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        <span class="hljs-comment">/* concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T] */</span>
        concat: (xs) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (ys) =&gt; {
            <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
              <span class="hljs-keyword">return</span> ys;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
            }
          };
        },
        last: (xs) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(xs, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> self.match(tail, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> head;
                },
                cons: (head, _) =&gt; {
                  <span class="hljs-keyword">return</span> self.last(tail);
                }
              });
            }
          });
        },
        <span class="hljs-comment">/* concat:: LIST[LIST[T]] -&gt; LIST[T]  */</span>
        join: (list_of_list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
            <span class="hljs-keyword">return</span> self.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.concat(seq.head(list_of_list))(self.join(self.tail(list_of_list)));
          }
        },
        <span class="hljs-comment">/* foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T */</span>
        foldr: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (glue) =&gt; {
              expect(glue).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> self.match(list,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> glue(head)(self.foldr(tail)(accumulator)(glue));
                }
              });
            };
          };
        },
        <span class="hljs-comment">/* map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T] */</span>
        map: (list, transform) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> self.empty();
            },
            cons: (x,xs) =&gt; {
              <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs,transform));
            }
          });
        },
        <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
        <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
        <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
        filter: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (predicate) =&gt; {
            expect(predicate).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">var</span> filterAux = (list, accumulator) =&gt; {
              <span class="hljs-keyword">return</span> self.match(list,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head,tail) =&gt; {
                  <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
                    <span class="hljs-keyword">return</span> self.concat(self.concat(accumulator)(self.cons(head, self.empty())))(filterAux(tail, accumulator));
                  } <span class="hljs-keyword">else</span>  {
                    <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
                  }
                }
              });
            };
            <span class="hljs-keyword">return</span> filterAux(list, self.empty());
          };
        },
        <span class="hljs-comment">/* #@range_end(list_filter) */</span>
        toArray: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">var</span> toArrayHelper = (list,accumulator) =&gt; {
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> toArrayHelper(tail, accumulator.concat(head));
              }
            });
          };
          <span class="hljs-keyword">return</span> toArrayHelper(list, []);
        }
      };
      it(<span class="hljs-string">'dividesTimesの例'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(dividesTimes) */</span>
        <span class="hljs-keyword">var</span> multiplyOf = (n,m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
        expect(
          multiplyOf(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        <span class="hljs-keyword">var</span> dividesTimes = (n, m) =&gt; {
          <span class="hljs-keyword">var</span> dividesTimesHelper = (n,m,accumulator) =&gt; {
            <span class="hljs-keyword">if</span>(n &gt; m) {
              <span class="hljs-keyword">return</span> accumulator;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span>(multiplyOf(n,m)) {
                <span class="hljs-keyword">return</span> dividesTimesHelper(n,m - n,accumulator + <span class="hljs-number">1</span>);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> accumulator;
              }
            }
          };
          <span class="hljs-keyword">return</span> dividesTimesHelper(n,m,<span class="hljs-number">0</span>);
        };
        expect(
          dividesTimes(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          dividesTimes(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>)
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        <span class="hljs-comment">/* #@range_end(dividesTimes) */</span>
        next();
      });
      it(<span class="hljs-string">'list#lastをテストする'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_test) */</span>
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
        expect(
          seq.last(list)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(list_last_test) */</span>
        next();
      });
      it(<span class="hljs-string">'list#mapをテストする'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_map_test) */</span>
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
        expect(
          seq.toArray(seq.map(list,(item) =&gt; {
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          }))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
        next();
      });
      it(<span class="hljs-string">'list#filterテストする'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_filter_test) */</span>
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
        <span class="hljs-keyword">var</span> even = (n) =&gt; {
          <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
        };
        expect(
          seq.toArray(seq.filter(list)(even))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_filter_test) */</span>
        next();
      });
      it(<span class="hljs-string">'list#reverseをテストする'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> reverse = (list,accumulator) =&gt; {
          <span class="hljs-keyword">return</span> seq.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> reverse(tail, seq.cons(head, accumulator));
            }
          });
        };
        <span class="hljs-comment">/**************** テスト ****************/</span>
        <span class="hljs-comment">/* #@range_begin(list_reverse_test) */</span>
        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.empty()));
        expect(
          seq.toArray(reverse(list, seq.empty()))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_reverse_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'関数を合成する'</span>, () =&gt; {
      it(<span class="hljs-string">'関数を連続して適用する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(function_applied_sequentially) */</span>
        <span class="hljs-keyword">var</span> double = (n) =&gt; {
          <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
        };
        <span class="hljs-keyword">var</span> negate = (n) =&gt; {
          <span class="hljs-keyword">return</span> - n;
        };
        expect(
          negate(double(<span class="hljs-number">2</span>))
        ).to.eql(
            -<span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(function_applied_sequentially) */</span>
        <span class="hljs-comment">/* #@range_begin(function_applied_twice) */</span>
        <span class="hljs-keyword">var</span> twice = (f,arg) =&gt; {
          <span class="hljs-keyword">return</span> f(f(arg));
        };
        <span class="hljs-keyword">var</span> succ = (x) =&gt; {
          <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
        };
        expect(
          twice(succ,<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(function_applied_twice) */</span>
        <span class="hljs-comment">/* #@range_begin(function_applied_ntimes) */</span>
        <span class="hljs-keyword">var</span> applyNTimes = (n, func) =&gt; {
          <span class="hljs-keyword">var</span> applyNTimesHelper = (n, func) =&gt; {
            <span class="hljs-keyword">return</span> (init) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> accumulator;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> applyNTimesHelper(n - <span class="hljs-number">1</span>,func)(init)(func(accumulator));
                };
              };
            };
          };
          <span class="hljs-keyword">return</span> applyNTimesHelper(n,func)(<span class="hljs-number">0</span>);
        };
        expect(
          applyNTimes(<span class="hljs-number">4</span>,succ)(<span class="hljs-number">0</span>)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(function_applied_ntimes) */</span>
        next();
      });
      describe(<span class="hljs-string">'関数合成'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_definition) */</span>
        <span class="hljs-keyword">var</span> compose = (f,g,arg) =&gt; {
          <span class="hljs-keyword">return</span> f(g(arg));
        };
        <span class="hljs-comment">/* #@range_end(compose_definition) */</span>
        it(<span class="hljs-string">'否定を合成する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_negation) */</span>
          <span class="hljs-keyword">var</span> negate = (n) =&gt; {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> *  n;
          };
          expect(
            compose(negate,negate, <span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_negation) */</span>
          next();
        });
        it(<span class="hljs-string">'1個の引数の関数を合成する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_one_argument_functions) */</span>
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> prev = (n) =&gt; {
            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
          };
          expect(
            compose(prev,succ,<span class="hljs-number">5</span>)
          ).to.eql(
            <span class="hljs-number">5</span>
          );
          expect(
            compose(prev,succ,<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_one_argument_functions) */</span>
          next();
        });
      });
      it(<span class="hljs-string">'再帰によるlast'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_recursive) */</span>
        <span class="hljs-keyword">var</span> last = (list) =&gt; {
          <span class="hljs-keyword">return</span> seq.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> seq.match(tail, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> head;
                },
                cons: (head, _) =&gt; {
                  <span class="hljs-keyword">return</span> last(tail);
                }
              });
            }
          });
        };
        <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
        expect(
          last(sequence)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        <span class="hljs-comment">/* #@range_end(list_last_recursive) */</span>
        next();
      });
      it(<span class="hljs-string">'合成によるlast'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_compose) */</span>
        <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
        <span class="hljs-keyword">var</span> last = (list) =&gt; {
          <span class="hljs-keyword">return</span> compose(seq.head)(seq.reverse)(list);
        };
        <span class="hljs-comment">/* #@range_end(list_last_compose) */</span>
        next();
      });
    }); <span class="hljs-comment">// 関数を合成する</span>
  }); <span class="hljs-comment">// 関数の適用</span>
}); <span class="hljs-comment">// 関数の基本</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h2 id="-">関数と参照透過性</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数と参照透過性'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3 id="-">関数の純粋性</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'関数の純粋性'</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> succ = (n) =&gt; {
      <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
    };
    <span class="hljs-comment">/* #@range_begin(succ_has_referential_transparency) */</span>
    expect(
      succ(<span class="hljs-number">1</span>)
    ).to.eql(
      succ(<span class="hljs-number">1</span>)
    );
    <span class="hljs-comment">/* #@range_end(succ_has_referential_transparency) */</span>
    next();
  });
  describe(<span class="hljs-string">'副作用が参照透過性を損なうこと'</span>, () =&gt; {
    it(<span class="hljs-string">'ファイルを操作する'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(fileio_destroys_referential_transparency) */</span>
      <span class="hljs-comment">/* fsモジュールを変数fsにバインドする */</span>
      <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
      <span class="hljs-comment">/* テストの実行前にあらかじめ "This is a test."
         という文字列をファイルに書き込んでおく */</span>
      fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is a test."</span>);

      <span class="hljs-comment">/* 第1回目のファイルの読み込み */</span>
      <span class="hljs-keyword">var</span> text = fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>,<span class="hljs-string">'utf8'</span>);
      expect(
        fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>)
      ).to.eql(
        <span class="hljs-string">"This is a test."</span>
      );
      <span class="hljs-comment">/* 途中でのファイルへの書き込み */</span>
      fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>,
                       <span class="hljs-string">"This is another test."</span>);

      <span class="hljs-comment">/* 第2回目のファイルの読み込み */</span>
      expect(
        fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>)
      ).to.eql(<span class="hljs-comment">/* 最初の readFileSync関数の結果と異なっている */</span>
        <span class="hljs-string">"This is another test."</span>
      );
      <span class="hljs-comment">/* #@range_end(fileio_destroys_referential_transparency) */</span>
      next();
    });
  });
  it(<span class="hljs-string">'画面出力が参照透過性を損なうこと'</span>, (next) =&gt; {
    <span class="hljs-comment">/* #@range_begin(log_destroys_referential_transparency) */</span>
    expect(
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is a test"</span>)
    ).to.eql(
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is anoter test"</span>)
    );
    <span class="hljs-comment">/* #@range_end(log_destroys_referential_transparency) */</span>
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h3 id="-">副作用への対処</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'副作用への対処'</span>, () =&gt; {
    describe(<span class="hljs-string">'ストリームによる入出力'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> stream = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (headThunk,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(headThunk,tailThunk);
          };
        },
        head: (astream) =&gt; {
          <span class="hljs-keyword">return</span> stream.match(astream,{
            empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
            cons: (headThunk, tailThunk) =&gt; { <span class="hljs-keyword">return</span> headThunk(); }
          });
        },
        tail: (astream) =&gt; {
          <span class="hljs-keyword">return</span> stream.match(astream,{
            empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> tailThunk(); <span class="hljs-comment">// ここで初めてサンクを評価する</span>
            }
          });
        },
        foldr: (astream) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> stream.match(astream,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (headThunk, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> callback(headThunk())(stream.foldr(tailThunk())(accumulator)(callback));
                }
              });
            };
          };
        } 
      };
      <span class="hljs-keyword">var</span> Req =  {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        readFile: (path) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.readFile(path);
          };
        },
        writeFile: (path, content) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.writeFile(path, content);
          };
        },
        writeConsole: (content) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.writeConsole(content);
          };
        }
      };
      <span class="hljs-keyword">var</span> Res = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        done: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.done(_);
          };
        },
        success: (content) =&gt; {
          <span class="hljs-keyword">return</span> content;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>return (pattern) =&gt; {
  return pattern.successRead(content);
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      };
      <span class="hljs-keyword">var</span> io = {
        executeRequest: (req) =&gt; {
          <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
          <span class="hljs-keyword">return</span> stream.match(req, {
            readFile: (path) =&gt; {
              <span class="hljs-keyword">return</span> Res.success(fs.readFileSync(path, <span class="hljs-string">'utf8'</span>));
            },
            writeConsole: (content) =&gt; {
              <span class="hljs-built_in">console</span>.log(content);
              <span class="hljs-keyword">return</span> Res.success(<span class="hljs-literal">undefined</span>);
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>executeMain:: FUN[STREAM[Res] =&gt; STREAM[Req]] =&gt; IO()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        executeMain: (main) =&gt; {
          <span class="hljs-keyword">return</span> stream.foldr(main)(stream.empty())((response) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons((_) =&gt; {
                <span class="hljs-keyword">return</span> response;
              }, (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;
              });
            }; 
          }); 
        }
      };
      <span class="hljs-keyword">var</span> cat  = (path) =&gt; {
        <span class="hljs-keyword">return</span> (responses) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons((_) =&gt; { <span class="hljs-keyword">return</span> Req.readFile(path); }, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons((_) =&gt; {Req.writeConsole(<span class="hljs-string">"test"</span>);}, (_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>return cat(path)(stream.tail(responses));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> cat(path)(stream.tail(stream.tail(responses)));
            });
          });
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>expect(
  io.executeMain(cat(“/var/log/syslog”))
).to.eql(
  1
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    });
    it(<span class="hljs-string">'kestrelコンビネーター'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(kestrel_combinator) */</span>
      <span class="hljs-keyword">var</span> kestrel = (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
      };
      <span class="hljs-comment">/* #@range_end(kestrel_combinator) */</span>
      <span class="hljs-comment">/* #@range_begin(kestrel_combinator_test) */</span>
      expect(
        kestrel(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/*
       expect(
         kestrel(1)(infiniteLoop())
       ).to.eql(
         1
       );
       */</span>
      <span class="hljs-comment">/* #@range_end(kestrel_combinator_test) */</span>
      <span class="hljs-comment">/*
      setTimeout(function(){ // happens 0.5 seconds later:
        expect(
       kestrel(1)(infiniteLoop())
        ).to.eql(
       1
        );
        next(); // this tells mocha to run the next test
      },500);
      */</span>
      next();
    });
  });
  describe(<span class="hljs-string">'tapコンビネーターによる副作用の分離'</span>, () =&gt; {
    <span class="hljs-comment">/* #@range_begin(tap_combinator) */</span>
    <span class="hljs-keyword">var</span> tap = (target,sideEffect) =&gt; {
      sideEffect(target); <span class="hljs-comment">// 副作用を実行する</span>
      <span class="hljs-keyword">return</span> target;
    };
    <span class="hljs-comment">/* #@range_end(tap_combinator) */</span>
    it(<span class="hljs-string">'tapコンビネーターによる console.logのテスト'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_console) */</span>
      <span class="hljs-comment">/* 画面出力という副作用を実行する関数 */</span>
      <span class="hljs-keyword">var</span> consoleSideEffect = (any) =&gt; {
        <span class="hljs-built_in">console</span>.log(any);
      };
      expect(
        tap(succ(<span class="hljs-number">1</span>), consoleSideEffect)
      ).to.eql(
        tap(succ(<span class="hljs-number">1</span>), consoleSideEffect)
      );
      <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_console) */</span>
      <span class="hljs-keyword">var</span> updateSideEffect = (n) =&gt; {
        n = n + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> n;
      };
      expect(
        tap(succ(<span class="hljs-number">2</span>), updateSideEffect)
      ).to.eql(
        tap(succ(<span class="hljs-number">2</span>), updateSideEffect)
      );
      next();
    });
    it(<span class="hljs-string">'tapコンビネーターによるオブジェクトの操作'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_object) */</span>
      <span class="hljs-keyword">var</span> updateSideEffect = (obj) =&gt; {
        obj.name = <span class="hljs-string">"C3PO"</span>;
        <span class="hljs-keyword">return</span> obj;
      };
      <span class="hljs-keyword">var</span> r2d2 = {name: <span class="hljs-string">"R2D2"</span>};
      expect(
        tap(r2d2, updateSideEffect).name
      ).to.eql(
        tap(r2d2, updateSideEffect).name
      );
      expect(
        r2d2.name
      ).to.eql(
        <span class="hljs-string">"C3PO"</span>
      );
      <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_object) */</span>
      next();
    });
    it(<span class="hljs-string">'tapコンビネーターによるファイル入出力のテストは失敗する'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// fsモジュールを変数fsにバインドする</span>
      <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_fileio) */</span>
      <span class="hljs-comment">/* あらかじめ文字列をファイルに書き込んでおく */</span>
      fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is a test."</span>);

      <span class="hljs-comment">/* ファイルからの読み込みという副作用を実行する */</span>
      <span class="hljs-keyword">var</span> IOSideEffect = (_) =&gt; {
        <span class="hljs-keyword">var</span> content = fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>,
                                      <span class="hljs-string">'utf8'</span>);
        fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>,
                         <span class="hljs-string">"This is another test."</span>);
        <span class="hljs-keyword">return</span> content;
      };

      expect(
        tap(fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>),
            IOSideEffect)
      ).not.to.eql( <span class="hljs-comment">// 同じ引数に適用しているのに両者は等しくない</span>
        tap(fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>),
            IOSideEffect)
      );
      <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_fileio) */</span>
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
    </ul>
    <div id="footer">
      目次に戻る。 
    </div>
  </div>
</body>
</html>
