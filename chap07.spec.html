<!DOCTYPE html>

<html>
<head>
  <title>chap07.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap07.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data(pattern);
};

<span class="hljs-keyword">var</span> id = (any) =&gt; {
  <span class="hljs-keyword">return</span> any;
};

<span class="hljs-keyword">var</span> list  = {
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, seq) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, seq);
    };
  },
  head: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>list#concat
concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xs) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">if</span>(list.isEmpty(xs)){
        <span class="hljs-keyword">return</span> ys;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> list.cons(list.head(xs),(list.concat(list.tail(xs))(ys)));
      }
    };
  },
  last: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(seq, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> match(tail, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> head;
          },
          cons: (head, _) =&gt; {
            <span class="hljs-keyword">return</span> list.last(tail);
          }
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  join: (list_of_list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
      <span class="hljs-keyword">return</span> list.empty();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> list.concat(list.head(list_of_list))(list.join(list.tail(list_of_list)));
    }
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> match(seq,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));
          }
        });
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (seq, transform) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(seq,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> list.empty();
      },
      cons: (x,xs) =&gt; {
        <span class="hljs-keyword">return</span> list.cons(transform(x),list.map(xs,transform));
      }
    });
  },
  <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
  reverse: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> reverseAux = (seq, accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(seq, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> reverseAux(tail, list.cons(head, accumulator));
        }
      });
    };
    <span class="hljs-keyword">return</span> reverseAux(seq, list.empty());
  },
  <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
  <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
  filter: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      expect(predicate).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">var</span> filterAux = (seq, accumulator) =&gt; {
        <span class="hljs-keyword">return</span> match(seq,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
              <span class="hljs-keyword">return</span> list.concat(list.concat(accumulator)(list.cons(head, list.empty())))(filterAux(tail, accumulator));
            } <span class="hljs-keyword">else</span>  {
              <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
            }
          }
        });
      };
      <span class="hljs-keyword">return</span> filterAux(seq, list.empty());
    };
  },
  <span class="hljs-comment">/* #@range_end(list_filter) */</span>
  toArray: (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> toArrayAux = (seq,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(seq, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayAux(seq, []);
  }
};

it(<span class="hljs-string">'listのテスト'</span>, (next) =&gt; {
  <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,
                           list.cons(<span class="hljs-number">2</span>,
                                     list.cons(<span class="hljs-number">3</span>,
                                               list.cons(<span class="hljs-number">4</span>,
                                                         list.empty()))));
  expect(
    list.head(sequence)
  ).to.eql(
    <span class="hljs-number">1</span>
  );
  expect(
    list.toArray(sequence)
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
  );
  expect(
    list.toArray(list.reverse(sequence))
  ).to.eql(
    [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
  );
  expect(
    list.head(list.reverse(sequence))
  ).to.eql(
    <span class="hljs-number">4</span>
  );

  expect(
    list.last(sequence)
  ).to.eql(
    <span class="hljs-number">4</span>
  );</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>init = reverse . tail . reverse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> init = (seq) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> compose(list.reverse)(compose(list.tail)(list.reverse))(seq);
  };
  <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
  expect(
    list.toArray(init(seq))
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
  );
  next();
});

<span class="hljs-keyword">var</span> truthy = (any) =&gt; {
  <span class="hljs-keyword">return</span> any !== <span class="hljs-literal">false</span> &amp;&amp; any != <span class="hljs-literal">null</span>;
};

<span class="hljs-keyword">var</span> double = (number) =&gt; {
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
};


<span class="hljs-keyword">var</span> compose = (f) =&gt; {
  <span class="hljs-keyword">return</span> (g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };
};


<span class="hljs-keyword">var</span> stream = {
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> value;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> tailThunk();
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h2 id="stream-map">stream#map</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="stream-concat">stream#concat</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
      <span class="hljs-keyword">return</span> match(xs,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ysThunk();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.concat(tailThunk())(ysThunk);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> stream.concat(head)((_) =&gt; {
          <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
        });
      }
    });
  },
  toArray: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> [];
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> match(tailThunk(),{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> [head];
          },
          cons: (head_,tailThunk_) =&gt; {
            <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
          }
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h3 id="stream-fromlist">stream#fromList</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  fromArray: (array) =&gt; {
    <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
      <span class="hljs-keyword">return</span> stream.concat(accumulator)(stream.cons(item, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      }));
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3 id="stream-take">stream#take</h3>
<p>take:: STREAM -&gt; NUMBER -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  take: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (number) =&gt; {
      expect(number).to.a(<span class="hljs-string">'number'</span>);
      expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> stream.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.take(tailThunk())(number -<span class="hljs-number">1</span>);
            });
          }
        }
      });
    };
  }
}; <span class="hljs-comment">// stream</span>

describe(<span class="hljs-string">'streamのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">'stream#map'</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    <span class="hljs-keyword">var</span> doubled_stream = stream.map(lazyList)((item) =&gt; {
      <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
    });
    expect(
      stream.head(doubled_stream)
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      stream.head(stream.tail(doubled_stream))
    ).to.eql(
      <span class="hljs-number">4</span>
    );
    
    next();
  });
});

describe(<span class="hljs-string">'高階関数'</span>, () =&gt; {
  describe(<span class="hljs-string">'カリー化'</span>, () =&gt; {
    it(<span class="hljs-string">'カリー化された関数の単純な例'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(simple_curried_function) */</span>
      <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>) </span>{
        <span class="hljs-keyword">return</span> x + y ;
      };
      <span class="hljs-keyword">var</span> addCurried =  (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> x + y ;
        };
      };
      expect(
        add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        addCurried(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
      );
      <span class="hljs-comment">/* #@range_end(simple_curried_function) */</span>
      next();
    });
    it(<span class="hljs-string">'カリー化による関数の部品化'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(multiplyOf_curried) */</span>
      <span class="hljs-keyword">var</span> multiplyOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_end(multiplyOf_curried) */</span>
      <span class="hljs-comment">/* #@range_begin(multiplyOf_curried_test) */</span>
      <span class="hljs-keyword">var</span> twoFold = multiplyOf(<span class="hljs-number">2</span>);
      <span class="hljs-keyword">var</span> threeFold = multiplyOf(<span class="hljs-number">3</span>);
      expect(
        twoFold(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        threeFold(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(multiplyOf_curried_test) */</span>
      next();
    });

    describe(<span class="hljs-string">'通常の関数とカリー化関数の相互変換'</span>, () =&gt; {
      it(<span class="hljs-string">'通常の関数をカリー化する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(curry_function_definition) */</span>
        <span class="hljs-keyword">var</span> curry = (fun) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">x,optionalY</span>)</span>{
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>){
              <span class="hljs-keyword">return</span> fun.call(<span class="hljs-keyword">this</span>, x,optionalY);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partiallyApplied</span>(<span class="hljs-params">y</span>) </span>{
                <span class="hljs-keyword">return</span> fun.call(<span class="hljs-keyword">this</span>, x,y);
              };
            }
          };
        };
        <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x + y;
        };
        <span class="hljs-keyword">var</span> curriedAdd = curry(add);
        expect(
          curriedAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(curry_function_definition) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化を通常の関数に変換する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(uncurry_function_definition) */</span>
        <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = fun;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
              result = result(<span class="hljs-built_in">arguments</span>[i]);
            <span class="hljs-keyword">return</span> result;
          };
        };
        <span class="hljs-keyword">var</span> addCurried = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
        };
        <span class="hljs-keyword">var</span> add = uncurry(addCurried);
        expect(
          add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(uncurry_function_definition) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'関数合成のカリー化'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(compose_definition_curried) */</span>
      <span class="hljs-keyword">var</span> compose = (f) =&gt; {
        <span class="hljs-keyword">return</span> (g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt;{
            <span class="hljs-keyword">return</span> f(g(arg));
          };
        };
      };
      <span class="hljs-comment">/* #@range_end(compose_definition_curried) */</span>

      <span class="hljs-comment">/* #@range_begin(flip) */</span>
      <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
        <span class="hljs-keyword">return</span>  (f) =&gt; {
          <span class="hljs-keyword">return</span> (g) =&gt; {
            <span class="hljs-keyword">return</span> fun(g)(f);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>return fun.call(this, g)(f);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          };
        };
      };
      <span class="hljs-keyword">var</span> callee = (n) =&gt; {
        <span class="hljs-keyword">return</span> (callback) =&gt; {
          <span class="hljs-keyword">return</span> callback(n);
        };
      };
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      expect(flip(callee)(succ)(<span class="hljs-number">2</span>)).to.eql(<span class="hljs-number">3</span>);
      <span class="hljs-comment">/* #@range_end(flip) */</span>
      it(<span class="hljs-string">'カリー化の合成で乗算と否定の合成は成功する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_negate_multiply_successful) */</span>
        <span class="hljs-keyword">var</span> compose = (f) =&gt; {
          <span class="hljs-keyword">return</span> (g) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt;{
              <span class="hljs-keyword">return</span> f(g(arg));
            };
          };
        };
        <span class="hljs-keyword">var</span> negate = (x) =&gt; {
          <span class="hljs-keyword">return</span> - x;
        };
        <span class="hljs-keyword">var</span> multiply = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x * y;
          };
        };
        expect(
          compose(negate)(multiply(<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)
        ).to.eql(
            -<span class="hljs-number">6</span>
        );
        <span class="hljs-comment">/* #@range_end(compose_negate_multiply_successful) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化による関数の合成'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_and_uncurry) */</span>
        <span class="hljs-keyword">var</span> compose = (f) =&gt; {
          <span class="hljs-keyword">return</span> (g) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> f(g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
            };
          };
        };
        <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
          <span class="hljs-keyword">return</span> () =&gt; {
            <span class="hljs-keyword">var</span> result = fun;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
              result = result(<span class="hljs-built_in">arguments</span>[i]);
            <span class="hljs-keyword">return</span> result;
          };
        };
        <span class="hljs-keyword">var</span> negate = (x) =&gt; {
          <span class="hljs-keyword">return</span> -x;
        };
        <span class="hljs-keyword">var</span> multiply = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x * y;
          };
        };
        expect(
          compose(negate)(uncurry(multiply))(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
        ).to.eql(
            -<span class="hljs-number">6</span>
        );
        <span class="hljs-comment">/* #@range_end(compose_and_uncurry) */</span>
        next();
      });
      it(<span class="hljs-string">'マイナスのマイナスはプラス'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(composition_example_negation_twice) */</span>
        <span class="hljs-keyword">var</span> negate = (n) =&gt; {
          <span class="hljs-keyword">return</span> - n;
        };
        expect(
          compose(negate)(negate)(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(composition_example_negation_twice) */</span>
        next();
      });
      it(<span class="hljs-string">"1個の引数の関数を合成する"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> decrement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> double = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n;
        };
        expect(
          compose(increment)(decrement)(<span class="hljs-number">5</span>)
        ).to.eql(
          <span class="hljs-number">5</span>
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>expect(<strong>.compose.bind(</strong>)(decrement)(increment)(5)).to.be(5);
expect(<strong>.compose.bind(</strong>)(increment)(increment)(5)).to.be(7);
// (n <em> 2) + 1
expect(<strong>.compose.bind(</strong>)(increment)(double)(5)).to.be(11);
// (n + 1) </em> 2
expect(<strong>.compose.bind(</strong>)(double)(increment)(5)).to.be(12);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      describe(<span class="hljs-string">"pipe関数による合成"</span>, () =&gt; {
        it(<span class="hljs-string">"composeでlastを定義する"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt; {
                <span class="hljs-keyword">return</span> f.call(self,
                              g.call(self,arg));
              };
            };
          };
          <span class="hljs-keyword">var</span> last = (seq) =&gt; {
            <span class="hljs-keyword">return</span> compose(list.head)(list.reverse)(seq);
          };
          <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          next();
        });
        it(<span class="hljs-string">"pipeでlastを定義する"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt; {
                <span class="hljs-keyword">return</span> f.call(self,
                              g.call(self,arg));
              };
            };
          };
          <span class="hljs-comment">/* #@range_begin(last_with_pipe) */</span>
          <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span>  (f) =&gt; {
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> fun.call(self, g)(f); <span class="hljs-comment">// return fun(g)(f);</span>
              };
            };
          };
          <span class="hljs-keyword">var</span> pipe = (fun) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            expect(fun).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> flip.call(self,
                             compose)(fun);
          };
          <span class="hljs-keyword">var</span> last = (seq) =&gt; {
            <span class="hljs-keyword">return</span> pipe(list.reverse)(list.head)(seq);
          };
          <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(last_with_pipe) */</span>
          next();
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>it(“‘compose two argument functions’”, function(next) {
  var negate = function(x) {
    return -x;
  };
  var multiply = function(x,y){
    return x * y;
  };
  expect((<strong>.compose.bind(</strong>)(negate)(multiply))(2,3)).to.eql(-6);
  next();
});
it(“compose several functions”, function(next) {
  var not = function(x){
    return ! x;
  };
  expect(
    <strong>.compose.bind(</strong>)(not)(math.isEqual(3))(3)
  ).to.eql(
      false
  );
  // expect(
  //   <strong>.compose.bind(</strong>)(__.not)(math.isEqual(3))(3)
  // ).to.eql(
  //  false
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }); <span class="hljs-comment">// 関数合成のカリー化</span>
    it(<span class="hljs-string">'リストの逆順を求める'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> seq = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        empty: (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty;
        },
        cons: (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        },
        isEmpty: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
            empty: <span class="hljs-literal">true</span>,
            cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
          });
        },
        head: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            },
          });
        },
        tail: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            },
          });
        }
      };
      <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
      <span class="hljs-keyword">var</span> reverse = (list) =&gt; {
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> seq.match(list, {
            empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> reverse(tail)(seq.cons(head, accumulator))
            },
          });
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>toArray:: LIST -&gt; ARRAY -&gt; ARRAY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> toArray = (list) =&gt; {
        <span class="hljs-keyword">var</span> toArrayAux = (list) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> seq.match.call(seq,
                                  list, {
                                    empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
                                    cons: (head, tail) =&gt; {
                                      <span class="hljs-keyword">return</span> toArrayAux(tail)(accumulator.concat(head))
                                    }
                                  });
          };
        };
        <span class="hljs-keyword">return</span> toArrayAux(list)([])
      };
      <span class="hljs-comment">/**************** テスト ****************/</span>
      expect(
        toArray(reverse(seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.empty)))(seq.empty))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
      );
      <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
      next();
    });
  });
  describe(<span class="hljs-string">'クロージャーで状態をカプセル化する'</span>, () =&gt; {
    describe(<span class="hljs-string">'関数とデータの類似性'</span>, (next) =&gt; {
      it(<span class="hljs-string">'関数とリストの類似性'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        };
        <span class="hljs-keyword">var</span> empty = (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty;
        };
        <span class="hljs-keyword">var</span> cons = (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        };
        <span class="hljs-keyword">var</span> isEmpty = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
            empty: <span class="hljs-literal">true</span>,
            cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
          });
        };
        <span class="hljs-keyword">var</span> head = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            },
          });
        };
        <span class="hljs-keyword">var</span> tail = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            },
          });
        };
        <span class="hljs-comment">/*
          ~~~haskell
          list2fct :: Eq a =&gt; [(a,b)] -&gt; a -&gt; b
          list2fct [] _ = error "function not total"
          list2fct ((u,v):uvs) x | x == u = v
          | otherwise = list2fct uvs x
          fct2list :: (a -&gt; b) -&gt; [a] -&gt; [(a,b)]
          fct2list f xs = [ (x, f x) | x &lt;- xs ]
          ~~~
        */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>var list2function = (list) =&gt; {
   return (any) =&gt; {
     if(head(list)) {
       if(head(list) === any){
         return
       } else {
       }
   } else {
   }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      describe(<span class="hljs-string">'クロージャーによる「環境」の実装'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(environment_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="-">空の環境</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> emptyEnv = (variable) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        };
        <span class="hljs-comment">/* 変数名に対応する値を環境から取りだす */</span>
        <span class="hljs-keyword">var</span> lookupEnv = (identifier, env) =&gt; {
          <span class="hljs-keyword">return</span> env(identifier);
        };
        <span class="hljs-comment">/* 環境を拡張する */</span>
        <span class="hljs-keyword">var</span> extendEnv = (identifier, value, env) =&gt; {
          <span class="hljs-keyword">return</span> (queryIdentifier) =&gt; {
            <span class="hljs-keyword">if</span>(identifier === queryIdentifier) {
              <span class="hljs-keyword">return</span> value;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> lookupEnv(queryIdentifier,env);
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(environment_in_closure) */</span>
        it(<span class="hljs-string">'extendEnvで環境を作り、 lookupEnv で環境を探る'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(environment_in_closure_test) */</span>
          expect(
            lookupEnv(<span class="hljs-string">"a"</span>, emptyEnv)
          ).to.be(
            <span class="hljs-literal">undefined</span>
          );
          <span class="hljs-keyword">var</span> newEnv = extendEnv(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>, emptyEnv);
          expect(
            lookupEnv(<span class="hljs-string">"a"</span>, newEnv)
          ).to.be(
            <span class="hljs-number">1</span>
          );
          expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>var a = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> firstEnv = extendEnv(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>var b = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> secondEnv = extendEnv(<span class="hljs-string">"b"</span>,<span class="hljs-number">3</span>, firstEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>辞書から b の値を参照する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"b"</span>,secondEnv);
          })()).to.eql(
            <span class="hljs-number">3</span>
          );
          expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>var x = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> xEnv = extendEnv(<span class="hljs-string">"x"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>var z = 2 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> zEnv = extendEnv(<span class="hljs-string">"z"</span>, <span class="hljs-number">2</span>, xEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>内部のスコープで var x = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> xEnvInner = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">3</span>, zEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>内部のスコープで var y = 4 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> innerMostEnv = extendEnv(<span class="hljs-string">"y"</span>,<span class="hljs-number">4</span>, xEnvInner);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>一番内側のスコープを利用して x + y + z を計算する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"x"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"y"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"z"</span>,innerMostEnv) ;
          })()).to.eql(
            <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(environment_in_closure_test) */</span>
          next();
        });
      });
    });
    it(<span class="hljs-string">'クロージャーの変数バインディング'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(free_variable_in_closure) */</span>
      <span class="hljs-keyword">var</span> outerFunction = (outerArgument) =&gt; {
        <span class="hljs-keyword">var</span> innerFunction = (innerArgument) =&gt; {
          <span class="hljs-keyword">return</span> outerArgument + innerArgument;
        };
        <span class="hljs-keyword">return</span> innerFunction;
      };
      <span class="hljs-comment">/* #@range_end(free_variable_in_closure) */</span>
      next();
    });
    describe(<span class="hljs-string">'クロージャーと参照透過性'</span>, () =&gt; {
      it(<span class="hljs-string">'multiplyOf関数は参照透過である'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> multiplyOf = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          };
        };
        <span class="hljs-comment">/* #@range_begin(multiplyOf_is_transparent) */</span>
        expect(
          multiplyOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
        ).to.eql(
          multiplyOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
        );
        expect(
          multiplyOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
        ).to.eql(
          multiplyOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
        );
        <span class="hljs-comment">/* #@range_end(multiplyOf_is_transparent) */</span>
        next();
      });
      it(<span class="hljs-string">'参照透過でないクロジャーの例'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(counter_is_not_transparent) */</span>
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> _init = init;
          <span class="hljs-keyword">return</span> (_) =&gt; {
            _init = _init + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> _init;
          };
        };
        <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
        expect(
          counterFromZero()
        ).not.to.eql( <span class="hljs-comment">// notで一致しないことをテストしている</span>
          counterFromZero()
        );
        <span class="hljs-comment">/* #@range_end(counter_is_not_transparent) */</span>
        next();
      });
      it(<span class="hljs-string">'参照透過でないクロジャーの利用法'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>チャーチ数 church numeral</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> zero = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> x;
          };
        };
        <span class="hljs-keyword">var</span> one = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(x);
          };
        };
        <span class="hljs-keyword">var</span> two = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(x));
          };
        };
        <span class="hljs-keyword">var</span> three = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(f(x)));
          };
        };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(n(f)(x));
            };
          };
        };
        <span class="hljs-keyword">var</span> add = (m) =&gt; {
          <span class="hljs-keyword">return</span> (n) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> (x) =&gt;{
                <span class="hljs-keyword">return</span> m(f)(n(f)(x));
              };
            };
          };
        };
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> _init = init;
          <span class="hljs-keyword">return</span> (_) =&gt; {
            _init = _init + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> _init;
          };
        };
        <span class="hljs-comment">/* #@range_begin(closure_as_counter) */</span>
        expect(
          one(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          two(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          add(one)(two)(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(closure_as_counter) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'不変なデータ型を作る'</span>, () =&gt; {
      it(<span class="hljs-string">'不変なオブジェクト型を作る'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>var objects = {
  empty: {
  },
  set: (key,value,obj) =&gt; {
    expect(obj).to.an(‘object’);
    obj[key] = value;
    return obj;
  },
  get: (key,obj) =&gt; {
    expect(obj).to.an(‘object’);
    return obj[key];
  },
  isEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for(var key in obj){
      if(hasOwnProperty.call(obj, key))
        return false;
    }
  },
  isNotEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    return ! this.objects.isEmpty(obj);
  },
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(immutable_object_type) */</span>
        <span class="hljs-keyword">var</span> objects = {
          empty: (key) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
          },
          get: (key, obj) =&gt; {
            <span class="hljs-keyword">return</span> obj(key);
          },
          set: (key, value, obj) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (key2) =&gt; {
              <span class="hljs-keyword">if</span>(key === key2) {
                <span class="hljs-keyword">return</span> value;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.get(key2,obj)
              }
            }
          }
        };
        <span class="hljs-comment">/* #@range_end(immutable_object_type) */</span>
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_test) */</span>
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty)))
        ).to.eql(
          <span class="hljs-string">"Star Wars"</span>
        )
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))
        ).to.eql(
          <span class="hljs-literal">undefined</span>
        )
        expect(
          objects.get(<span class="hljs-string">"HAL9000"</span>, objects.set.call(objects,<span class="hljs-string">"C3PO"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set.call(objects,<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set.call(objects,<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))))
        ).to.eql(
          <span class="hljs-string">"2001: a space odessay"</span>
        )
        <span class="hljs-comment">/* #@range_end(immutable_object_type_test) */</span>
        next();
      });
      it(<span class="hljs-string">'不変なオブジェクト型を作る(改良版)'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved) */</span>
        <span class="hljs-keyword">var</span> objects = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
          },
          get: (key, obj) =&gt; {
            <span class="hljs-keyword">return</span> obj(key);
          },
          set: (key, value, obj) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (key2) =&gt; {
              <span class="hljs-keyword">if</span>(key === key2) {
                <span class="hljs-keyword">return</span> value;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.get(key2,obj)
              }
            }
          },
          fromObject: (obj) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">var</span> keys = (o) =&gt; {
              <span class="hljs-keyword">var</span> result = [];
              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> o) {
                <span class="hljs-keyword">if</span>(o.hasOwnProperty(prop))
                  result.push(prop);
              }
              <span class="hljs-keyword">return</span> result;
            };
            <span class="hljs-keyword">return</span> keys(obj).reduce((accumulator, key) =&gt; {
              <span class="hljs-keyword">return</span> self.set.call(self,key, obj[key], accumulator);
            }, self.empty)
          }
        };
        <span class="hljs-comment">/* #@range_end(immutable_object_type_improved) */</span>
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved_test) */</span>
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))
        ).to.eql(
          <span class="hljs-literal">undefined</span>
        );
        expect(
          objects.get(<span class="hljs-string">"HAL9000"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
        ).to.eql(
          <span class="hljs-string">"2001: a space odessay"</span>
        );
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
        ).to.eql(
          <span class="hljs-string">"Star Wars"</span>
        );
        <span class="hljs-comment">/* #@range_end(immutable_object_type_improved_test) */</span>
        next();
      });
      it(<span class="hljs-string">'不変なリスト型'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(immutable_list) */</span>
        <span class="hljs-keyword">var</span> seq = {
          empty: (index) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          },
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> f(head,tail);
            };
          },
          head: (array) =&gt; {
            <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            });
          },
          tail: (array) =&gt; {
            <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            });
          },
          at: (index,array) =&gt; {
            <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head(array);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.at(index -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.tail(array));
            }
          }
        };
        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.empty)));
        expect(
          seq.head(list)
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        expect(
          seq.head(seq.tail(list))
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          seq.at(<span class="hljs-number">0</span>,list)
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        expect(
          seq.at(<span class="hljs-number">1</span>,list)
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          seq.at(<span class="hljs-number">2</span>,list)
        ).to.eql(
          <span class="hljs-number">3</span>
        )
        <span class="hljs-comment">/* #@range_end(immutable_list) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>it(‘不変な配列型’, (next) =&gt; {
  var arrays = {
    empty: [],
    cons: (any,array) =&gt; {
      expect(array).to.an(‘array’);
      return [any].concat(array);
    },
    head: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return ary[0];
    },
    tail: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      expect(self.isNonEmpty(ary)).to.be.ok();
      return ary.slice(1,ary.length);
    },
    get: (index,ary) =&gt; {
      expect(index).to.be.a(‘number’);
      expect(ary).to.an(‘array’);
      return ary[index];
    },
    isEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.equal.call(self,ary.length)(0);
    },
    isNotEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.not.call(self,self.arrays.isEmpty(ary));
    }
  };
  expect(
    arrays.cons(1,arrays.empty)
  ).to.eql(
    [1]
  )
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'代数的ストリーム型'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(algebraic_stream) */</span>
        <span class="hljs-keyword">var</span> empty = (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.empty(_);
          };
        };
        <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
          expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            cons: (value, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> value;
            }
          });
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> tailThunk();
            }
          });
        };
        <span class="hljs-keyword">var</span> isEmpty = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head1,tailThunk1) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        };
        <span class="hljs-keyword">var</span> concat = (xs) =&gt; {
          <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
            <span class="hljs-keyword">return</span> match(xs,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> ysThunk();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> cons(head,(_) =&gt; {
                  <span class="hljs-keyword">return</span> concat(tailThunk())(ysThunk);
                });
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(algebraic_stream) */</span>
        <span class="hljs-comment">/* #@range_begin(algebraic_stream_helpers) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> toArray = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> [];
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> match(tailThunk(),{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> [head];
                },
                cons: (head_,tailThunk_) =&gt; {
                  <span class="hljs-keyword">return</span> [head].concat(toArray(tailThunk()));
                }
              });
            }
          });
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="stream-fromlist">stream#fromList</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fromArray = (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
            <span class="hljs-keyword">return</span> concat(accumulator)(cons(item, (_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            }));
          });
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3 id="stream-take">stream#take</h3>
<p>take:: STREAM -&gt; NUMBER -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> take = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (number) =&gt; {
            expect(number).to.a(<span class="hljs-string">'number'</span>);
            expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> empty();
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> cons(head,(_) =&gt; {
                    <span class="hljs-keyword">return</span> take(tailThunk())(number -<span class="hljs-number">1</span>);
                  });
                }
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(algebraic_stream_helpers) */</span>
        it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>stream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            tail(stream)
          ).to.a(<span class="hljs-string">"function"</span>);
          expect(
            head(tail(stream))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"無限ストリーム"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(infinite_stream) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>ones = [1,1,1,1,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> ones = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          expect(
            head(ones)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            head(tail(ones))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-comment">/* #@range_end(infinite_stream) */</span>
          <span class="hljs-comment">/* #@range_begin(infinite_integer) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>ones = [1,2,3,4,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> intgersFrom = (n) =&gt; {
            <span class="hljs-keyword">return</span> cons(n, (_) =&gt; {
              <span class="hljs-keyword">return</span> intgersFrom(n + <span class="hljs-number">1</span>);
            });
          };
          expect(
            head(intgersFrom(<span class="hljs-number">1</span>))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            head(tail(intgersFrom(<span class="hljs-number">1</span>)))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            toArray(take(intgersFrom(<span class="hljs-number">1</span>))(<span class="hljs-number">10</span>))
          ).to.eql(
            [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> ] 
          );
          <span class="hljs-comment">/* #@range_end(infinite_integer) */</span>
          next();
        });
        it(<span class="hljs-string">"代数的ストリーム型は不変ではない"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> object = head(stream);
          object.key = <span class="hljs-number">2</span>;
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
          );
          next();
        });
      });
      describe(<span class="hljs-string">'不変なストリーム型'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_stream) */</span>
        <span class="hljs-keyword">var</span> empty = (index) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };
        <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> f(head,tailThunk);
          };
        };
        <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> head;
          });
        };
        <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> tailThunk();
          });
        };
        <span class="hljs-comment">/* #@range_end(immutable_stream) */</span>
        it(<span class="hljs-string">"関数的ストリーム型は不変である"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> object = head(stream);
          object.key = <span class="hljs-number">2</span>;
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
          );
          next();
        });
      });
    });
    describe(<span class="hljs-string">'クロージャーでジェネレーターを作る'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(generator_in_closure) */</span>
      <span class="hljs-keyword">var</span> generator = (seed) =&gt; {
        <span class="hljs-keyword">return</span> (current) =&gt; {
          <span class="hljs-keyword">return</span> (stepFunction) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(current(seed),
                               (_) =&gt; { 
                                 <span class="hljs-keyword">return</span> generator(stepFunction(seed))(current)(stepFunction) 
                               });
          };
        };
      };
      <span class="hljs-keyword">var</span> id = (any) =&gt; { <span class="hljs-keyword">return</span> any; };
      <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>; };
      <span class="hljs-keyword">var</span> integers = generator(<span class="hljs-number">0</span>)(id)(succ);
      expect(
        stream.head(integers)
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        stream.head(stream.tail(integers))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        stream.head(stream.tail(stream.tail(integers)))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-comment">/* #@range_end(generator_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>describe(‘streamとgenerator’, () =&gt; {
  var integers = generator(0)(id)(succ);
  var double = (n) =&gt; {
    return n * 2;
  };
  var doubles = stream.map.call(stream,
                                integers, double);
  expect(
    stream.head(integers)
  ).to.eql(
    0
  );</p>

            </div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    });
  }); <span class="hljs-comment">// クロージャーで状態をカプセル化する</span>
  describe(<span class="hljs-string">'関数を渡す'</span>, () =&gt; {
    describe(<span class="hljs-string">'コールバックを渡す'</span>, () =&gt; {
      it(<span class="hljs-string">'直接コールする'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(direct_call) */</span>
        <span class="hljs-keyword">var</span> succ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> directCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> succ(n);
        };
        expect(
          directCall(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(direct_call) */</span>
        next();
      });
      it(<span class="hljs-string">'コールバックを呼び出す'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(call_callback) */</span>
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> call_callback = (callback) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> callback(arg);
          };
        };
        expect(
          call_callback(succ)(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(call_callback) */</span>
        next();
      });
      describe(<span class="hljs-string">'イベント駆動'</span>, () =&gt; {
        it(<span class="hljs-string">'イベントを処理する'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> processEvent = (event) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> callback(event);
            };
          };
          <span class="hljs-keyword">var</span> anEvent = {<span class="hljs-string">"temperture"</span>: <span class="hljs-number">26.0</span>};
          expect(
            processEvent(anEvent)((theEvent) =&gt; {
              <span class="hljs-keyword">return</span> theEvent.temperture;
            })
          ).to.eql(
            <span class="hljs-number">26</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>var extract = (key) =&gt; {
  return (object) =&gt; {
 return object[key];
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> extractTemperture = (event) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>return processEvent(event)(extract(“temperture”));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> processEvent(event)((theEvent) =&gt; {
              <span class="hljs-keyword">return</span> theEvent.temperture;
            });
          };
          expect(
            extractTemperture(anEvent)
          ).to.eql(
            <span class="hljs-number">26</span>
          );
          next();
        });
        it(<span class="hljs-string">'リストのmap'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_map) */</span>
          <span class="hljs-keyword">var</span> map = (seq) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> match(seq,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> list.empty();
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> stream.cons(callback(head), map(tail)(callback));
                }
              });
            };
          };
          <span class="hljs-comment">/* #@range_end(list_map) */</span>
          <span class="hljs-comment">/* #@range_begin(list_map_test) */</span>
          <span class="hljs-keyword">var</span> numberList = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.empty()));
          <span class="hljs-keyword">var</span> double = (number) =&gt; {
            <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
          };
          <span class="hljs-keyword">var</span> doubledList = map(numberList)(double);
          expect(
            list.head(doubledList)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            list.toArray(doubledList)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-keyword">var</span> stringList = list.cons(<span class="hljs-string">"a"</span>, list.cons(<span class="hljs-string">"b"</span>,list.empty()));
          <span class="hljs-keyword">var</span> upper = (string) =&gt; {
            <span class="hljs-keyword">return</span> string.toUpperCase();
          };
          expect(
            list.toArray(map(stringList)(upper))
          ).to.eql(
            [<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
          next();
        });
        describe(<span class="hljs-string">'リストの再帰関数'</span>, () =&gt; {
          it(<span class="hljs-string">'リストの合計'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(list_sum) */</span>
            <span class="hljs-keyword">var</span> sum = (seq) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> match(seq,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> sum(tail)(accumulator + head);
                  }
                });
              };
            };
            <span class="hljs-keyword">var</span> numberList = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
            expect(
              sum(numberList)(<span class="hljs-number">0</span>)
            ).to.eql(
              <span class="hljs-number">6</span>
            );
            <span class="hljs-comment">/* #@range_end(list_sum) */</span>
            <span class="hljs-comment">/* #@range_begin(list_sum_callback) */</span>
            <span class="hljs-keyword">var</span> sumWithCallbak = (seq) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> (callback) =&gt; {
                  <span class="hljs-keyword">return</span> match(seq,{
                    empty: (_) =&gt; {
                      <span class="hljs-keyword">return</span> accumulator;
                    },
                    cons: (head, tail) =&gt; {
                      <span class="hljs-keyword">return</span> sumWithCallbak(tail)(callback(accumulator)(head))(callback);
                    }
                  });
                };
              };
            };
            <span class="hljs-keyword">var</span> add = (n) =&gt; {
              <span class="hljs-keyword">return</span> (m) =&gt; {
                <span class="hljs-keyword">return</span> n + m;
              };
            };
            expect(
              sumWithCallbak(numberList)(<span class="hljs-number">0</span>)(add)
            ).to.eql(
              <span class="hljs-number">6</span>
            );
            <span class="hljs-comment">/* #@range_end(list_sum_callback) */</span>
            next();
          });
          it(<span class="hljs-string">'リストの長さ'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(list_length) */</span>
            <span class="hljs-keyword">var</span> length = (seq) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> match(seq,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> length(tail)(accumulator + <span class="hljs-number">1</span>);
                  }
                });
              };
            };
            <span class="hljs-keyword">var</span> numberList = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
            expect(
              length(numberList)(<span class="hljs-number">0</span>)
            ).to.eql(
              <span class="hljs-number">3</span>
            );
            <span class="hljs-comment">/* #@range_end(list_length) */</span>
            <span class="hljs-comment">/* #@range_begin(list_length_callback) */</span>
            <span class="hljs-keyword">var</span> lengthWithCallbak = (seq) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> (callback) =&gt; {
                  <span class="hljs-keyword">return</span> match(seq,{
                    empty: (_) =&gt; {
                      <span class="hljs-keyword">return</span> accumulator;
                    },
                    cons: (head, tail) =&gt; {
                      <span class="hljs-keyword">return</span> lengthWithCallbak(tail)(callback(accumulator))(callback);
                    }
                  });
                };
              };
            };
            <span class="hljs-keyword">var</span> add = (n) =&gt; {
              <span class="hljs-keyword">return</span> (m) =&gt; {
                <span class="hljs-keyword">return</span> n + m;
              };
            };
            expect(
              lengthWithCallbak(numberList)(<span class="hljs-number">0</span>)(add(<span class="hljs-number">1</span>))
            ).to.eql(
              <span class="hljs-number">3</span>
            );
            <span class="hljs-comment">/* #@range_end(list_length_callback) */</span>
            next();
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>it(‘リストの逆転’, (next) =&gt; {
  /<em> #@range_begin(list_reverse) </em>/
  var length = (seq) =&gt; {
 return (accumulator) =&gt; {
   return match(seq,{
     empty: (_) =&gt; {
       return accumulator;
     },
     cons: (head, tail) =&gt; {
       return length(tail)(accumulator + 1);
     }
   });
 };
  };
  var numberList = list.cons(1, list.cons(2,list.cons(3,list.empty())));
  expect(
 length(numberList)(0)
  ).to.eql(
 3
  );
  /<em> #@range_end(list_reverse) </em>/
  var lengthWithCallbak = (seq) =&gt; {
     return (accumulator) =&gt; {
       return (callback) =&gt; {
         return match(seq,{
           empty: (_) =&gt; {
             return accumulator;
           },
         cons: (head, tail) =&gt; {
           return lengthWithCallbak(tail)(callback(accumulator))(callback);
         }
         });
       };
     };
  };
  var add = (n) =&gt; {
     return (m) =&gt; {
       return n + m;
     };
  };
  expect(
     lengthWithCallbak(numberList)(0)(add(1))
  ).to.eql(
     3
  );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        });
        it(<span class="hljs-string">'ストリームのmap'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(stream_map) */</span>
          <span class="hljs-keyword">var</span> map = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.empty();
                },
                cons: (head, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> stream.cons(callback(head), (_) =&gt; {
                    <span class="hljs-keyword">return</span> map(tailThunk())(callback);
                  });
                }
              });
            };
          };
          <span class="hljs-comment">/* #@range_end(stream_map) */</span>
          <span class="hljs-comment">/* #@range_begin(stream_map_test) */</span>
          <span class="hljs-keyword">var</span> numberStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> double = (number) =&gt; {
            <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
          };
          <span class="hljs-keyword">var</span> doubled_stream = map(numberStream)(double);
          expect(
            stream.head(doubled_stream)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            stream.toArray(doubled_stream)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-keyword">var</span> stringStream = stream.cons(<span class="hljs-string">"a"</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-string">"b"</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> upper = (string) =&gt; {
            <span class="hljs-keyword">return</span> string.toUpperCase();
          };
          expect(
            stream.toArray(map(stringStream)(upper))
          ).to.eql(
            [<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>]
          );
          <span class="hljs-comment">/* #@range_end(stream_map_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>var request = {
  login: (user, password) =&gt; {
 return (pattern) =&gt; {
   expect(pattern).to.an(‘object’);
   return pattern.login(user, password);
 };
  },
  logout: (session) =&gt; {
 return (pattern) =&gt; {
   expect(pattern).to.an(‘object’);
   return pattern.logout(session);
 };
  }
};
var subscribe = (init) =&gt; {
  var subscriptions = init;
  return (request) =&gt; {
 return subscriptions.concat([request]);
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
      });
    });
    describe(<span class="hljs-string">'畳み込み関数で反復処理を渡す'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>var seq  = {
  match: (data, pattern) =&gt; {
    var self = this;
    return data(pattern);
  },
  empty: (<em>) =&gt; {
    return (pattern) =&gt; {
      return pattern.empty();
    };
  },
  cons: (value, list) =&gt; {
    return (pattern) =&gt; {
      return pattern.cons(value, list);
    };
  },
  head: (list) =&gt; {
    var self = this;
    return self.match(list, {
      empty: (</em>) =&gt; {
        return undefined;
      },
      cons: (head, tail) =&gt; {
        return head;
      },
    });
  },
  tail: (list) =&gt; {
    var self = this;
    return self.match(list, {
      empty: (<em>) =&gt; {
        return undefined;
      },
      cons: (head, tail) =&gt; {
        return tail;
      },
    });
  },
  isEmpty: (list) =&gt; {
    var self = this;
    return seq.match(list, {
      empty: (</em>) =&gt; {
        return true;
      },
      cons: (head, tail) =&gt; {
        return false;
      },
    });
  },
// concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
concat: (xs) =&gt; {
   var self = this;
   return (ys) =&gt; {
     if(self.isEmpty(xs)){
       return ys;
     } else {
       return self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
     }
   };
},
// concat:: LIST[LIST[T]] -&gt; LIST[T]
join: (list_of_list) =&gt; {
   var self = this;
   if(self.isEmpty(list_of_list)){
     return self.empty();
   } else {
     return self.concat(seq.head(list_of_list))(self.join(seq.tail(list_of_list)));
   }
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(foldr_toArray) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>toArray: (list) =&gt; {
  var self = this;
  return self.foldr(list)([])(function (item) {
    return (accumulator) =&gt; {
      return [item].concat(accumulator);
    };
  });
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_end(foldr_toArray) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'畳み込み関数foldr'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_foldr) */</span>
        <span class="hljs-keyword">var</span> foldr = (seq) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (glue) =&gt; {
              expect(glue).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> match(seq,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));
                }
              });
            };
          };
        };
        <span class="hljs-comment">/* #@range_end(list_foldr) */</span>
        it(<span class="hljs-string">"foldrでsumを作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_sum) */</span>
          <span class="hljs-keyword">var</span> sum = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)(<span class="hljs-number">0</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator + item;
              };
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            sum(seq)
          ).to.eql(
            <span class="hljs-number">10</span>  <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_sum) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでproductを作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_product) */</span>
          <span class="hljs-keyword">var</span> product = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)(<span class="hljs-number">1</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator * item;
              };
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            product(seq)
          ).to.eql(
            <span class="hljs-number">24</span> <span class="hljs-comment">// 1 * 2 * 3 * 4 = 24</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_product) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでlength関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_length) */</span>
          <span class="hljs-keyword">var</span> length = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)(<span class="hljs-number">0</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator + <span class="hljs-number">1</span>;
              };
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            length(seq)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_length) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでall関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_all) */</span>
          <span class="hljs-keyword">var</span> all = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)(<span class="hljs-literal">true</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator &amp;&amp; truthy(item);
              };
            });
          };
          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-literal">true</span>,list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-literal">null</span>,list.cons(<span class="hljs-string">"a"</span>,list.empty()))));
          expect(
            all(seq)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_all) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでtoArray関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_toarray) */</span>
          <span class="hljs-keyword">var</span> toArray = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)([])((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> [item].concat(accumulator);
              };
            });
          };
          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-literal">true</span>,list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-literal">null</span>,list.cons(<span class="hljs-string">"a"</span>,list.empty()))));
          expect(
            toArray(seq)
          ).to.eql(
            [ <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'a'</span> ]
          );
          <span class="hljs-comment">/* #@range_end(foldr_toarray) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrで reverse関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_reverse) */</span>
          <span class="hljs-keyword">var</span> reverse = (seq) =&gt; {
            <span class="hljs-keyword">return</span> foldr(seq)(list.empty())((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> list.concat(accumulator)(list.cons(item,list.empty()));
              };
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            list.toArray(reverse(seq))
          ).to.eql(
            [ <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
          );
          <span class="hljs-comment">/* #@range_end(foldr_reverse) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrで map関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_map) */</span>
          <span class="hljs-keyword">var</span> map = (seq) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              <span class="hljs-keyword">return</span> foldr(seq)(list.empty())((item) =&gt; {
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">return</span> list.cons(transform(item), accumulator);
                };
              });
            };
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            list.toArray(map(seq)(double))
          ).to.eql(
            [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]
          );
          <span class="hljs-comment">/* #@range_end(foldr_map) */</span>
          next();
        });
      });
    }); <span class="hljs-comment">// 畳み込み関数で反復処理を渡す</span>
    describe(<span class="hljs-string">'継続を渡す'</span>, () =&gt; {
      describe(<span class="hljs-string">"継続の導入例"</span>, () =&gt; {
        it(<span class="hljs-string">"算術の継続"</span>, (next) =&gt; {
		  <span class="hljs-comment">/* #@range_begin(continuation_in_arithmetic) */</span>
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> continuation = (any) =&gt; { <span class="hljs-comment">// 値をそのまま返すだけの継続</span>
            <span class="hljs-keyword">return</span> any;
          };
          expect(
            id(succ(<span class="hljs-number">1</span>))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> succCPS = (n, continues) =&gt; {
            <span class="hljs-keyword">return</span> continues(n + <span class="hljs-number">1</span>);
          };
          expect(
            succCPS(<span class="hljs-number">1</span>, id)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> multiply = (n,m) =&gt; {
            <span class="hljs-keyword">return</span> n * m;
          };
          expect(
            multiply(succ(<span class="hljs-number">1</span>), <span class="hljs-number">3</span>)
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-keyword">var</span> multiplyCPS = (n,m, continues) =&gt; {
            <span class="hljs-keyword">return</span> continues(n * m);
          };
          expect(
            multiplyCPS(succCPS(<span class="hljs-number">1</span>, continuation), <span class="hljs-number">3</span>,continuation) <span class="hljs-comment">// 継続を渡す</span>
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(continuation_in_arithmetic) */</span>
		  next();
        });
        it(<span class="hljs-string">"継続としての蓄積変数"</span>, (next) =&gt; {
		  <span class="hljs-comment">/* #@range_begin(accumulator_as_continuation) */</span>
          <span class="hljs-keyword">var</span> succCPS = (n, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span> + accumulator;
          };
          expect(
            succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> multiplyCPS = (n,m, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> n * m * accumulator;
          };
          expect(
            multiplyCPS(succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 蓄積変数を渡す</span>
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          expect(
            multiplyCPS(succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), succCPS(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>) <span class="hljs-comment">// 蓄積変数を渡す</span>
          ).to.eql(
            <span class="hljs-number">8</span>
          );
          <span class="hljs-comment">/* #@range_end(accumulator_as_continuation) */</span>
		  next();
        });
        it(<span class="hljs-string">"クライアントサーバー通信の継続"</span>, (next) =&gt; {
		  
		  next();
        });
      });
      it(<span class="hljs-string">"継続による反復処理"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(loop_cps) */</span>
        <span class="hljs-keyword">var</span> loop = (predicate, accumulator) =&gt; {
          <span class="hljs-keyword">return</span> (continues) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(accumulator)){
              <span class="hljs-keyword">return</span> loop(predicate, continues(accumulator))(continues);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> accumulator;
            }
          };
        };
        <span class="hljs-keyword">var</span> lessThan = (n) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> x &lt; n;
          };
        };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        expect(
          loop(lessThan(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>)(succ)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(loop_cps) */</span>
        next();
      });
    });
  }); <span class="hljs-comment">// 関数を渡す</span>
  describe(<span class="hljs-string">'コンビネーター'</span>, () =&gt; {
    <span class="hljs-comment">/* #@range_begin(not_combinator) */</span>
    it(<span class="hljs-string">'論理コンビネータ'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> not = (f) =&gt; {
        <span class="hljs-keyword">return</span> (arg) =&gt; {
          <span class="hljs-keyword">return</span> ! f(arg);
        };
      };
      <span class="hljs-keyword">var</span> multiplyOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-keyword">var</span> even = multiplyOf(<span class="hljs-number">2</span>);
      expect(
        even(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-keyword">var</span> odd = not(even);
      expect(
        odd(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      expect(
        odd(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(not_combinator) */</span>
      <span class="hljs-keyword">var</span> or = (f) =&gt; {
        <span class="hljs-keyword">return</span> (g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) || g(arg);
          };
        };
      };
      <span class="hljs-keyword">var</span> and = (f) =&gt; {
        <span class="hljs-keyword">return</span> (g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) &amp;&amp; g(arg);
          };
        };
      };
      <span class="hljs-keyword">var</span> positive = (n) =&gt; {
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>;
      };
      <span class="hljs-keyword">var</span> isZero = (n) =&gt; {
        <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span>;
      };
      <span class="hljs-keyword">var</span> negative = or(positive)(not(isZero));
      expect(
        negative(-<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        negative(<span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">'パイプライン'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> pipe = (f, g) =&gt; {
        <span class="hljs-keyword">return</span> (input) =&gt; {
          <span class="hljs-keyword">return</span> compose(f,g)(input);
        };
      };
      <span class="hljs-keyword">var</span> pipelines = (combinators) =&gt; {
        <span class="hljs-keyword">return</span> (input) =&gt; {
          <span class="hljs-keyword">return</span> combinators.reduce((accumulator, combinator) =&gt; {
            <span class="hljs-keyword">return</span> compose(combinator,accumulator)
          });
        };
      };
      next();
    });
    describe(<span class="hljs-string">'コンビネーター・ライブラリー'</span>, () =&gt; {
      describe(<span class="hljs-string">'オブジェクト型検証コンビネータ'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
        <span class="hljs-keyword">var</span> isEmpty = (obj) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>null and undefined are “empty”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Assume if it has a length property with a non-zero value
that that property is correct.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (obj.length &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">if</span> (obj.length === <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Otherwise, does it have any properties of its own?
Note that this doesn’t handle
toString and valueOf enumeration bugs in IE &lt; 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
            <span class="hljs-keyword">if</span> (hasOwnProperty.call(obj, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };

        <span class="hljs-comment">/* パース結果の代数的データ型 */</span>
        <span class="hljs-keyword">var</span> result = {
          failed: (message) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.failed(message);
            };
          },
          successful: (value, inputObject) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.successful(value, inputObject);
            };
          }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>validate: PARSER -&gt; JSON -&gt; PARSERESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> validate = (validator, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> validator(inputObject, continues, continuesInFailure);
          };
        };
        <span class="hljs-comment">/* 基本パーサー */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>succeed:: ANY =&gt; LIST =&gt; RESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> succeed = (value, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> continues(result.successful(value, inputObject));
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>fail:: (ANY) =&gt; LIST =&gt; PARSERESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fail = (message, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> continuesInFailure(result.failed(message));
          };
        };
        <span class="hljs-keyword">var</span> continues = {
	  	  normally: (result) =&gt; {
	  	    <span class="hljs-keyword">return</span> result;
	  	  },
          abnormally: (exception) =&gt; {
            <span class="hljs-keyword">return</span> exception;
	  	  }
        };
        it(<span class="hljs-string">'succeed'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> object = {
            key: <span class="hljs-number">1</span>
          };
          match(validate(succeed(<span class="hljs-literal">true</span>, continues.normally, continues.abnormally)(object)),{
            failed: () =&gt; {
              expect().fail();
            },
            successful: (value, theObject) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-number">1</span>
              );
              expect(
                theObject
              ).to.eql(
                object
              );
            }
          });
          next();
        });
        it(<span class="hljs-string">'fail'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> object = {
            key: <span class="hljs-number">1</span>
          };
          match(validate(fail(<span class="hljs-string">"failed"</span>, continues.normally, continues.abnormally)(object)),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">"failed"</span>
              );
            },
            successful: (value, theObject) =&gt; {
              expect().fail();
            }
          });
          next();
        });
        <span class="hljs-keyword">var</span> is = (predicate, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(target)){
              <span class="hljs-keyword">return</span> continues(succeed(<span class="hljs-literal">true</span>, continues, continuesInFailure)(target));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> continuesInFailure(fail(<span class="hljs-string">"is not"</span>, continues, continuesInFailure)(target));
            }
          };
        };
        <span class="hljs-keyword">var</span> typeOf = (target) =&gt; {
          <span class="hljs-keyword">if</span>(target === <span class="hljs-literal">undefined</span> || target === <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(target);
          <span class="hljs-keyword">var</span> classToType = {
            <span class="hljs-string">'[object Boolean]'</span>: <span class="hljs-string">'boolean'</span>,
            <span class="hljs-string">'[object Number]'</span>: <span class="hljs-string">'number'</span>,
            <span class="hljs-string">'[object String]'</span>: <span class="hljs-string">'string'</span>,
            <span class="hljs-string">'[object Function]'</span>: <span class="hljs-string">'function'</span>,
            <span class="hljs-string">'[object Array]'</span>: <span class="hljs-string">'array'</span>,
            <span class="hljs-string">'[object Date]'</span>: <span class="hljs-string">'date'</span>,
            <span class="hljs-string">'[object RegExp]'</span>: <span class="hljs-string">'regexp'</span>,
            <span class="hljs-string">'[object Object]'</span>: <span class="hljs-string">'object'</span>
          };
          <span class="hljs-keyword">return</span> classToType[<span class="hljs-built_in">Object</span>.prototype.toString.call(target)];
        };
        <span class="hljs-keyword">var</span> bool = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'boolean'</span>;
        };
        <span class="hljs-keyword">var</span> string = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'string'</span>;
        };
        <span class="hljs-keyword">var</span> number = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'number'</span>;
        };
        it(<span class="hljs-string">'is'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(is_number_test) */</span>
          <span class="hljs-keyword">var</span> target = <span class="hljs-number">1</span>;
          match(validate(is(number, continues.normally, continues.abnormally)(target)),{
            failed: (message) =&gt; {
              expect().fail();
            },
            successful: (value, target) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-literal">true</span>
              );
            }
          });
          <span class="hljs-comment">/* #@range_end(is_number_test) */</span>
          next();
        });
        <span class="hljs-keyword">var</span> hasKey = (key, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">if</span>(isEmpty(inputObject)) {
              <span class="hljs-keyword">return</span> continuesInFailure(fail(<span class="hljs-string">"empty"</span>, continues, continuesInFailure)(inputObject));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> theKey <span class="hljs-keyword">in</span> inputObject) {
                <span class="hljs-keyword">if</span> (hasOwnProperty.call(inputObject, key)) {
                  <span class="hljs-keyword">return</span> continues(succeed(<span class="hljs-literal">true</span>, continues, continuesInFailure)(inputObject));
                }
              }
              <span class="hljs-keyword">return</span> continuesInFailure(fail(key + <span class="hljs-string">" is not found"</span>, continues, continuesInFailure)(inputObject));
            }
          };
        };
        it(<span class="hljs-string">'hasKey'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> inputObject = {
            <span class="hljs-string">"key"</span>: <span class="hljs-number">1</span>
          };
          match(validate(hasKey(<span class="hljs-string">"key"</span>, continues.normally, continues.abnormally)(inputObject)),{
            failed: (message) =&gt; {
              expect().fail();
            },
            successful: (value, inputObject) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-literal">true</span>
              );
            }
          });
          match(validate(hasKey(<span class="hljs-string">"nokey"</span>, continues.normally, continues.abnormally)({})),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">'empty'</span>
              );
            },
            successful: (value, inputObject) =&gt; {
              expect().fail();
            }
          });
          match(validate(hasKey(<span class="hljs-string">"nokey"</span>, continues.normally, continues.abnormally)(inputObject)),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">'nokey is not found'</span>
              );
            },
            successful: (value, inputObject) =&gt; {
              expect().fail();
            }
          });
          next();
        });
      });
      it(<span class="hljs-string">'ケージ監視'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(combinator_library) */</span>
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-keyword">var</span> get = (key) =&gt; {
          <span class="hljs-keyword">return</span> (obj) =&gt; {
            <span class="hljs-keyword">return</span> obj[key];
          };
        };
        <span class="hljs-keyword">var</span> isEqual = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n2 === n1;
          };
        };
        <span class="hljs-keyword">var</span> isLessThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &gt; n2;
          };
        };
        <span class="hljs-keyword">var</span> isMoreThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &lt; n2;
          };
        };
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
          <span class="hljs-keyword">return</span> (data) =&gt; {
            <span class="hljs-keyword">return</span> ! predicate(data);
          }
        };
        <span class="hljs-keyword">var</span> within = (lower) =&gt; {
          <span class="hljs-keyword">return</span> (upper) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">return</span> (extractor) =&gt; {
                <span class="hljs-keyword">return</span> and(extractor, isMoreThan(lower))(extractor, isLessThan(upper))(data);
              };
            };
          };
        };
        <span class="hljs-keyword">var</span> and = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(! firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-keyword">var</span> or = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(combinator_library) */</span>
        <span class="hljs-comment">/* #@range_begin(combinator_library_test) */</span>
        <span class="hljs-keyword">var</span> data = {
          temp: <span class="hljs-number">24</span>,
          time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"2013/2/15 17:57:27"</span>)
        };
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> and(getTemp, isMoreThan(<span class="hljs-number">20</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> or(getTemp, isMoreThan(<span class="hljs-number">30</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(get(<span class="hljs-string">'temp'</span>)(data))(id)
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)(get(<span class="hljs-string">'temp'</span>))
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)((data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data)
          })
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        <span class="hljs-comment">/* #@range_end(combinator_library_test) */</span>
        next();
      });
    });
    it(<span class="hljs-string">'Y combinator'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
	  <span class="hljs-comment">/* #@range_begin(Y_combinator) */</span>
	  <span class="hljs-keyword">var</span> Y = (F) =&gt; {
	    <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g</span>) </span>{
		  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
		    <span class="hljs-keyword">return</span> F(g(g))(x);
		  };
	    })(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g</span>) </span>{
		  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
		    <span class="hljs-keyword">return</span> F(g(g))(x);
		  };
	    });
	  };
	  <span class="hljs-comment">/* #@range_end(Y_combinator)  */</span>
	  <span class="hljs-comment">/* #@range_begin(Y_combinator_test) */</span>
	  <span class="hljs-keyword">var</span> factorial = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fact</span>) </span>{
	    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
		  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
		    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		  } <span class="hljs-keyword">else</span> {
		    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);
		  }
	    };
	  };
 	  <span class="hljs-keyword">var</span> fact = Y(factorial);
	  expect(
	    fact(<span class="hljs-number">3</span>)
	  ).to.eql(
	    <span class="hljs-number">6</span>
	  );</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Y x = x(Y x)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	  <span class="hljs-comment">/* #@range_end(Y_combinator_test) */</span>
	  next();
    });
    
  }); <span class="hljs-comment">// コンビネータ</span>
  describe(<span class="hljs-string">'モナドを作る'</span>, () =&gt; {
    describe(<span class="hljs-string">'恒等モナド'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_monad) */</span>
      <span class="hljs-keyword">var</span> identity = {</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h2 id="identity-unit">identity#unit</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> value;
        },
        flatMap: (instance) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> transform(instance);
          };
        }
      };
      <span class="hljs-comment">/* #@range_end(identity_monad) */</span>
      it(<span class="hljs-string">"identity#flatMap"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(identity_monad_test) */</span>
        <span class="hljs-keyword">var</span> instance = identity.unit(<span class="hljs-number">1</span>);
        expect(
          identity.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> identity.unit(n * <span class="hljs-number">2</span>);
          })
        ).to.eql(
          identity.unit(<span class="hljs-number">2</span>)
        );
        expect(
          identity.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> identity.flatMap(identity.unit(n * <span class="hljs-number">2</span>))((m) =&gt; {
              <span class="hljs-keyword">return</span> identity.unit(m * <span class="hljs-number">3</span>);
            });
          })
        ).to.eql(
          identity.unit(<span class="hljs-number">6</span>)
        );
        expect(
          identity.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> identity.flatMap(identity.unit(n))((m) =&gt; {
              <span class="hljs-keyword">return</span> identity.unit(m * n);
            });
          })
        ).to.eql(
          identity.unit(<span class="hljs-number">1</span>)
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'Maybeモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> id = (any) =&gt; {
        <span class="hljs-keyword">return</span> any;
      };
      <span class="hljs-keyword">var</span> match = (exp, pattern) =&gt; {
        <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
      };
      it(<span class="hljs-string">'代数的データ型を作る'</span>)
      describe(<span class="hljs-string">'Maybeモナドを作る'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(maybe_monad) */</span>
        <span class="hljs-keyword">var</span> just = (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.just(value);
          };
        };
        <span class="hljs-keyword">var</span> nothing = ((_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.nothing(_);
          };
        })(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">var</span> unit = (value) =&gt; {
          <span class="hljs-keyword">if</span>(value){
            <span class="hljs-keyword">return</span> just(value);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> nothing(<span class="hljs-literal">null</span>);
          }
        };
        <span class="hljs-keyword">var</span> isEqual = (maybeA) =&gt; {
          <span class="hljs-keyword">return</span> (maybeB) =&gt; {
            <span class="hljs-keyword">return</span> match(maybeA,{
              just: (valueA) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (valueB) =&gt; {
                    <span class="hljs-keyword">return</span> (valueA === valueB);
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  }
                });
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                });
              }
            });
          };
        };
        <span class="hljs-keyword">var</span> map = (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> unit(transform(value));
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing;
              }
            });
          };
        };
        <span class="hljs-keyword">var</span> flatMap = (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> transform(value);
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing;
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(maybe_monad) */</span>
        it(<span class="hljs-string">"map id == id"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{
          <span class="hljs-comment">/* #@range_begin(maybe_monad_test) */</span>
          <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
          expect(
            isEqual(map(justOne)(id))(id(justOne))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          expect(
            isEqual(map(nothing)(id))(id(nothing))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-comment">/* #@range_end(maybe_monad_test) */</span>
          next();
        });
        it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(maybe_monad_add_test) */</span>
          <span class="hljs-keyword">var</span> add = (maybeA) =&gt; {
            <span class="hljs-keyword">return</span> (maybeB) =&gt; {
              <span class="hljs-keyword">return</span> flatMap(maybeA)((a) =&gt; {
                <span class="hljs-keyword">return</span> flatMap(maybeB)((b) =&gt; {
                  <span class="hljs-keyword">return</span> unit(a + b);
                });
              });
            };
          };
          <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">var</span> justTwo = just(<span class="hljs-number">2</span>);
          <span class="hljs-keyword">var</span> justThree = just(<span class="hljs-number">3</span>);
          expect(
            isEqual(add(justOne)(justTwo))(justThree)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          expect(
            isEqual(add(justOne)(nothing))(nothing)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-comment">/* #@range_end(maybe_monad_add_test) */</span>
          next();
        });
      });
    });
    describe(<span class="hljs-string">'Listモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> seq  = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> data(pattern);
        },
        compose: (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(g(arg));
          };
        },
        flip: (fun) =&gt; {
          <span class="hljs-keyword">return</span>  (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> fun(g)(f);
            };
          };
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        },
        head: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            },
          });
        },
        tail: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            },
          });
        },
        isEmpty: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> seq.match(list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
          });
        },
        toArray: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.foldr(list)([])(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> [item].concat(accumulator);</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>return accumulator.concat(item);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            };
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        concat: (xs) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (ys) =&gt; {
            <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
              <span class="hljs-keyword">return</span> ys;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
            }
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        join: (list_of_list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
            <span class="hljs-keyword">return</span> self.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.concat(seq.head(list_of_list))(self.join(seq.tail(list_of_list)));
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        foldr: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (glue) =&gt; {
              expect(glue).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">if</span>(self.isEmpty(list)){
                <span class="hljs-keyword">return</span> accumulator;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> item = self.head(list);
                <span class="hljs-keyword">var</span> tail = self.tail(list);
                <span class="hljs-keyword">return</span> glue(item)(self.foldr(tail)(accumulator)(glue));
              }
            };
          };
        },
        <span class="hljs-comment">/* #@range_begin(list_monad_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        map: (list) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> seq.match(list,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> self.empty;
              },
              cons: (x,xs) =&gt; {
                <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs)(transform));
              }
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>return self.foldr(list)(self.empty())(function (item){
   return (accumulator) =&gt; {
     return seq.match(list,{
       empty: (_) =&gt; {
         return accumulator;
       },
       cons: (x,xs) =&gt; {
         return transform();
       }
     });
   };
});
var glue = self.compose(self.cons.bind(self),transform.bind(self));
return self.foldr(list)(self.empty())(glue);
var glue = self.compose(self.cons.bind(self),transform.bind(self));
return self.foldr(list)(self.empty())(glue);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          };
        },
        <span class="hljs-comment">/* #@range_end(list_monad_map) */</span>
        <span class="hljs-comment">/* #@range_begin(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h3 id="list-unit">list#unit</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> self.cons(value, seq.empty());
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h3 id="monad-list-flatmap">monad.list#flatMap</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatMap: (instance) =&gt; {
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> self.join(self.map(instance)(transform.bind(self)));
          };
        }
        <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span>
      }; <span class="hljs-comment">// end of seq</span>
      it(<span class="hljs-string">"'list#empty'"</span>, (next) =&gt; {
        seq.match(seq.empty,{
          empty: (_) =&gt; {
            expect(<span class="hljs-literal">true</span>).ok();
          },
          cons: (x,xs) =&gt; {
            expect().fail()
          }
        });
        next();
      })
      it(<span class="hljs-string">"'list#isEmpty'"</span>, (next) =&gt; {
        expect(
          seq.isEmpty(seq.empty())
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          seq.isEmpty(seq.cons(<span class="hljs-number">1</span>,seq.empty()))
        ).to.eql(
          <span class="hljs-literal">false</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#cons'"</span>, (next) =&gt; {
        seq.match(seq.cons(<span class="hljs-number">1</span>,seq.empty()),{
          empty: (_) =&gt; {
            expect().fail()
          },
          cons: (x,xs) =&gt; {
            expect(x).to.eql(<span class="hljs-number">1</span>)
          }
        });
        next();
      });
      it(<span class="hljs-string">"'list#head'"</span>, (next) =&gt; {
        expect(
          seq.head(seq.cons(<span class="hljs-number">1</span>,seq.empty()))
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        next();
      })
      it(<span class="hljs-string">"'list#tail'"</span>, (next) =&gt; {
        expect(
          seq.head(seq.tail(seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.empty()))))
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        next();
      })
      it(<span class="hljs-string">"'list#concat'"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> list = seq.concat(seq.cons(<span class="hljs-number">1</span>,seq.empty()))(seq.cons(<span class="hljs-number">2</span>,seq.empty()));
        expect(
          seq.head(list)
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        expect(
          seq.head(seq.tail(list))
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          seq.isEmpty(seq.tail(seq.tail(list)))
        ).to.eql(
          <span class="hljs-literal">true</span>
        )
        next();
      });
      it(<span class="hljs-string">"'list#join'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>list = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list_of_list = seq.cons(seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.empty())),
                                    seq.cons(seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty())),
                                             seq.empty));</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>joined_list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> joined_list = seq.join(list_of_list)
        expect(
          seq.head(joined_list)
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        expect(
          seq.head(seq.tail(joined_list))
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          seq.isEmpty(seq.tail(seq.tail(joined_list)))
        ).to.eql(
          <span class="hljs-literal">false</span>
        )
        next();
      });
      it(<span class="hljs-string">"'list#foldr'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
        expect(
          seq.foldr(list)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> accumulator + item;
            };
          })
        ).to.eql(
          <span class="hljs-number">10</span>
        )
        next();
      })
      it(<span class="hljs-string">"'list#toArray'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
        expect(
          seq.toArray(list)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
        )
        next();
      })
      it(<span class="hljs-string">"'list#map'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
        expect(
          seq.toArray(seq.map(list)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          }))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
        )
        next();
      })
      it(<span class="hljs-string">"'list#unit'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list = seq.unit(<span class="hljs-number">1</span>);
        expect(
          seq.toArray(list)
        ).to.eql(
          [<span class="hljs-number">1</span>]
        )
        next();
      })
      it(<span class="hljs-string">"'list#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> list = seq.concat(seq.unit(<span class="hljs-number">1</span>))(seq.concat(seq.unit(<span class="hljs-number">2</span>))(seq.unit(<span class="hljs-number">3</span>)))
        expect(
          seq.toArray(seq.flatMap(list)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
            <span class="hljs-keyword">return</span> seq.concat(seq.unit(item))(seq.unit(- item));
          }))
        ).to.eql(
          [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
        );
        next();
      });
    });
    describe(<span class="hljs-string">'Streamモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
        <span class="hljs-keyword">return</span> data(pattern);
      };
      <span class="hljs-keyword">var</span> maybe = {
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.just(value);
          };
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.nothing(_);
          };
        },
        unit: (value) =&gt; {
          <span class="hljs-keyword">if</span>(value){
            <span class="hljs-keyword">return</span> self.maybe.just(value);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.maybe.nothing(<span class="hljs-literal">undefined</span>);
          }
        },
        get: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> match(maybe,{
            just: (value) =&gt; {
              <span class="hljs-keyword">return</span> value;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            }
          });
        },
        isEqual: (maybeA) =&gt; {
          <span class="hljs-keyword">return</span> (maybeB) =&gt; {
            <span class="hljs-keyword">return</span> match(maybeA,{
              just: (valueA) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (valueB) =&gt; {
                    <span class="hljs-keyword">return</span> (valueA === valueB);
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  }
                });
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                });
              }
            });
          };
        },
        map: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> unit(transform(value));
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing();
              }
            });
          };
        },
        flatMap: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> transform(value);
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing();
              }
            });
          };
        }
      }; <span class="hljs-comment">// end of maybe</span>
      <span class="hljs-comment">/* #@range_begin(stream_monad_definition) */</span>
      <span class="hljs-keyword">var</span> stream = {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (head,tailThunk) =&gt; {
          expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        head: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> maybe.nothing();
            },
            cons: (value, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> maybe.just(value);
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tail: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> maybe.nothing();
            },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> maybe.just(tailThunk());
            }
          });
        },
        isEmpty: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        toArray: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> [];
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">if</span>(stream.isEmpty(tailThunk())){
                <span class="hljs-keyword">return</span> [head];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
              }
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <h3 id="stream-unit">stream#unit</h3>
<p>unit:: ANY -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {
          <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
            <span class="hljs-keyword">return</span> stream.cons(value, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.empty();
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h3 id="stream-map">stream#map</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        map: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform)});
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h2 id="stream-append">stream#append</h2>
<p>append: (stream1, stream2) =&gt; {
  // var self = this;
  return match(stream1,{
    empty: (<em>) =&gt; {
      return stream2;
    },
    cons: (head1,tailThunk1) =&gt; {
      return match(stream2,{
        empty: (</em>) =&gt; {
          return stream1;
        },
        cons: (head2,tailThunk2) =&gt; {
          return stream.cons(head1,() =&gt; {
            return stream.append(tailThunk1(),stream2)});
        }
      });
    }
  });
},</p>
<h2 id="stream-concat">stream#concat</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        concat: (xs) =&gt; {
          <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
            <span class="hljs-keyword">return</span> match(xs,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> ysThunk();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.concat(tailThunk())(ysThunk);
                });
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatten: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> stream.concat(head)((_) =&gt; {
                <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
              });
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <h3 id="stream-flatmap">stream#flatMap</h3>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>
<p>flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatMap: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> stream.flatten(stream.map(lazyList)(transform));
          };
        }
      };
      <span class="hljs-comment">/* #@range_end(stream_monad_definition) */</span>
      it(<span class="hljs-string">"stream#unit"</span>, (next) =&gt; {
        match(maybe.nothing(<span class="hljs-literal">null</span>),{
          nothing: (_) =&gt; {
            <span class="hljs-keyword">return</span> expect(
              _
            ).to.eql(
              <span class="hljs-literal">null</span>
            )
          },
          just: (value) =&gt; {
            <span class="hljs-keyword">return</span> expect().fail()
          }
        });
        <span class="hljs-keyword">var</span> lazyList = stream.unit(<span class="hljs-number">1</span>);
        expect(
          maybe.get(stream.head(lazyList))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(stream.unit(<span class="hljs-number">1</span>)))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(stream.unit(<span class="hljs-number">0</span>)))
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        expect(
          maybe.get(stream.head(lazyList))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        expect(
          stream.tail(lazyList)
        ).to.a(<span class="hljs-string">"function"</span>);

        match(stream.tail(lazyList),{
          nothing: (_) =&gt; {
            expect().fail();
          },
          just: (tail) =&gt; {
            match(tail,{
              empty: (_) =&gt; {
                expect().fail();
              },
              cons: (head, tailThunk) =&gt; {
                expect(head).to.eql(<span class="hljs-number">2</span>);
              }
            });
          }
        });
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(lazyList))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#toArray"</span>, (next) =&gt; {
        expect(
          stream.toArray(stream.empty())
        ).to.eql(
          []
        );
        expect(
          stream.toArray(stream.unit(<span class="hljs-number">1</span>))
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        next();
      });
      it(<span class="hljs-string">"stream#concat"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> xs = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
        <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        };
        <span class="hljs-keyword">var</span> concatenatedStream = stream.concat(xs)(ysThunk);
        expect(
          maybe.get(stream.head(concatenatedStream))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(concatenatedStream))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#flatten"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>innerStream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> innerStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>outerStream = [[1,2]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> outerStream = stream.unit(innerStream);
        <span class="hljs-keyword">var</span> flattenedStream = stream.flatten(outerStream);
        match(flattenedStream,{
          empty: (_) =&gt; {
            expect().fail()
          },
          cons: (head,tailThunk) =&gt; {
            expect(head).to.eql(<span class="hljs-number">1</span>)
          }
        });
        expect(
          maybe.get(stream.head(flattenedStream))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(flattenedStream))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      describe(<span class="hljs-string">"stream#map"</span>, () =&gt; {
        it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> doubledLazyList = stream.map(lazyList)((item) =&gt; {
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(doubledLazyList))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledLazyList))))
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          expect(
            stream.toArray(doubledLazyList)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          next();
        });
        it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(ones_infinite_sequence) */</span>
          <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          expect(
            maybe.get(stream.head(ones))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(ones))))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-comment">/* #@range_end(ones_infinite_sequence) */</span>
          <span class="hljs-keyword">var</span> twoes = stream.map(ones)((item) =&gt; {
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(twoes))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(twoes))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(maybe.get(stream.tail(twoes))))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
              <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
            });
          };
          expect(
            maybe.get(stream.head(integersFrom(<span class="hljs-number">0</span>)))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> doubledIntergerMapped = stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
            <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(doubledIntergerMapped))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledIntergerMapped))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> doubledInterger = stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
            <span class="hljs-keyword">return</span> stream.unit(integer * <span class="hljs-number">2</span>);
          });
          expect(
            maybe.get(stream.head(doubledInterger))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledInterger))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          <span class="hljs-keyword">var</span> twoes = stream.flatMap(ones)((one) =&gt; {
            expect(one).to.a(<span class="hljs-string">'number'</span>);
            <span class="hljs-keyword">return</span> stream.unit(one * <span class="hljs-number">2</span>);
          });
          expect(
            maybe.get(stream.head(twoes))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {
          <span class="hljs-comment">/*
            scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))
            scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))
            res0: List[Int] = List(2, 4, 6, 8)
          */</span>
          <span class="hljs-keyword">var</span> innerStream12 = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> innerStream34 = stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>nestedStream = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> nestedStream = stream.cons(innerStream12, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(innerStream34,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> flattenedStream = stream.flatMap(nestedStream)((innerStream) =&gt; {
            <span class="hljs-keyword">return</span> stream.flatMap(innerStream)((n) =&gt; {
              expect(n).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">return</span> stream.unit(n * <span class="hljs-number">2</span>);
            });
          });
          expect(
            maybe.get(stream.head(flattenedStream))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            stream.toArray(flattenedStream)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
          );
          next();
        });

      });
    }); <span class="hljs-comment">// streamモナド</span>
  }); <span class="hljs-comment">// モナド</span>
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
