<!DOCTYPE html>

<html>
<head>
  <title>chap07.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap07.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> truthy = (any) =&gt; {
  <span class="hljs-keyword">return</span> any !== <span class="hljs-literal">false</span> &amp;&amp; any != <span class="hljs-literal">null</span>;
};


<span class="hljs-keyword">var</span> identity = (any) =&gt; {
  <span class="hljs-keyword">return</span> any;
};


<span class="hljs-keyword">var</span> double = (number) =&gt; {
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
};


<span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
  <span class="hljs-keyword">return</span> (arg) =&gt; {
    <span class="hljs-keyword">return</span> f(g(arg));
  };
};
<span class="hljs-keyword">var</span> pipe = (fun) =&gt; {
  expect(fun).to.a(<span class="hljs-string">'function'</span>);
  <span class="hljs-keyword">return</span> flip(compose)(fun);
};


<span class="hljs-keyword">var</span> flip = (fun) =&gt; {
  <span class="hljs-keyword">return</span>  (f) =&gt; {
    <span class="hljs-keyword">return</span> (g) =&gt; {
      <span class="hljs-keyword">return</span> fun(g)(f);
    };
  };
};

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data.call(pattern, pattern);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>return data(pattern);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1 id="-string-module">‘string’ module</h1>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/* #@range_begin(string_module) */</span>
<span class="hljs-keyword">var</span> string = {
  head: (str) =&gt; {
    expect(str).to.a(<span class="hljs-string">'string'</span>);
    <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>];
  },
  tail: (str) =&gt; {
    expect(str).to.a(<span class="hljs-string">'string'</span>);
    <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">1</span>);
  },
  isEmpty: (str) =&gt; {
    <span class="hljs-keyword">return</span> str.length === <span class="hljs-number">0</span>;
  },
  toArray: (str) =&gt; {
    expect(str).to.a(<span class="hljs-string">'string'</span>);
    <span class="hljs-keyword">var</span> glue = (item) =&gt; {
      <span class="hljs-keyword">return</span> (rest) =&gt; {
        <span class="hljs-keyword">return</span> [item].concat(rest);
      };
    };
    <span class="hljs-keyword">if</span>(string.isEmpty(str)) {
      <span class="hljs-keyword">return</span> [];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> [string.head(str)].concat(string.toArray(string.tail(str)));
    }
  }
};
<span class="hljs-comment">/* #@range_end(string_module) */</span>

it(<span class="hljs-string">'stringのテスト'</span>, (next) =&gt; {
  expect(
    string.head(<span class="hljs-string">"abc"</span>)
  ).to.eql(
    <span class="hljs-string">'a'</span>
  );
  expect(
    string.tail(<span class="hljs-string">"abc"</span>)
  ).to.eql(
    <span class="hljs-string">'bc'</span>
  );
  expect(
    string.toArray(<span class="hljs-string">"abc"</span>)
  ).to.eql(
    [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]
  );
  next();
});

<span class="hljs-keyword">var</span> list  = {
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(list, pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
append [] ys = ys
append (x:xs) ys = x : (xs ++ ys)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(head, list.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>list#concat
concat:: LIST[LIST[T]] -&gt; LIST[T]
concat [] = []
concat (xs:xss) = append(xs, xss)
or,
concat xss = foldr xss [] append</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xss) =&gt; {
    <span class="hljs-keyword">return</span> match(xss,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> list.empty();
      },
      cons: (xs,xss) =&gt; {
        <span class="hljs-keyword">return</span> list.append(xs,xss);
      }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>return list.foldr(list_of_list)(list.empty())(list.append);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>concat: (xs) =&gt; {
  var self = this;
  return (ys) =&gt; {
    if(list.isEmpty(xs)){
      return ys;
    } else {
      return list.cons(list.head(xs),(list.concat(list.tail(xs))(ys)));
    }
  };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  last: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> match(tail, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> head;
          },
          cons: (head, _) =&gt; {
            <span class="hljs-keyword">return</span> list.last(tail);
          }
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>join:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  join: (list_of_list) =&gt; {
    <span class="hljs-keyword">return</span> list.concat(list_of_list);</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>var self = this;
if(self.isEmpty(list_of_list)){
  return list.empty();
} else {
  return list.concat(list.head(list_of_list))(list.join(list.tail(list_of_list)));
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> match(alist,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));
          }
        });
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> match(alist,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> list.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(transform(head),list.map(tail)(transform));
        }
      });
    };
  },
  <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
  reverse: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> reverseAux = (alist, accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(alist, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> reverseAux(tail, list.cons(head, accumulator));
        }
      });
    };
    <span class="hljs-keyword">return</span> reverseAux(alist, list.empty());
  },
  <span class="hljs-comment">/* #@range_end(list_reverse) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="list-filter">list.filter</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
  filter: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      <span class="hljs-keyword">return</span> match(alist,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> list.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">if</span>(predicate(head)){
            <span class="hljs-keyword">return</span> list.cons(head,(_) =&gt; {
              <span class="hljs-keyword">return</span> list.filter(tail)(predicate);
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> list.filter(tail)(predicate);
          }
        }
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>return (predicate) =&gt; {
  expect(predicate).to.a(‘function’);
  var filterAux = (alist, accumulator) =&gt; {
    return match(alist,{
      empty: (_) =&gt; {
        return accumulator;
      },
      cons: (head,tail) =&gt; {
        if(predicate(head) === true){
          return list.concat(list.concat(accumulator)(list.cons(head, list.empty())))(filterAux(tail, accumulator));
        } else  {
          return filterAux(tail, accumulator);
        }
      }
    });
  };
  return filterAux(alist, list.empty());
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>list#length</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  length: (alist) =&gt; {
    <span class="hljs-keyword">return</span> match(alist,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },
      cons: (head,tail) =&gt; {
        <span class="hljs-keyword">return</span> list.foldr(alist)(<span class="hljs-number">0</span>)((item) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + accumulator;
          };
        });
      }
    });
  },
  any: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      expect(predicate).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> match(alist,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">if</span>(truthy(predicate(head))) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> list.any(tail)(predicate);
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>return compose(self.list.or.bind(self))(self.flip.bind(self)(self.list.map.bind(self))(predicate))(list);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
  },
  <span class="hljs-comment">/* #@range_end(list_filter) */</span>
  toArray: (alist) =&gt; {
    <span class="hljs-keyword">var</span> toArrayAux = (alist,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> match(alist, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayAux(alist, []);
  },
  fromArray: (array) =&gt; {
    expect(array).to.an(<span class="hljs-string">'array'</span>);
    <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
      <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item, list.empty()));
    }, list.empty());
  },
  <span class="hljs-comment">/* #@range_begin(list_fromString) */</span>
  fromString: (str) =&gt; {
    expect(str).to.a(<span class="hljs-string">'string'</span>);
    <span class="hljs-keyword">if</span>(string.isEmpty(str)) {
      <span class="hljs-keyword">return</span> list.empty();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> list.cons(string.head(str), list.fromString(string.tail(str)));
    }
  },
  <span class="hljs-comment">/* #@range_end(list_fromString) */</span>
  at: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (index) =&gt; {
      expect(index).to.a(<span class="hljs-string">'number'</span>);
      expect(index).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> list.head(alist);
      } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> list.at(list.tail(alist))(index - <span class="hljs-number">1</span>);
      }
    };
  },
  take: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (n) =&gt; {
      expect(n).to.a(<span class="hljs-string">'number'</span>);
      expect(n).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> list.empty();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> list.cons(list.head)(list.take(list.tail)(n-<span class="hljs-number">1</span>));
      }
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2 id="list-drop">list#drop</h2>
<p>drop :: List =&gt; List</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  drop: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    self.list.censor(list);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
      expect(n).to.be.a(<span class="hljs-string">'number'</span>);
      expect(n).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> list;
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span>(self.list.isEmpty.bind(self)(list))
          <span class="hljs-keyword">return</span> self.list.empty;
        <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> tail = list.tail;
          <span class="hljs-keyword">return</span> self.list.drop.bind(self)(tail)(n-<span class="hljs-number">1</span>);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>if (n === 0)
  return list;
else {
  if(self.list.isEmpty(list))
 return [];
  else {
 var tail = list.tail();
 return self.list.drop.bind(self)(tail)(n-1);
  }
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
  },
  <span class="hljs-comment">/* #@range_begin(list_generate) */</span>
  generate: (alist) =&gt; {
    <span class="hljs-keyword">var</span> theList = alist;
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">return</span> match(theList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
        },
        cons: (head,tail) =&gt; {
          theList = tail;
          <span class="hljs-keyword">return</span> head;
        }
      });
    };
  }
  <span class="hljs-comment">/* #@range_end(list_generate) */</span>
};

it(<span class="hljs-string">'listのテスト'</span>, (next) =&gt; {
  <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,
                           list.cons(<span class="hljs-number">2</span>,
                                     list.cons(<span class="hljs-number">3</span>,
                                               list.cons(<span class="hljs-number">4</span>,
                                                         list.empty()))));
  expect(
    list.length(sequence)
  ).to.eql(
    <span class="hljs-number">4</span>
  );
  expect(
    list.head(sequence)
  ).to.eql(
    <span class="hljs-number">1</span>
  );
  expect(
    list.toArray(sequence)
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
  );
  expect(
    list.toArray(list.reverse(sequence))
  ).to.eql(
    [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
  );
  expect(
    list.head(list.reverse(sequence))
  ).to.eql(
    <span class="hljs-number">4</span>
  );

  expect(
    list.last(sequence)
  ).to.eql(
    <span class="hljs-number">4</span>
  );</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>init = reverse . tail . reverse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> init = (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> compose(list.reverse,
                   compose(list.tail,list.reverse))(alist);
  };
  <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
  expect(
    list.toArray(init(seq))
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
  );</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>expect(
  list.toArray(list.fromArray([1,2,3]))
).to.eql(
  [1,2]
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  expect(
    list.toArray(list.fromString(<span class="hljs-string">"abc"</span>))
  ).to.eql(
    [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]
  );
  expect(
    list.at(seq)(<span class="hljs-number">0</span>)
  ).to.eql(
    <span class="hljs-number">1</span>
  );
  expect(
    list.at(seq)(<span class="hljs-number">1</span>)
  ).to.eql(
    <span class="hljs-number">2</span>
  );
  next();
});



<span class="hljs-keyword">var</span> stream = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(stream, pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> value;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> tailThunk();
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h2 id="stream-map">stream#map</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h2 id="stream-concat">stream#concat</h2>
<p>concat:: STREAM[STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (astream) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> match(astream,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> stream.append(head,tailThunk());
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (astream) =&gt; {
    <span class="hljs-keyword">return</span> list.concat(astream);
  },
  toArray: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> [];
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> match(tailThunk(),{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> [head];
          },
          cons: (head_,tailThunk_) =&gt; {
            <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
          }
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h3 id="stream-fromarray">stream#fromArray</h3>
<p>fromArray: (array) =&gt; {
  return array.reduce((accumulator, item) =&gt; {
    return stream.concat(accumulator)(stream.cons(item, (_) =&gt; {
      return stream.empty();
    }));
  });
},</p>
<h3 id="stream-take">stream#take</h3>
<p>take:: STREAM -&gt; NUMBER -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  take: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (number) =&gt; {
      expect(number).to.a(<span class="hljs-string">'number'</span>);
      expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> stream.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.take(tailThunk())(number -<span class="hljs-number">1</span>);
            });
          }
        }
      });
    };
  },
  filter: (astream) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      <span class="hljs-keyword">return</span> stream.match(astream,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">if</span>(predicate(head)){
            <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.filter(tailThunk())(predicate);
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.filter(tailThunk())(predicate);
          }
        }
      });
    };
  },
  foldr: (astream) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> match(astream,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(stream.foldr(tailThunk())(accumulator)(glue));
          }
        });
      };
    };
  },
  integersFrom: (from) =&gt; {
    <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.integersFrom(from + <span class="hljs-number">1</span>);
    });
  },
  <span class="hljs-comment">/* #@range_begin(stream_generate) */</span>
  generate: (astream) =&gt; {
    <span class="hljs-keyword">var</span> theStream = astream;
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">return</span> match(theStream,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
        },
        cons: (head,tailThunk) =&gt; {
          theStream = tailThunk();
          <span class="hljs-keyword">return</span> head;
        }
      });
    };
  },
  <span class="hljs-comment">/* #@range_end(stream_generate) */</span>
  forAll: (astream) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      <span class="hljs-keyword">var</span> forAllHelper = (astream) =&gt; { <span class="hljs-comment">// 補助関数</span>
        <span class="hljs-keyword">return</span> match(astream,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> predicate(head) &amp;&amp; forAllHelper(tailThunk());
          }
        });
      };
      <span class="hljs-keyword">return</span> match(astream,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 空のストリームの場合は、必ず false が返る</span>
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> forAllHelper(astream);   
        }
      });
    };
  },
  <span class="hljs-comment">/* #@range_begin(stream_forEach) */</span>
  forEach: (astream) =&gt; {
    <span class="hljs-keyword">return</span> (callback) =&gt; {
      <span class="hljs-keyword">return</span> match(astream,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
        },
        cons: (head,tailThunk) =&gt; {
          callback(head);
          <span class="hljs-keyword">return</span> stream.forEach(tailThunk())(callback);
        }
      });
    };
  }
  <span class="hljs-comment">/* #@range_end(stream_forEach) */</span>

}; <span class="hljs-comment">// end of 'stream' module</span>

describe(<span class="hljs-string">'streamのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">'stream#map'</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    <span class="hljs-keyword">var</span> doubled_stream = stream.map(lazyList)((item) =&gt; {
      <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
    });
    expect(
      stream.head(doubled_stream)
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      stream.head(stream.tail(doubled_stream))
    ).to.eql(
      <span class="hljs-number">4</span>
    );
    next();
  });
  it(<span class="hljs-string">'stream#forAll'</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> evens = stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    
    expect(
      stream.forAll(evens)((n) =&gt; { <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>; })
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-keyword">var</span> integers = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });

    expect(
      stream.forAll(integers)((n) =&gt; { <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>; })
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
});

<span class="hljs-keyword">var</span> maybe = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data(pattern);</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>return data.call(pattern,pattern);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },
  just : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.just(value);
    };
  },
  nothing : (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.nothing(_);
    };
  },
  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> maybe.just(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>if(value){
  return maybe.just(value);
} else {
  return maybe.nothing(null);
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },
  flatMap : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.nothing(_);
        }
      });
    };
  },
  isEqual : (maybeA) =&gt; {
    <span class="hljs-keyword">return</span> (maybeB) =&gt; {
      <span class="hljs-keyword">return</span> maybe.match(maybeA,{
        just: (valueA) =&gt; {
          <span class="hljs-keyword">return</span> maybe.match(maybeB,{
            just: (valueB) =&gt; {
              <span class="hljs-keyword">return</span> (valueA === valueB);
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.match(maybeB,{
            just: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });
        }
      });
    };
  },
  map : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> maybe.unit(transform(value));
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.nothing(_);
        }
      });
    };
  }
};

<span class="hljs-keyword">var</span> pair = {
  cons: (left, right) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(left, right);
    };
  },
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(pair, pattern);
  },
  right: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> right;
      }
    });
  },
  left: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> left;
      }
    });
  }
};

<span class="hljs-keyword">var</span> object = {
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  },
  get: (key, obj) =&gt; {
    expect(obj).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> obj(key);
  },
  set: (key, value, obj) =&gt; {
    <span class="hljs-keyword">return</span> (key2) =&gt; {
      <span class="hljs-keyword">if</span>(key === key2) {
        <span class="hljs-keyword">return</span> value;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> object.get(key2,obj);
      }
    };
  }
};

describe(<span class="hljs-string">'高階関数'</span>, () =&gt; {
  describe(<span class="hljs-string">'カリー化'</span>, () =&gt; {
    it(<span class="hljs-string">'カリー化されていない指数関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(exponential_uncurried) */</span>
      <span class="hljs-keyword">var</span> exponential = (base,index) =&gt; {
        <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> base * exponential(base,index - <span class="hljs-number">1</span>);
        }
      };
      expect(
        exponential(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// 2 * 2 = 4</span>
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      expect(
        exponential(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">// 2 * 2 * 2 = 8</span>
      ).to.eql(
        <span class="hljs-number">8</span>
      );
      <span class="hljs-comment">/* #@range_end(exponential_uncurried) */</span>
      next();
    });
    it(<span class="hljs-string">'カリー化された指数関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(exponential_curried) */</span>
      <span class="hljs-keyword">var</span> exponential = (base) =&gt; {
        <span class="hljs-keyword">return</span> (index) =&gt; {
          <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> base * exponential(base)(index - <span class="hljs-number">1</span>);
          }
        };
      };
      <span class="hljs-comment">/****** テスト ******/</span>
      expect(
        exponential(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2の3乗を求める </span>
      ).to.eql(
        <span class="hljs-number">8</span>
      );
      <span class="hljs-comment">/* #@range_end(exponential_curried) */</span>
      expect(
        exponential(<span class="hljs-number">2</span>)(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      <span class="hljs-comment">/* #@range_begin(flip) */</span>
      <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
        <span class="hljs-keyword">return</span>  (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> fun(y)(x);
          };
        };
      };
      <span class="hljs-comment">/* #@range_end(flip) */</span>
      <span class="hljs-comment">/* #@range_begin(flipped_exponential) */</span>
      <span class="hljs-keyword">var</span> square = flip(exponential)(<span class="hljs-number">2</span>); <span class="hljs-comment">// flipで引数を逆転させて、2乗を定義する</span>
      <span class="hljs-keyword">var</span> cube = flip(exponential)(<span class="hljs-number">3</span>);   <span class="hljs-comment">// flipで引数を逆転させて、3乗を定義する</span>
      <span class="hljs-comment">/* #@range_end(flipped_exponential) */</span>
      <span class="hljs-comment">/* #@range_begin(flipped_exponential_test) */</span>
      expect(
        square(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">4</span> <span class="hljs-comment">// 2 * 2 = 4</span>
      );
      expect(
        cube(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">8</span> <span class="hljs-comment">// 2 * 2 * 2 = 8</span>
      );
      <span class="hljs-comment">/* #@range_end(flipped_exponential_test) */</span>
      next();
    });
    it(<span class="hljs-string">'カリー化された関数の単純な例'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(simple_curried_function) */</span>
      <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>) </span>{
        <span class="hljs-keyword">return</span> x + y ;
      };
      <span class="hljs-keyword">var</span> addCurried =  (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> x + y ;
        };
      };
      expect(
        add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
      ).to.eql(
        addCurried(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
      );
      <span class="hljs-comment">/* #@range_end(simple_curried_function) */</span>
      next();
    });
    it(<span class="hljs-string">'カリー化されていない multipleOf関数'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(multipleOf_uncurried) */</span>
      <span class="hljs-keyword">var</span> multipleOf = (n,m) =&gt; {
        <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      expect(
        multipleOf(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        multipleOf(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      <span class="hljs-comment">/* #@range_end(multipleOf_uncurried) */</span>
      next();
    });
    it(<span class="hljs-string">'カリー化による関数の部品化'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(multipleOf_curried) */</span>
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; { <span class="hljs-comment">// 外側の関数定義</span>
        <span class="hljs-keyword">return</span> (m) =&gt; {         <span class="hljs-comment">// 内側の関数定義</span>
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_end(multipleOf_curried) */</span>
      <span class="hljs-comment">/* #@range_begin(multipleOf_curried_test) */</span>
      <span class="hljs-keyword">var</span> twoFold = multipleOf(<span class="hljs-number">2</span>);
      <span class="hljs-keyword">var</span> threeFold = multipleOf(<span class="hljs-number">3</span>);
      expect(
        twoFold(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        threeFold(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(multipleOf_curried_test) */</span>
      next();
    });
    describe(<span class="hljs-string">'高階関数によるベクトル演算'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> mkVector =  (alist) =&gt; {
        <span class="hljs-keyword">return</span> (index) =&gt; {
          <span class="hljs-keyword">return</span> list.at(alist)(index);
        };
      };
      <span class="hljs-keyword">var</span> zero = mkVector(list.cons(<span class="hljs-number">0</span>, list.cons(<span class="hljs-number">0</span>, list.empty())));
      <span class="hljs-keyword">var</span> add = (vs) =&gt; {
        <span class="hljs-keyword">return</span> (ws) =&gt; {
          <span class="hljs-keyword">return</span> (index) =&gt; {
            <span class="hljs-keyword">return</span> vs(index) + ws(index);
          };
        };
      };
      <span class="hljs-keyword">var</span> innerProduct = (vs) =&gt; {
        <span class="hljs-keyword">return</span> (ws) =&gt; {
          <span class="hljs-keyword">var</span> product = (index) =&gt; {
            <span class="hljs-keyword">return</span> vs(index) * ws(index);
          };
          <span class="hljs-keyword">var</span> innerProductHelper = (indexes, accumulator) =&gt; {
            <span class="hljs-keyword">var</span> index = stream.head(indexes);
            <span class="hljs-keyword">if</span>(truthy(vs(index)) &amp;&amp; truthy(ws(index))) {
              <span class="hljs-keyword">return</span> innerProductHelper(stream.tail(indexes), accumulator + product(index));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> accumulator;
            }
          };
          <span class="hljs-keyword">var</span> naturals = stream.integersFrom(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">return</span> innerProductHelper(naturals, <span class="hljs-number">0</span>);
        };
      };
      it(<span class="hljs-string">'ベクトルの内積を innerProduct で計算する'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> vs = mkVector(list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">0</span>, list.empty())));
        <span class="hljs-keyword">var</span> ws = mkVector(list.cons(<span class="hljs-number">0</span>, list.cons(<span class="hljs-number">1</span>, list.empty())));
        expect(
          innerProduct(vs)(ws)
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        expect(
          innerProduct(mkVector(list.cons(-<span class="hljs-number">1</span>, list.cons(-<span class="hljs-number">2</span>, 
                                                         list.cons(<span class="hljs-number">1</span>,
                                                                   list.empty())))))(
            mkVector(list.cons(<span class="hljs-number">1</span>, list.cons(-<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.empty()))))
          )
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        next();
      });
    });
    describe(<span class="hljs-string">'通常の関数とカリー化関数の相互変換'</span>, () =&gt; {
      it(<span class="hljs-string">'通常の関数をカリー化する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(curry_function_definition) */</span>
        <span class="hljs-comment">/* カリー化する関数 */</span>
        <span class="hljs-keyword">var</span> curry = (fun) =&gt; {
          <span class="hljs-keyword">return</span> (x,optionalY) =&gt; {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>){ <span class="hljs-comment">// 引数が2個以上の場合</span>
              <span class="hljs-keyword">return</span> fun(x, optionalY);
            } <span class="hljs-keyword">else</span> {                  <span class="hljs-comment">// 引数が1個の場合</span>
              <span class="hljs-keyword">return</span> (y) =&gt;  {
                <span class="hljs-keyword">return</span> fun(x, y);
              };
            }
          };
        };
        <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x + y;
        };
        expect(
          curry(add)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)  <span class="hljs-comment">// add関数がカリー化されている</span>
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(curry_function_definition) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化を通常の関数に変換する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(uncurry_function_definition) */</span>
        <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = fun;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
              result = result(<span class="hljs-built_in">arguments</span>[i]);
            <span class="hljs-keyword">return</span> result;
          };
        };
        <span class="hljs-keyword">var</span> addCurried = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
        };
        <span class="hljs-keyword">var</span> add = uncurry(addCurried);
        expect(
          add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(uncurry_function_definition) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'関数合成'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(compose_definition) */</span>
      <span class="hljs-keyword">var</span> compose = (f) =&gt; {
        <span class="hljs-keyword">return</span> (g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt;{
            <span class="hljs-keyword">return</span> f(g(arg));
          };
        };
      };
      <span class="hljs-comment">/* #@range_end(compose_definition) */</span>
      <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
        <span class="hljs-keyword">return</span>  (f) =&gt; {
          <span class="hljs-keyword">return</span> (g) =&gt; {
            <span class="hljs-keyword">return</span> fun(g)(f);
          };
        };
      };

      <span class="hljs-comment">/* #@range_begin(compose_test) */</span>
      <span class="hljs-keyword">var</span> f = (x) =&gt; {
        <span class="hljs-keyword">return</span> x * x + <span class="hljs-number">1</span>; 
      };
      <span class="hljs-keyword">var</span> g = (x) =&gt; {
        <span class="hljs-keyword">return</span> x - <span class="hljs-number">2</span>;
      };
      <span class="hljs-keyword">var</span> fg = compose(f)(g); <span class="hljs-comment">// f . g で合成された関数</span>
      
      expect(
       fg(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2^2  -4 * 2 + 5 </span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(compose_test) */</span>
      <span class="hljs-keyword">var</span> subtract = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">return</span> n - m;
        };
      };
      expect(
        subtract(<span class="hljs-number">2</span>)(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        subtract(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
      ).to.eql(
        -<span class="hljs-number">1</span>
      );
      it(<span class="hljs-string">'pipe関数で適用の順番を逆転する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(pipe_definition) */</span>
        <span class="hljs-keyword">var</span> pipe = (fun) =&gt; {
          <span class="hljs-keyword">return</span> flip(compose)(fun);
        };
        <span class="hljs-comment">/* #@range_end(pipe_definition) */</span>
        <span class="hljs-comment">/* #@range_begin(pipe_test) */</span>
        <span class="hljs-keyword">var</span> gf = pipe(g)(f);
        
        expect(
          gf(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2^2  -4 * 2 + 5 </span>
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(pipe_test) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化の合成で加算と反数の合成は成功する'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_opposite_add_successful) */</span>
        <span class="hljs-keyword">var</span> opposite = (x) =&gt; {
          <span class="hljs-keyword">return</span> - x;
        };
        <span class="hljs-keyword">var</span> addCurried = (x) =&gt; { <span class="hljs-comment">// カリー化されたadd関数</span>
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
        };
        expect(
          compose(opposite)(addCurried(<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)
        ).to.eql(
            -<span class="hljs-number">5</span>
        );
        <span class="hljs-comment">/* #@range_end(compose_opposite_add_successful) */</span>
        next();
      });
      describe(<span class="hljs-string">'カリー化による関数の合成'</span>, () =&gt; {
        it(<span class="hljs-string">'カリー化と関数合成'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (_) =&gt; {
                <span class="hljs-keyword">return</span> f(g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
              };
            };
          };
          <span class="hljs-keyword">var</span> curry = (fun) =&gt; {
            <span class="hljs-keyword">return</span> (x,optionalY) =&gt; {
              <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>){
                <span class="hljs-keyword">return</span> fun(x, optionalY);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>return fun.call(this, x,optionalY);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> (y) =&gt;  {
                  <span class="hljs-keyword">return</span> fun(x, y);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>return fun.call(this, x,y);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                };
              }
            };
          };
          <span class="hljs-comment">/* #@range_begin(compose_and_curry) */</span>
          <span class="hljs-keyword">var</span> opposite = (x) =&gt; {
            <span class="hljs-keyword">return</span> -x;
          };
          <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
          expect(
            compose(opposite)(curry(add)(<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)
          ).to.eql(
              -<span class="hljs-number">5</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_and_curry) */</span>
          next();
        });
        it(<span class="hljs-string">'脱カリー化と関数合成'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_and_uncurry) */</span>
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (_) =&gt; {
                <span class="hljs-keyword">return</span> f(g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
              };
            };
          };
          <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
            <span class="hljs-keyword">return</span> () =&gt; {
              <span class="hljs-keyword">var</span> result = fun;
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
                result = result(<span class="hljs-built_in">arguments</span>[i]);
              <span class="hljs-keyword">return</span> result;
            };
          };
          <span class="hljs-keyword">var</span> opposite = (x) =&gt; {
            <span class="hljs-keyword">return</span> -x;
          };
          <span class="hljs-keyword">var</span> multiply = (x) =&gt; {
            <span class="hljs-keyword">return</span> (y) =&gt; {
              <span class="hljs-keyword">return</span> x * y;
            };
          };
          expect(
            compose(opposite)(uncurry(multiply))(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
          ).to.eql(
              -<span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_and_uncurry) */</span>
          next();
        });
        it(<span class="hljs-string">'マイナスのマイナスはプラス'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(composition_example_opposite_twice) */</span>
          <span class="hljs-keyword">var</span> opposite = (n) =&gt; { <span class="hljs-comment">// 反数の定義</span>
            <span class="hljs-keyword">return</span> - n;
          };
          expect(
            compose(opposite)(opposite)(<span class="hljs-number">2</span>) <span class="hljs-comment">// 反数同士の合成は成功します</span>
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(composition_example_opposite_twice) */</span>
          next();
        });
      });
      it(<span class="hljs-string">"1個の引数の関数を合成する"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> decrement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> double = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n;
        };
        expect(
          compose(increment)(decrement)(<span class="hljs-number">5</span>)
        ).to.eql(
          <span class="hljs-number">5</span>
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>expect(<strong>.compose.bind(</strong>)(decrement)(increment)(5)).to.be(5);
expect(<strong>.compose.bind(</strong>)(increment)(increment)(5)).to.be(7);
// (n <em> 2) + 1
expect(<strong>.compose.bind(</strong>)(increment)(double)(5)).to.be(11);
// (n + 1) </em> 2
expect(<strong>.compose.bind(</strong>)(double)(increment)(5)).to.be(12);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      describe(<span class="hljs-string">"pipe関数による合成"</span>, () =&gt; {
        it(<span class="hljs-string">"composeでlastを定義する"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt; {
                <span class="hljs-keyword">return</span> f.call(self,
                              g.call(self,arg));
              };
            };
          };
          <span class="hljs-keyword">var</span> last = (alist) =&gt; {
            <span class="hljs-keyword">return</span> compose(list.head)(list.reverse)(alist);
          };
          <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          next();
        });
        it(<span class="hljs-string">"pipeでlastを定義する"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt; {
                <span class="hljs-keyword">return</span> f.call(self,
                              g.call(self,arg));
              };
            };
          };
          <span class="hljs-comment">/* #@range_begin(last_with_pipe) */</span>
          <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span>  (f) =&gt; {
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> fun.call(self, g)(f); <span class="hljs-comment">// return fun(g)(f);</span>
              };
            };
          };
          <span class="hljs-keyword">var</span> pipe = (fun) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            expect(fun).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> flip.call(self,
                             compose)(fun);
          };
          <span class="hljs-keyword">var</span> last = (alist) =&gt; {
            <span class="hljs-keyword">return</span> pipe(list.reverse)(list.head)(alist);
          };
          <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(last_with_pipe) */</span>
          next();
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>it(“‘compose two argument functions’”, function(next) {
  var negate = function(x) {
    return -x;
  };
  var multiply = function(x,y){
    return x * y;
  };
  expect((<strong>.compose.bind(</strong>)(negate)(multiply))(2,3)).to.eql(-6);
  next();
});
it(“compose several functions”, function(next) {
  var not = function(x){
    return ! x;
  };
  expect(
    <strong>.compose.bind(</strong>)(not)(math.isEqual(3))(3)
  ).to.eql(
      false
  );
  // expect(
  //   <strong>.compose.bind(</strong>)(__.not)(math.isEqual(3))(3)
  // ).to.eql(
  //  false
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'再帰によるlast'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_recursive) */</span>
        <span class="hljs-keyword">var</span> last = (alist) =&gt; {
          <span class="hljs-keyword">return</span> match(alist, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> match(tail, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> head;
                },
                cons: (head, _) =&gt; {
                  <span class="hljs-keyword">return</span> last(tail);
                }
              });
            }
          });
        };
        <span class="hljs-comment">/* #@range_end(list_last_recursive) */</span>
        <span class="hljs-comment">/* #@range_begin(list_last_test) */</span>
        <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
        expect(
          last(numbers)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(list_last_test) */</span>
        next();
      });
      it(<span class="hljs-string">'合成によるlast'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_compose) */</span>
        <span class="hljs-keyword">var</span> last = (alist) =&gt; {
          <span class="hljs-keyword">return</span> compose(list.head)(list.reverse)(alist);
        };
        <span class="hljs-comment">/* #@range_end(list_last_compose) */</span>
        <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
        expect(
          last(sequence)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        next();
      });
      it(<span class="hljs-string">'length関数の抽象的な定義'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> alwaysOne = (x) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> sum = (alist) =&gt; {
          <span class="hljs-keyword">var</span> sumHelper = (alist, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> match(alist,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> sumHelper(tail, accumulator + head);
              }
            });
          };
          <span class="hljs-keyword">return</span> sumHelper(alist,<span class="hljs-number">0</span>);
        };
        <span class="hljs-comment">/* #@range_begin(abstract_length) */</span>
        <span class="hljs-keyword">var</span> length = (alist) =&gt; {
          <span class="hljs-keyword">return</span> compose(sum)(flip(list.map)(alwaysOne))(alist);
        };
        <span class="hljs-comment">/****** テスト *******/</span>
        <span class="hljs-keyword">var</span> alist = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
        expect(
          length(alist)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(abstract_length) */</span>
        next();
      });
      it(<span class="hljs-string">'init関数の抽象的な定義'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(abstract_init) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>init = reverse . tail . reverse </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> init = (alist) =&gt; {
          <span class="hljs-keyword">return</span> compose(list.reverse)(compose(list.tail)(list.reverse))(alist);
        };
        <span class="hljs-comment">/****** テスト *******/</span>
        <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
        expect(
          list.toArray(init(sequence))
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        );
        <span class="hljs-comment">/* #@range_end(abstract_init) */</span>
        next();
      });
    }); <span class="hljs-comment">// 関数合成のカリー化</span>
    it(<span class="hljs-string">'リストの逆順を求める'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> list = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data.call(list, pattern);
        },
        empty: (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty;
        },
        cons: (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        },
        isEmpty: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
            empty: <span class="hljs-literal">true</span>,
            cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        head: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            }
          });
        },
        tail: (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            }
          });
        }
      };
      <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
      <span class="hljs-keyword">var</span> reverse = (alist) =&gt; {
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist, {
            empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> reverse(tail)(list.cons(head, accumulator));
            }
          });
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>toArray:: LIST -&gt; ARRAY -&gt; ARRAY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> toArray = (alist) =&gt; {
        <span class="hljs-keyword">var</span> toArrayAux = (alist) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> toArrayAux(tail)(accumulator.concat(head));
              }
            });
          };
        };
        <span class="hljs-keyword">return</span> toArrayAux(alist)([]);
      };
      <span class="hljs-comment">/**************** テスト ****************/</span>
      expect(
        toArray(reverse(list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.empty)))(list.empty))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
      );
      <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
      next();
    });
  });
  describe(<span class="hljs-string">'クロージャーの仕組み'</span>, () =&gt; {
    it(<span class="hljs-string">'環境と変数のバインディング'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(variable_binding_in_environment) */</span>
      <span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>; <span class="hljs-comment">// 変数fooに数値1をバインドする</span>
      <span class="hljs-keyword">var</span> bar = <span class="hljs-string">"a string"</span>; <span class="hljs-comment">// 変数bar に文字列 "a string" をバインドする</span>
      <span class="hljs-comment">/* #@range_end(variable_binding_in_environment) */</span>
      <span class="hljs-comment">/* #@range_begin(variable_binding_in_environment_test) */</span>
      expect(
        foo  <span class="hljs-comment">// 環境から変数fooの値を取り出す</span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(variable_binding_in_environment_test) */</span>
      next();
    });
    it(<span class="hljs-string">'部分適用と環境'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; { <span class="hljs-comment">// 外側の関数定義</span>
        <span class="hljs-keyword">return</span> (m) =&gt; {         <span class="hljs-comment">// 内側の関数定義</span>
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_begin(partial_application_with_environment) */</span>
      <span class="hljs-keyword">var</span> twoFold = multipleOf(<span class="hljs-number">2</span>);
      expect(
       twoFold(<span class="hljs-number">4</span>) 
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(partial_application_with_environment) */</span>
      next();
    });
  });
  describe(<span class="hljs-string">'クロージャーで状態をカプセル化する'</span>, () =&gt; {
    describe(<span class="hljs-string">'単純なクロージャーの例'</span>, (next) =&gt; {
      it(<span class="hljs-string">'counter関数の例'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(counter_as_closure) */</span>
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> countingNumber =  init - <span class="hljs-number">1</span>;
          <span class="hljs-keyword">return</span> (_) =&gt; {  <span class="hljs-comment">// countingNumberの環境を持つクロージャーを返す</span>
            countingNumber = countingNumber + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> countingNumber ;
          };
        };
        <span class="hljs-comment">/* #@range_end(counter_as_closure) */</span>
        <span class="hljs-comment">/* #@range_begin(counter_as_closure_test) */</span>
        <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
        expect(
          counterFromZero()
        ).to.eql( 
          <span class="hljs-number">0</span>
        );
        expect(
          counterFromZero()
        ).to.eql( 
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(counter_as_closure_test) */</span>
        <span class="hljs-comment">/* #@range_begin(another_counter) */</span>
        <span class="hljs-keyword">var</span> anoterCounterFromZero = counter(<span class="hljs-number">0</span>);
        expect(
          anoterCounterFromZero()
        ).to.eql( 
          <span class="hljs-number">0</span>
        );
        <span class="hljs-comment">/* #@range_end(another_counter) */</span>
        next();
      });
      it(<span class="hljs-string">'counter関数における、外側のスコープからのクロージャーによる自由変数の捕捉'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> _init = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> counter = (_) =&gt; {  <span class="hljs-comment">// クロージャーを返す</span>
          _init = _init + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">return</span> _init;
        };
        expect(
          counter()
        ).to.eql( 
          <span class="hljs-number">1</span>
        );
        _init = <span class="hljs-number">100</span>;
        expect(
          counter()
        ).to.eql( 
          <span class="hljs-number">101</span>
        );
        next();
      });
      it(<span class="hljs-string">'関数の外側にあるスコープによる自由変数の捕捉'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> sleep = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sleep-async'</span>)();
        <span class="hljs-comment">/* #@range_begin(captures_free_variable_outside_function) */</span>
        <span class="hljs-keyword">var</span> startUpTime = <span class="hljs-built_in">Date</span>.now();
        
        <span class="hljs-keyword">var</span> application = {
          timeLapse: () =&gt; {
            <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();
            <span class="hljs-keyword">return</span> now - startUpTime; <span class="hljs-comment">// 外側のスコープにある startUpTime変数を捕捉している</span>
          }
        };
        <span class="hljs-comment">/* #@range_end(captures_free_variable_outside_function) */</span>
        sleep.sleep(<span class="hljs-number">5000</span>, () =&gt; {
          expect(
            application.timeLapse()
          ).to.be.greaterThan(
            <span class="hljs-number">1</span>
          );
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>var loopUntil = (predicateThunk) =&gt; {
  return (bodyThunk) =&gt; {
    if(predicateThunk() === true){
      bodyThunk();
      return loopUntil(predicateThunk)(bodyThunk);
    } else {
      return undefined;
    }
  };
};
var i = 3;
var result = 0;
var largerThanZero = (<em>) =&gt; {
  return i &gt; 0;
};
loopUntil(largerThanZero)((</em>) =&gt; {
  result = result + 1;
  i = i - 1;
});
expect(
  result
).to.eql(
  3
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
    });
    describe(<span class="hljs-string">'関数とデータの類似性'</span>, (next) =&gt; {
      it(<span class="hljs-string">'チャーチ数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(church_numeral) */</span>
        <span class="hljs-keyword">var</span> zero = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> x;
          };
        };
        <span class="hljs-keyword">var</span> one = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(x); <span class="hljs-comment">// 関数を1回適用する</span>
          };
        };
        <span class="hljs-keyword">var</span> two = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(x)); <span class="hljs-comment">// 関数を2回適用する</span>
          };
        };
        <span class="hljs-keyword">var</span> three = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(f(x)));  <span class="hljs-comment">// 関数を3回適用する</span>
          };
        };
        <span class="hljs-keyword">var</span> add = (m) =&gt; {
          <span class="hljs-keyword">return</span> (n) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> (x) =&gt; {
                <span class="hljs-keyword">return</span> m(f)(n(f)(x));
              };
            };
          };
        };
        <span class="hljs-comment">/*#@range_end(church_numeral) */</span>
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(n(f)(x));
            };
          };
        };
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> _init = init;
          <span class="hljs-keyword">return</span> (dummy) =&gt; {
            _init = _init + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> _init;
          };
        };
        expect(one(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">1</span>);
        expect(two(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
        expect(three(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
        expect(succ(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
        expect(succ(two)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
        expect(add(zero)(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">1</span>);
        expect(add(one)(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
        expect(add(one)(two)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
        expect(add(two)(three)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">5</span>);
        next();
      });
      it(<span class="hljs-string">'関数とリストの類似性'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        };
        <span class="hljs-keyword">var</span> empty = (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty;
        };
        <span class="hljs-keyword">var</span> cons = (value, list) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, list);
          };
        };
        <span class="hljs-keyword">var</span> isEmpty = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
            empty: <span class="hljs-literal">true</span>,
            cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
          });
        };
        <span class="hljs-keyword">var</span> head = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            },
          });
        };
        <span class="hljs-keyword">var</span> tail = (list) =&gt; {
          <span class="hljs-keyword">return</span> match(list, {
            empty: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            },
          });
        };
        <span class="hljs-comment">/*
          ~~~haskell
          list2fct :: Eq a =&gt; [(a,b)] -&gt; a -&gt; b
          list2fct [] _ = error "function not total"
          list2fct ((u,v):uvs) x | x == u = v
          | otherwise = list2fct uvs x
          fct2list :: (a -&gt; b) -&gt; [a] -&gt; [(a,b)]
          fct2list f xs = [ (x, f x) | x &lt;- xs ]
          ~~~
        */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>var list2function = (list) =&gt; {
   return (any) =&gt; {
     if(head(list)) {
       if(head(list) === any){
         return
       } else {
       }
   } else {
   }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      describe(<span class="hljs-string">'クロージャーによる「環境」の実装'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(environment_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h2 id="-">空の環境</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> emptyEnv = (variable) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        };
        <span class="hljs-comment">/* 変数名に対応する値を環境から取りだす */</span>
        <span class="hljs-keyword">var</span> lookupEnv = (identifier, env) =&gt; {
          <span class="hljs-keyword">return</span> env(identifier);
        };
        <span class="hljs-comment">/* 環境を拡張する */</span>
        <span class="hljs-keyword">var</span> extendEnv = (identifier, value, env) =&gt; {
          <span class="hljs-keyword">return</span> (queryIdentifier) =&gt; {
            <span class="hljs-keyword">if</span>(identifier === queryIdentifier) {
              <span class="hljs-keyword">return</span> value;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> lookupEnv(queryIdentifier,env);
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(environment_in_closure) */</span>
        it(<span class="hljs-string">'extendEnvで環境を作り、 lookupEnv で環境を探る'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(environment_in_closure_test) */</span>
          expect(
            lookupEnv(<span class="hljs-string">"a"</span>, emptyEnv)
          ).to.be(
            <span class="hljs-literal">null</span>
          );
          <span class="hljs-keyword">var</span> newEnv = extendEnv(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>, emptyEnv);
          expect(
            lookupEnv(<span class="hljs-string">"a"</span>, newEnv)
          ).to.be(
            <span class="hljs-number">1</span>
          );
          expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>var a = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> firstEnv = extendEnv(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>var b = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> secondEnv = extendEnv(<span class="hljs-string">"b"</span>,<span class="hljs-number">3</span>, firstEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>辞書から b の値を参照する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"b"</span>,secondEnv);
          })()).to.eql(
            <span class="hljs-number">3</span>
          );
          expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>var x = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> xEnv = extendEnv(<span class="hljs-string">"x"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>var z = 2 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> zEnv = extendEnv(<span class="hljs-string">"z"</span>, <span class="hljs-number">2</span>, xEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>内部のスコープで var x = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> xEnvInner = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">3</span>, zEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>内部のスコープで var y = 4 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> innerMostEnv = extendEnv(<span class="hljs-string">"y"</span>,<span class="hljs-number">4</span>, xEnvInner);</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>一番内側のスコープを利用して x + y + z を計算する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"x"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"y"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"z"</span>,innerMostEnv) ;
          })()).to.eql(
            <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(environment_in_closure_test) */</span>
          next();
        });
      });
    });
    it(<span class="hljs-string">'クロージャーの変数バインディング'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(free_variable_in_closure) */</span>
      <span class="hljs-keyword">var</span> outerFunction = (outerArgument) =&gt; {
        <span class="hljs-keyword">var</span> innerFunction = (innerArgument) =&gt; {
          <span class="hljs-keyword">return</span> outerArgument + innerArgument;
        };
        <span class="hljs-keyword">return</span> innerFunction;
      };
      <span class="hljs-comment">/* #@range_end(free_variable_in_closure) */</span>
      next();
    });
    describe(<span class="hljs-string">'クロージャーと参照透過性'</span>, () =&gt; {
      it(<span class="hljs-string">'multipleOf関数は参照透過である'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          };
        };
        <span class="hljs-comment">/* #@range_begin(multipleOf_is_transparent) */</span>
        expect(
          multipleOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
        ).to.eql(
          multipleOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
        );
        expect(
          multipleOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
        ).to.eql(
          multipleOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
        );
        <span class="hljs-comment">/* #@range_end(multipleOf_is_transparent) */</span>
        next();
      });
      it(<span class="hljs-string">'参照透過でないクロジャーの例'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> _init = init;
          <span class="hljs-keyword">return</span> (_) =&gt; {
            _init = _init + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> _init;
          };
        };
        <span class="hljs-comment">/* #@range_begin(counter_is_not_transparent) */</span>
        <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
        expect(
          counterFromZero()
        ).not.to.eql( <span class="hljs-comment">// notで一致しないことをテストしている</span>
          counterFromZero()
        );
        <span class="hljs-comment">/* #@range_end(counter_is_not_transparent) */</span>
        next();
      });
      it(<span class="hljs-string">'参照透過でないクロジャーの利用法'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>チャーチ数 church numeral</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> zero = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> x;
          };
        };
        <span class="hljs-keyword">var</span> one = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(x);
          };
        };
        <span class="hljs-keyword">var</span> two = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(x));
          };
        };
        <span class="hljs-keyword">var</span> three = (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(f(f(x)));
          };
        };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(n(f)(x));
            };
          };
        };
        <span class="hljs-keyword">var</span> add = (m) =&gt; {
          <span class="hljs-keyword">return</span> (n) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> (x) =&gt;{
                <span class="hljs-keyword">return</span> m(f)(n(f)(x));
              };
            };
          };
        };
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> _init = init;
          <span class="hljs-keyword">return</span> (_) =&gt; {
            _init = _init + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> _init;
          };
        };
        <span class="hljs-comment">/* #@range_begin(church_numeral_test) */</span>
        expect(
          one(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          two(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          add(one)(two)(counter(<span class="hljs-number">0</span>))()
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(church_numeral_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'不変なデータ型を作る'</span>, () =&gt; {
      it(<span class="hljs-string">'オブジェクト型は不変ではない'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(object_is_not_immutable) */</span>
        <span class="hljs-keyword">var</span> object = {
          a: <span class="hljs-number">1</span>
        };
        expect(
          object.a
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        object.a = <span class="hljs-number">2</span>;
        expect(
          object.a
        ).to.eql(
          <span class="hljs-number">2</span> <span class="hljs-comment">// 1だった値が2に変更されています</span>
        );
        <span class="hljs-comment">/* #@range_end(object_is_not_immutable) */</span>
        next();
      });
      it(<span class="hljs-string">'不変なオブジェクト型を作る'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>var objects = {
  empty: {
  },
  set: (key,value,obj) =&gt; {
    expect(obj).to.an(‘object’);
    obj[key] = value;
    return obj;
  },
  get: (key,obj) =&gt; {
    expect(obj).to.an(‘object’);
    return obj[key];
  },
  isEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for(var key in obj){
      if(hasOwnProperty.call(obj, key))
        return false;
    }
  },
  isNotEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    return ! this.objects.isEmpty(obj);
  },
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(immutable_object_type) */</span>
        <span class="hljs-keyword">var</span> object = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          },
          get: (key, obj) =&gt; {
            <span class="hljs-keyword">return</span> obj(key);
          },
          set: (key, value, obj) =&gt; {
            <span class="hljs-keyword">return</span> (key2) =&gt; {
              <span class="hljs-keyword">if</span>(key === key2) {
                <span class="hljs-keyword">return</span> value;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> object.get(key2,obj);
              }
            };
          }
        };
        <span class="hljs-comment">/* #@range_end(immutable_object_type) */</span>
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_test) */</span>
        expect(
          object.get(<span class="hljs-string">"R2D2"</span>, 
                      object.set(<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, 
                                  object.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,
                                              object.empty)))
        ).to.eql(
          <span class="hljs-string">"Star Wars"</span>
        );
        expect(
          object.get(<span class="hljs-string">"R2D2"</span>, 
                      object.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,
                                          object.empty))
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        expect(
          object.get(<span class="hljs-string">"HAL9000"</span>, 
                      object.set(<span class="hljs-string">"C3PO"</span>, <span class="hljs-string">"Star Wars"</span>, 
                                  object.set(<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, 
                                              object.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,
                                                          object.empty))))
        ).to.eql(
          <span class="hljs-string">"2001: a space odessay"</span>
        );
        <span class="hljs-comment">/* #@range_end(immutable_object_type_test) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化された不変なオブジェクト型'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_curried) */</span>
        <span class="hljs-keyword">var</span> object = {  <span class="hljs-comment">// objectモジュール</span>
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          },
          set: (key, value) =&gt; {
            <span class="hljs-keyword">return</span> (obj) =&gt; {
              <span class="hljs-keyword">return</span> (queryKey) =&gt; {
                <span class="hljs-keyword">if</span>(key === queryKey) {
                  <span class="hljs-keyword">return</span> value;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> object.get(queryKey)(obj);
                }
              };
            };
          },
          get: (key) =&gt; {
            <span class="hljs-keyword">return</span> (obj) =&gt; {
              <span class="hljs-keyword">return</span> obj(key);
            };
          }
        };
        <span class="hljs-comment">/* #@range_end(immutable_object_type_curried) */</span>
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_curried_test) */</span>
        <span class="hljs-keyword">var</span> robots = compose(object.set(<span class="hljs-string">"C3PO"</span>, <span class="hljs-string">"Star Wars"</span>),
                             object.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>))(object.empty);
         expect(
           object.get(<span class="hljs-string">"HAL9000"</span>)(robots)
         ).to.eql(
           <span class="hljs-string">"2001: a space odessay"</span>
         );
        <span class="hljs-comment">/* #@range_end(immutable_object_type_curried_test) */</span>
        next();
      });
      it(<span class="hljs-string">'不変なオブジェクト型を作る(改良版)'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved) */</span>
        <span class="hljs-keyword">var</span> objects = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          },
          get: (key, obj) =&gt; {
            <span class="hljs-keyword">return</span> obj(key);
          },
          set: (key, value, obj) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (key2) =&gt; {
              <span class="hljs-keyword">if</span>(key === key2) {
                <span class="hljs-keyword">return</span> value;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.get(key2,obj)
              }
            };
          },
          fromObject: (obj) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">var</span> keys = (o) =&gt; {
              <span class="hljs-keyword">var</span> result = [];
              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> o) {
                <span class="hljs-keyword">if</span>(o.hasOwnProperty(prop))
                  result.push(prop);
              }
              <span class="hljs-keyword">return</span> result;
            };
            <span class="hljs-keyword">return</span> keys(obj).reduce((accumulator, key) =&gt; {
              <span class="hljs-keyword">return</span> self.set.call(self,key, obj[key], accumulator);
            }, self.empty);
          }
        };
        <span class="hljs-comment">/* #@range_end(immutable_object_type_improved) */</span>
        <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved_test) */</span>
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        expect(
          objects.get(<span class="hljs-string">"HAL9000"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
        ).to.eql(
          <span class="hljs-string">"2001: a space odessay"</span>
        );
        expect(
          objects.get(<span class="hljs-string">"R2D2"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
        ).to.eql(
          <span class="hljs-string">"Star Wars"</span>
        );
        <span class="hljs-comment">/* #@range_end(immutable_object_type_improved_test) */</span>
        next();
      });
      it(<span class="hljs-string">'不変なリスト型'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(immutable_list) */</span>
        <span class="hljs-keyword">var</span> list = {
          empty: (index) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          },
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> f(head,tail);
            };
          },
          head: (array) =&gt; {
            <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            });
          },
          tail: (array) =&gt; {
            <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            });
          },
          at: (index,array) =&gt; {
            <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head(array);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.at(index -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.tail(array));
            }
          }
        };
        <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty)));
        expect(
          list.head(theList)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          list.head(list.tail(theList))
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          list.at(<span class="hljs-number">0</span>,theList)
        ).to.eql(
          <span class="hljs-number">1</span>
        )
        expect(
          list.at(<span class="hljs-number">1</span>,theList)
        ).to.eql(
          <span class="hljs-number">2</span>
        )
        expect(
          list.at(<span class="hljs-number">2</span>,theList)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(immutable_list) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>it(‘不変な配列型’, (next) =&gt; {
  var arrays = {
    empty: [],
    cons: (any,array) =&gt; {
      expect(array).to.an(‘array’);
      return [any].concat(array);
    },
    head: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return ary[0];
    },
    tail: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      expect(self.isNonEmpty(ary)).to.be.ok();
      return ary.slice(1,ary.length);
    },
    get: (index,ary) =&gt; {
      expect(index).to.be.a(‘number’);
      expect(ary).to.an(‘array’);
      return ary[index];
    },
    isEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.equal.call(self,ary.length)(0);
    },
    isNotEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.not.call(self,self.arrays.isEmpty(ary));
    }
  };
  expect(
    arrays.cons(1,arrays.empty)
  ).to.eql(
    [1]
  )
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'代数的ストリーム型'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(algebraic_stream) */</span>
        <span class="hljs-keyword">var</span> empty = (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.empty(_);
          };
        };
        <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
          expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (value, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> value;
            }
          });
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> tailThunk();
            }
          });
        };
        <span class="hljs-keyword">var</span> isEmpty = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head1,tailThunk1) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        };
        <span class="hljs-comment">/* #@range_end(algebraic_stream) */</span>
        <span class="hljs-comment">/* #@range_begin(algebraic_stream_helpers) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> toArray = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> [];
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> match(tailThunk(),{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> [head];
                },
                cons: (head_,tailThunk_) =&gt; {
                  <span class="hljs-keyword">return</span> [head].concat(toArray(tailThunk()));
                }
              });
            }
          });
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h3 id="stream-take">stream#take</h3>
<p>take:: STREAM -&gt; NUMBER -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> take = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (number) =&gt; {
            expect(number).to.a(<span class="hljs-string">'number'</span>);
            expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> empty();
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> cons(head,(_) =&gt; {
                    <span class="hljs-keyword">return</span> take(tailThunk())(number -<span class="hljs-number">1</span>);
                  });
                }
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(algebraic_stream_helpers) */</span>
        it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>stream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            tail(stream)
          ).to.a(<span class="hljs-string">"function"</span>);
          expect(
            head(tail(stream))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        describe(<span class="hljs-string">"無限ストリーム"</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(infinite_stream) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>ones = [1,1,1,1,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> ones = cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          expect(
            head(ones)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            head(tail(ones))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-comment">/* #@range_end(infinite_stream) */</span>
          <span class="hljs-comment">/* #@range_begin(infinite_integer) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>ones = [1,2,3,4,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> integersFrom = (n) =&gt; {
            <span class="hljs-keyword">return</span> cons(n, (_) =&gt; {
              <span class="hljs-keyword">return</span> integersFrom(n + <span class="hljs-number">1</span>);
            });
          };
          it(<span class="hljs-string">"無限の整数列をテストする"</span>, (next) =&gt; {
            expect(
              head(integersFrom(<span class="hljs-number">1</span>))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(
              head(tail(integersFrom(<span class="hljs-number">1</span>)))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              toArray(take(integersFrom(<span class="hljs-number">1</span>))(<span class="hljs-number">10</span>))
            ).to.eql(
              [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> ] 
            );
            <span class="hljs-comment">/* #@range_end(infinite_integer) */</span>
            next();
          });
          it(<span class="hljs-string">"filterで無限の偶数列を作る"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> even = (n) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
            };
            <span class="hljs-comment">/* #@range_begin(infinite_even_integer) */</span>
            <span class="hljs-keyword">var</span> evenIntegers = stream.filter(integersFrom(<span class="hljs-number">1</span>))(even);
            expect(
              head(evenIntegers)
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              toArray(stream.take(evenIntegers)(<span class="hljs-number">4</span>))
            ).to.eql(
              [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span> ]
            );
            <span class="hljs-comment">/* #@range_end(infinite_even_integer) */</span>
            next();
          });
          it(<span class="hljs-string">"filterで無限の素数列を作る"</span>, (next) =&gt; {
            <span class="hljs-keyword">this</span>.timeout(<span class="hljs-number">7000</span>);
            <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
              <span class="hljs-keyword">return</span> (m) =&gt; {
                <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              };
            };
            <span class="hljs-comment">/* #@range_begin(infinite_primes) */</span>
            <span class="hljs-keyword">var</span> leastDivisor = (n) =&gt; {
              expect(n).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">var</span> leastDivisorHelper = (k, n) =&gt; {
                expect(k).to.a(<span class="hljs-string">'number'</span>);
                expect(n).to.a(<span class="hljs-string">'number'</span>);
                <span class="hljs-keyword">if</span>(multipleOf(k)(n)) {
                  <span class="hljs-keyword">return</span> k;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">if</span>(n &lt; (k * k)) {
                    <span class="hljs-keyword">return</span> n;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> leastDivisorHelper(k+<span class="hljs-number">1</span>, n);
                  }
                };
              };
              <span class="hljs-keyword">return</span> leastDivisorHelper(<span class="hljs-number">2</span>,n);
            };
            <span class="hljs-keyword">var</span> isPrime = (n) =&gt; {
              <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"argument not positive"</span>);
              }
              <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> leastDivisor(n)  === n ;
              }
            };
            
            <span class="hljs-keyword">var</span> primes = stream.filter(integersFrom(<span class="hljs-number">1</span>))(isPrime);
            expect(
              toArray(stream.take(primes)(<span class="hljs-number">10</span>))
            ).to.eql(
              [ <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span> ]
            );
            <span class="hljs-comment">/* #@range_end(infinite_primes) */</span>
            next();
          });
        });
        it(<span class="hljs-string">"代数的ストリーム型は不変ではない"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> object = head(stream);
          object.key = <span class="hljs-number">2</span>;
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
          );
          next();
        });
      });
      describe(<span class="hljs-string">'不変なストリーム型'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(immutable_stream) */</span>
        <span class="hljs-keyword">var</span> empty = (index) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };
        <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> f(head,tailThunk);
          };
        };
        <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> head;
          });
        };
        <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> tailThunk();
          });
        };
        <span class="hljs-comment">/* #@range_end(immutable_stream) */</span>
        it(<span class="hljs-string">"関数的ストリーム型は不変である"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
            <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> empty();
            });
          });
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> object = head(stream);
          object.key = <span class="hljs-number">2</span>;
          expect(
            head(stream).key
          ).to.eql(
            <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
          );
          next();
        });
      });
    });
    describe(<span class="hljs-string">'クロージャーでジェネレーターを作る'</span>, () =&gt; {
      it(<span class="hljs-string">'ECMAScript6 generator'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(es6_generator) */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genCounter</span>(<span class="hljs-params"></span>)</span>{
          <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
          <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
        };
        <span class="hljs-keyword">var</span> counter = genCounter();
        expect(
          counter.next().value
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          counter.next().value
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(es6_generator) */</span>
        next();
      });
      it(<span class="hljs-string">'リスト・ジェレネータ'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_generator_test) */</span>
        <span class="hljs-keyword">var</span> generator = list.generate(list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>, list.empty())));
        expect(
          generator()
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          generator()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(list_generator_test) */</span>
        next();
      });
      it(<span class="hljs-string">'ストリーム・ジェレネータ'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(stream_generator_test) */</span>
        <span class="hljs-keyword">var</span> generator = stream.generate(stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        }));
        expect(
          generator()
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          generator()
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(stream_generator_test) */</span>
        next();
      });
      describe(<span class="hljs-string">'streamからジェネレータを作る'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(generator_from_stream) */</span>
        <span class="hljs-keyword">var</span> generate = (astream) =&gt; {
          <span class="hljs-keyword">var</span> _stream = astream; <span class="hljs-comment">// いったんローカル変数にストリームを格納する</span>
          <span class="hljs-comment">/* ジェネレータ関数が返る */</span>
          <span class="hljs-keyword">return</span> () =&gt; {
            <span class="hljs-keyword">return</span> stream.match(_stream, {
              empty: () =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              },
              cons: (head, tailThunk) =&gt; {
                _stream = tailThunk();  <span class="hljs-comment">// ローカル変数を更新する</span>
                <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// ストリームの先頭要素を返す</span>
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(generator_from_stream) */</span>
        it(<span class="hljs-string">'整数列のジェネレータ'</span>,(next) =&gt; {
          <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
              <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
            });
          };
          <span class="hljs-comment">/* #@range_begin(integer_generator) */</span>
          <span class="hljs-keyword">var</span> integers = integersFrom(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">var</span> intGenerator = generate(integers);
          expect(
            intGenerator()
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            intGenerator()
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            intGenerator()
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(integer_generator) */</span>
          next();
        });
        it(<span class="hljs-string">'素数のジェネレータ'</span>,(next) =&gt; {
          <span class="hljs-keyword">this</span>.timeout(<span class="hljs-number">7000</span>);
          <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
            <span class="hljs-keyword">return</span> (m) =&gt; {
              <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            };
          };
          <span class="hljs-keyword">var</span> leastDivisor = (n) =&gt; {
            expect(n).to.a(<span class="hljs-string">'number'</span>);
            <span class="hljs-keyword">var</span> leastDivisorHelper = (k, n) =&gt; {
              expect(k).to.a(<span class="hljs-string">'number'</span>);
              expect(n).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">if</span>(multipleOf(k)(n)) {
                <span class="hljs-keyword">return</span> k;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span>(n &lt; (k * k)) {
                  <span class="hljs-keyword">return</span> n;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> leastDivisorHelper(k+<span class="hljs-number">1</span>, n);
                }
              };
            };
            <span class="hljs-keyword">return</span> leastDivisorHelper(<span class="hljs-number">2</span>,n);
          };
          <span class="hljs-keyword">var</span> isPrime = (n) =&gt; {
            <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"argument not positive"</span>);
            }
            <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> leastDivisor(n)  === n ;
            }
          };
          <span class="hljs-comment">/* #@range_begin(prime_generator) */</span>
          <span class="hljs-keyword">var</span> integers = stream.integersFrom(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">var</span> primes = stream.filter(integers)(isPrime); <span class="hljs-comment">// 素数のストリーム</span>
          <span class="hljs-keyword">var</span> primeGenerator = generate(primes);
          <span class="hljs-comment">/******* テスト ********/</span>
          expect(
            primeGenerator()
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            primeGenerator()
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          expect(
            primeGenerator()
          ).to.eql(
            <span class="hljs-number">5</span>
          );
          <span class="hljs-comment">/* #@range_end(prime_generator) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'ジェネレータ・コンビネータ'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> identity = (any) =&gt; { <span class="hljs-keyword">return</span> any; };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>; };
        <span class="hljs-comment">/* #@range_begin(generator_in_closure) */</span>
        <span class="hljs-keyword">var</span> generator = (init) =&gt; {
          <span class="hljs-keyword">return</span> (current) =&gt; {
            <span class="hljs-keyword">return</span> (step) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(current(init),
                                 (_) =&gt; { 
                                   <span class="hljs-keyword">return</span> generator(step(init))(current)(step);
                                 });
            };
          };
        };
        <span class="hljs-keyword">var</span> integers = generator(<span class="hljs-number">0</span>)(identity)(succ);
        it(<span class="hljs-string">'integers をテストする'</span>, (next) =&gt;{
          expect(
            stream.head(integers)
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            stream.head(stream.tail(integers))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            stream.head(stream.tail(stream.tail(integers)))
          ).to.eql(
            <span class="hljs-number">2</span>
          );

          <span class="hljs-comment">/* #@range_end(generator_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>describe(‘streamとgenerator’, () =&gt; {
  var integers = generator(0)(id)(succ);
  var double = (n) =&gt; {
    return n * 2;
  };
  var doubles = stream.map.call(stream,
                                integers, double);
  expect(
    stream.head(integers)
  ).to.eql(
    0
  );</p>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
        it(<span class="hljs-string">'ジェレネータによる単体テストの自動生成'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(generate_unit_tests) */</span>
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
          };
          <span class="hljs-keyword">var</span> evenIntegers = stream.filter(integers)(even);
          stream.forEach(stream.take(evenIntegers)(<span class="hljs-number">10</span>))((n) =&gt; {
            <span class="hljs-keyword">return</span> expect(
              even(n)
            ).to.eql(
              <span class="hljs-literal">true</span>
            );
          });
          <span class="hljs-comment">/* #@range_end(generate_unit_tests) */</span>
          next();
        });
      });
    });
  }); <span class="hljs-comment">// クロージャーで状態をカプセル化する</span>
  describe(<span class="hljs-string">'関数を渡す'</span>, () =&gt; {
    describe(<span class="hljs-string">'コールバックを渡す'</span>, () =&gt; {
      it(<span class="hljs-string">'直接コールする'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(direct_call) */</span>
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> doCall = (arg) =&gt; {
          <span class="hljs-keyword">return</span> succ(arg);  <span class="hljs-comment">// succ関数を直接呼び出す</span>
        };
        expect(
          doCall(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(direct_call) */</span>
        next();
      });
      it(<span class="hljs-string">'コールバックを呼び出す'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-comment">/* #@range_begin(call_callback) */</span>
        <span class="hljs-keyword">var</span> setupCallBack = (callback) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {  <span class="hljs-comment">// コールバック関数を実行する無名関数を返す</span>
            <span class="hljs-keyword">return</span> callback(arg);
          };
        };
        <span class="hljs-keyword">var</span> doCallBack = setupCallBack(succ);  <span class="hljs-comment">// コールバック関数を設定する</span>
        expect(
          doCallBack(<span class="hljs-number">2</span>) <span class="hljs-comment">// 設定されたコールバック関数を実行する</span>
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(call_callback) */</span>
        next();
      });
      it(<span class="hljs-string">'リストのmap'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>map :: LIST[T] =&gt; FUN[T =&gt; T] =&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> map = (alist,callback) =&gt; {
          <span class="hljs-keyword">return</span> match(alist,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> list.empty();
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> list.cons(callback(head),  <span class="hljs-comment">// コールバック関数を実行する</span>
                               map(tail,callback)); <span class="hljs-comment">// map関数の再帰呼び出し</span>
            }
          });
        };
        <span class="hljs-comment">/* #@range_end(list_map) */</span>
        <span class="hljs-comment">/* #@range_begin(list_map_test) */</span>
        <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,
                                list.cons(<span class="hljs-number">2</span>,
                                          list.empty()));
        <span class="hljs-keyword">var</span> doubledList = map(numbers,(n) =&gt; { <span class="hljs-comment">// 要素を2倍する関数を渡す</span>
          <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
        });
        expect(
          list.toArray(doubledList)
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
        );
        <span class="hljs-keyword">var</span> squareList = map(numbers,(n) =&gt; { <span class="hljs-comment">// 要素を2乗する関数を渡す</span>
          <span class="hljs-keyword">return</span> n * n;
        });
        expect(
          list.toArray(squareList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
        next();
      });
      describe(<span class="hljs-string">'イベント駆動'</span>, () =&gt; {
        it(<span class="hljs-string">'オブジェクトの値をイベント駆動で取得する'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> processEvent = (event) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> callback(event);
            };
          };
          <span class="hljs-keyword">var</span> anEvent = {<span class="hljs-string">"temperture"</span>: <span class="hljs-number">26.0</span>};
          expect(
            processEvent(anEvent)((theEvent) =&gt; {
              <span class="hljs-keyword">return</span> theEvent.temperture;
            })
          ).to.eql(
            <span class="hljs-number">26</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>var extract = (key) =&gt; {
  return (object) =&gt; {
 return object[key];
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> extractTemperture = (event) =&gt; {
            <span class="hljs-keyword">return</span> processEvent(event)((theEvent) =&gt; {
              <span class="hljs-keyword">return</span> theEvent.temperture;
            });
          };
          expect(
            extractTemperture(anEvent)
          ).to.eql(
            <span class="hljs-number">26</span>
          );
          next();
        });
        it(<span class="hljs-string">'イベント駆動システムを実装する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(event_driven_system) */</span>
          <span class="hljs-keyword">var</span> eventSystem = () =&gt; {
            <span class="hljs-keyword">var</span> handlers = object.empty(); <span class="hljs-comment">// イベントハンドラを格納する変数</span>
            <span class="hljs-keyword">return</span> {
              on: (eventName, callback) =&gt; {
                handlers = object.set(eventName, callback, handlers);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              },
              emit: (eventName, arg) =&gt; {
                <span class="hljs-keyword">return</span> object.get(eventName, handlers)(arg);  <span class="hljs-comment">// 該当するイベントハンドラを起動する</span>
              }
            };
          };
          <span class="hljs-comment">/* #@range_end(event_driven_system) */</span>
          <span class="hljs-keyword">var</span> eventLoop = (eventSystem) =&gt; {
            
          };
          <span class="hljs-comment">/* #@range_begin(event_driven_system_test) */</span>
          <span class="hljs-keyword">var</span> eventDrivenServer = eventSystem(); <span class="hljs-comment">// イベント駆動システムを初期化する</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>イベント started を登録する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          eventDrivenServer.on(<span class="hljs-string">"started"</span>, (_) =&gt; { <span class="hljs-comment">// startedイベントで実行されるコールバック関数を渡す</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">"event started"</span>;
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>イベント terminated を登録する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          eventDrivenServer.on(<span class="hljs-string">"terminated"</span>, (exitCode) =&gt; { <span class="hljs-comment">// terminatedイベントで実行されるコールバック関数 </span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">"event terminated with "</span> + exitCode;
          });
          <span class="hljs-comment">/**** テスト ****/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>イベント started を生じさせる</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            eventDrivenServer.emit(<span class="hljs-string">"started"</span>, <span class="hljs-literal">null</span>)
          ).to.eql(
            <span class="hljs-string">"event started"</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>イベント terminated を生じさせる</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            eventDrivenServer.emit(<span class="hljs-string">"terminated"</span>,<span class="hljs-number">404</span>)
          ).to.eql(
            <span class="hljs-string">"event terminated with 404"</span>
          );
          <span class="hljs-comment">/* #@range_end(event_driven_system_test) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'リストの再帰関数'</span>, () =&gt; {
        it(<span class="hljs-string">'リストの合計'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_sum) */</span>
          <span class="hljs-keyword">var</span> sum = (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> match(alist,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> sum(tail)(accumulator + head);
                }
              });
            };
          };
          <span class="hljs-keyword">var</span> numberList = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            sum(numberList)(<span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(list_sum) */</span>
          <span class="hljs-comment">/* #@range_begin(list_sum_callback) */</span>
          <span class="hljs-keyword">var</span> sumWithCallBack = (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (CALLBACK) =&gt; {   <span class="hljs-comment">// コールバック関数を受けとる</span>
                <span class="hljs-keyword">return</span> match(alist,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> sumWithCallBack(tail)(CALLBACK(head)(accumulator))(CALLBACK);
                  }
                });
              };
            };
          };
          <span class="hljs-comment">/* #@range_end(list_sum_callback) */</span>
          <span class="hljs-comment">/* #@range_begin(list_sum_callback_test) */</span>
          <span class="hljs-keyword">var</span> add = (n) =&gt; {  <span class="hljs-comment">// sumWithCallBack関数に渡すコールバック関数</span>
            <span class="hljs-keyword">return</span> (m) =&gt; {
              <span class="hljs-keyword">return</span> n + m;
            };
          };
          <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            sumWithCallBack(numbers)(<span class="hljs-number">0</span>)(add)
          ).to.eql(
            <span class="hljs-number">6</span>  <span class="hljs-comment">// 1 + 2 + 3 = 6</span>
          );
          <span class="hljs-comment">/* #@range_end(list_sum_callback_test) */</span>
          next();
        });
        it(<span class="hljs-string">'リストの長さ'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>/<em> #@range_begin(list_length) </em>/
var length = (alist) =&gt; {
  return (accumulator) =&gt; {
    return match(alist,{
       empty: (_) =&gt; {
        return accumulator;
      },
      cons: (head, tail) =&gt; {
        return length(tail)(accumulator + 1);
      }
    });
  };
};
var numberList = list.cons(1, list.cons(2,list.cons(3,list.empty())));
expect(
  length(numberList)(0)
).to.eql(
  3
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_end(list_length) */</span>
          <span class="hljs-comment">/* #@range_begin(list_length_callback) */</span>
          <span class="hljs-keyword">var</span> lengthWithCallBack = (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (CALLBACK) =&gt; {
                <span class="hljs-keyword">return</span> match(alist,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> lengthWithCallBack(tail)(CALLBACK(accumulator))(CALLBACK);
                  }
                });
              };
            };
          };
          <span class="hljs-comment">/* #@range_end(list_length_callback) */</span>
          <span class="hljs-comment">/* #@range_begin(list_length_callback_test) */</span>
          <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-comment">// lengthWithCallBack関数に渡すコールバック関数</span>
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            lengthWithCallBack(numbers)(<span class="hljs-number">0</span>)(succ)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(list_length_callback_test) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>it(‘リストの逆転’, (next) =&gt; {
  /<em> #@range_begin(list_reverse) </em>/
  var length = (alist) =&gt; {
 return (accumulator) =&gt; {
   return match(alist,{
     empty: (_) =&gt; {
       return accumulator;
     },
     cons: (head, tail) =&gt; {
       return length(tail)(accumulator + 1);
     }
   });
 };
  };
  var numberList = list.cons(1, list.cons(2,list.cons(3,list.empty())));
  expect(
 length(numberList)(0)
  ).to.eql(
 3
  );
  /<em> #@range_end(list_reverse) </em>/
  var lengthWithCallbak = (alist) =&gt; {
     return (accumulator) =&gt; {
       return (callback) =&gt; {
         return match(alist,{
           empty: (_) =&gt; {
             return accumulator;
           },
         cons: (head, tail) =&gt; {
           return lengthWithCallbak(tail)(callback(accumulator))(callback);
         }
         });
       };
     };
  };
  var add = (n) =&gt; {
     return (m) =&gt; {
       return n + m;
     };
  };
  expect(
     lengthWithCallbak(numberList)(0)(add(1))
  ).to.eql(
     3
  );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      });
      it(<span class="hljs-string">'ストリームのmap'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(stream_map) */</span>
        <span class="hljs-keyword">var</span> map = (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (callback) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              },
              cons: (head, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(callback(head), (_) =&gt; {
                  <span class="hljs-keyword">return</span> map(tailThunk())(callback);
                });
              }
            });
          };
        };
        <span class="hljs-comment">/* #@range_end(stream_map) */</span>
        <span class="hljs-comment">/* #@range_begin(stream_map_test) */</span>
        <span class="hljs-keyword">var</span> numberStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        <span class="hljs-keyword">var</span> double = (number) =&gt; {
          <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
        };
        <span class="hljs-keyword">var</span> doubled_stream = map(numberStream)(double);
        expect(
          stream.head(doubled_stream)
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          stream.toArray(doubled_stream)
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
        );
        <span class="hljs-keyword">var</span> stringStream = stream.cons(<span class="hljs-string">"a"</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-string">"b"</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        <span class="hljs-keyword">var</span> upper = (string) =&gt; {
          <span class="hljs-keyword">return</span> string.toUpperCase();
        };
        expect(
          stream.toArray(map(stringStream)(upper))
        ).to.eql(
          [<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>]
        );
        <span class="hljs-comment">/* #@range_end(stream_map_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>var request = {
  login: (user, password) =&gt; {
 return (pattern) =&gt; {
   expect(pattern).to.an(‘object’);
   return pattern.login(user, password);
 };
  },
  logout: (session) =&gt; {
 return (pattern) =&gt; {
   expect(pattern).to.an(‘object’);
   return pattern.logout(session);
 };
  }
};
var subscribe = (init) =&gt; {
  var subscriptions = init;
  return (request) =&gt; {
 return subscriptions.concat([request]);
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
    });
    describe(<span class="hljs-string">'畳み込み関数で反復処理を渡す'</span>, () =&gt; {
      describe(<span class="hljs-string">'畳み込み関数foldr'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_foldr) */</span>
        <span class="hljs-keyword">var</span> foldr = (alist) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> match(alist,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> callback(head)(foldr(tail)(accumulator)(callback));
                }
              });
            };
          };
        };
        <span class="hljs-comment">/* #@range_end(list_foldr) */</span>
        it(<span class="hljs-string">"foldrでsumを作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_sum) */</span>
          <span class="hljs-keyword">var</span> sum = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">0</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator + item;
              };
            });
          };
          <span class="hljs-comment">/* #@range_end(foldr_sum) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            sum(seq)
          ).to.eql(
            <span class="hljs-number">10</span>  <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span>
          );
          next();
        });
        it(<span class="hljs-string">"foldrでlength関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_length) */</span>
          <span class="hljs-keyword">var</span> length = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">0</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator + <span class="hljs-number">1</span>;
              };
            });
          };
          <span class="hljs-comment">/* #@range_end(foldr_length) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            length(seq)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          next();
        });
        it(<span class="hljs-string">"foldrでproductを作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_product) */</span>
          <span class="hljs-keyword">var</span> product = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">1</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator * item;
              };
            });
          };
          <span class="hljs-comment">/********* テスト **********/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            product(seq)
          ).to.eql(
            <span class="hljs-number">6</span> <span class="hljs-comment">// 1 * 2 * 3 = 6</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_product) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrで reverse関数を作る"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>reverse = foldl (flip cons) list.empty()
var accumulator = list.empty();
var callback = (item) =&gt; {
  return (accumulator) =&gt; {
    return list.append(accumulator)(list.cons(item,list.empty()));
  };
}; 
var reverse = (alist) =&gt; {
  var accumulator = list.empty();
  var callback = (item) =&gt; {
    return (accumulator) =&gt; {
      return list.append(accumulator)(list.cons(item,list.empty()));
    };
  }; 
  return foldr(alist)(accumulator)(callback);
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(foldr_reverse) */</span>
          <span class="hljs-keyword">var</span> reverse = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(list.empty(<span class="hljs-number">0</span>))((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item,list.empty()));
              };
            });
          };
          <span class="hljs-comment">/* #@range_end(foldr_reverse) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            list.toArray(reverse(seq))
          ).to.eql(
            [ <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
          );
          next();
        });
        it(<span class="hljs-string">"foldrでfind関数を作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
          };
          <span class="hljs-comment">/* #@range_begin(foldr_find) */</span>
          <span class="hljs-keyword">var</span> find = (alist) =&gt; {
            <span class="hljs-keyword">return</span> (predicate) =&gt; { <span class="hljs-comment">// 要素を判定する述語関数</span>
              <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-literal">null</span>)((item) =&gt; {
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">if</span>(predicate(item) === <span class="hljs-literal">true</span>) { <span class="hljs-comment">// 要素が見つかった場合</span>
                    <span class="hljs-keyword">return</span> item;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> accumulator;
                  };
                };
              });
            };
          };
          <span class="hljs-comment">/******** テスト *********/</span>
          <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            find(numbers)(even) <span class="hljs-comment">// 最初に登場する偶数の要素を探す</span>
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_find) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでall関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_all) */</span>
          <span class="hljs-keyword">var</span> all = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-literal">true</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator &amp;&amp; truthy(item);
              };
            });
          };
          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-literal">true</span>,list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-literal">null</span>,list.cons(<span class="hljs-string">"a"</span>,list.empty()))));
          expect(
            all(seq)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_all) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでtoArray関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_toarray) */</span>
          <span class="hljs-keyword">var</span> toArray = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)([])((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> [item].concat(accumulator);
              };
            });
          };
          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-literal">true</span>,list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-literal">null</span>,list.cons(<span class="hljs-string">"a"</span>,list.empty()))));
          expect(
            toArray(seq)
          ).to.eql(
            [ <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'a'</span> ]
          );
          <span class="hljs-comment">/* #@range_end(foldr_toarray) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrで map関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_map) */</span>
          <span class="hljs-keyword">var</span> map = (alist) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; { <span class="hljs-comment">// 個々の要素を変換するコールバック関数</span>
              <span class="hljs-keyword">return</span> foldr(alist)(list.empty())((item) =&gt; {
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">return</span> list.cons(callback(item), accumulator);
                };
              });
            };
          };
          <span class="hljs-comment">/****** テスト ******/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.empty())));
          expect(
            list.toArray(map(seq)(double))
          ).to.eql(
            [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>] <span class="hljs-comment">// 2 * [1,2,3] = [2,4,6]</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_map) */</span>
          next();
        });
        it(<span class="hljs-string">"Array#reduceで list#fromArray関数を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_fromArray) */</span>
          <span class="hljs-keyword">var</span> fromArray = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item, list.empty()));
            }, list.empty());
          };
          <span class="hljs-comment">/******* テスト *******/</span>
          <span class="hljs-keyword">var</span> theList = fromArray([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
          expect(
            list.toArray(theList)
          ).to.eql(
            [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_fromArray) */</span>
          next();
        });
      });
    }); <span class="hljs-comment">// 畳み込み関数で反復処理を渡す</span>
    describe(<span class="hljs-string">'継続を渡す'</span>, () =&gt; {
      describe(<span class="hljs-string">"継続の導入例"</span>, () =&gt; {
        it(<span class="hljs-string">"succ関数の継続"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(succ_cps) */</span>
          <span class="hljs-keyword">var</span> succ = (n, continues) =&gt; { <span class="hljs-comment">// continues関数は、succ(n)のあとに続く継続</span>
            <span class="hljs-keyword">return</span> continues(n + <span class="hljs-number">1</span>);
          };
          <span class="hljs-comment">/* #@range_end(succ_cps) */</span>
          <span class="hljs-comment">/* #@range_begin(succ_cps_test) */</span>
          expect(
            succ(<span class="hljs-number">1</span>, identity) <span class="hljs-comment">// identity関数を継続として渡すことで、succ(1)の結果がそのまま返る</span>
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(succ_cps_test) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>it(“succ関数を中断し、再開する”, (next) =&gt; {
  /<em> #@range_begin(succ_suspend_and_resume) </em>/
  var integers = (n) =&gt; {
    var suspendedContinuation = null;
    var succ = (n, continues) =&gt; {
      suspendedContinuation = continues;
      return continues(n + 1);
    };
    return () =&gt; {
    };
  };
  /<em> #@range_end(succ_suspend_and_resume) </em>/
  var identity = (any) =&gt; {
    return any;
  };
  expect(
    succ(1, identity)
  ).to.eql(
    2
  );
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">"算術の継続"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> identity = (any) =&gt; { <span class="hljs-comment">// 値をそのまま返すだけの継続</span>
            <span class="hljs-keyword">return</span> any;
          };
          <span class="hljs-comment">/* #@range_begin(continuation_in_arithmetic) */</span>
          <span class="hljs-keyword">var</span> succ = (n, continues) =&gt; { <span class="hljs-comment">// 継続渡しのsucc関数</span>
            <span class="hljs-keyword">return</span> continues(n + <span class="hljs-number">1</span>);
          };
          <span class="hljs-keyword">var</span> add = (n,m, continues) =&gt; { <span class="hljs-comment">// 継続渡しのadd関数</span>
            <span class="hljs-keyword">return</span> continues(n + m);
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>継続渡しの succ関数と add関数を使って add(2, succ(3)) を計算する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            succ(<span class="hljs-number">3</span>, (succResult) =&gt; {
              <span class="hljs-keyword">return</span> add(<span class="hljs-number">2</span>, succResult, identity);
            })
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(continuation_in_arithmetic) */</span>
          next();
        });
        it(<span class="hljs-string">"継続としての蓄積変数"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(accumulator_as_continuation) */</span>
          <span class="hljs-keyword">var</span> succCPS = (n, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span> + accumulator;
          };
          expect(
            succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> multiplyCPS = (n,m, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> n * m * accumulator;
          };
          expect(
            multiplyCPS(succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 蓄積変数を渡す</span>
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          expect(
            multiplyCPS(succCPS(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), succCPS(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>) <span class="hljs-comment">// 蓄積変数を渡す</span>
          ).to.eql(
            <span class="hljs-number">8</span>
          );
          <span class="hljs-comment">/* #@range_end(accumulator_as_continuation) */</span>
          next();
        });
        it(<span class="hljs-string">"クライアントサーバー通信の継続"</span>, (next) =&gt; {
          
          next();
        });
      });
      describe(<span class="hljs-string">"継続で未来を選ぶ"</span>, () =&gt; {
        it(<span class="hljs-string">"find関数"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_find) */</span>
          <span class="hljs-keyword">var</span> find = (alist,accumulator, predicate) =&gt; {
            <span class="hljs-keyword">var</span> continuesOnRecursion = (alist) =&gt; { <span class="hljs-comment">// 反復処理を続ける継続</span>
              <span class="hljs-keyword">return</span> find(alist, accumulator, predicate);  <span class="hljs-comment">// find関数を再帰的に呼び出す</span>
            };
            <span class="hljs-keyword">var</span> escapesFromRecursion = identity; <span class="hljs-comment">// 反復処理を脱出する継続</span>

            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: () =&gt; {
                <span class="hljs-keyword">return</span> escapesFromRecursion(accumulator); <span class="hljs-comment">// 反復処理を抜ける</span>
              },
              cons: (head, tail) =&gt; { 
                <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) {
                  <span class="hljs-keyword">return</span> escapesFromRecursion(head); <span class="hljs-comment">// escapesFromRecursionで反復処理を脱出する</span>
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> continuesOnRecursion(tail); <span class="hljs-comment">// continuesOnRecursionで次の反復処理を続ける</span>
                };
              }
            });
          };
          <span class="hljs-comment">/* #@range_end(list_find) */</span>
          <span class="hljs-comment">/* #@range_begin(list_find_test) */</span>
          <span class="hljs-keyword">var</span> theList = list.fromArray([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
          expect(
            find(theList,<span class="hljs-literal">null</span>, (item) =&gt; {
              <span class="hljs-keyword">return</span> (item === <span class="hljs-number">4</span>);
            })
          ).to.eql(
            <span class="hljs-literal">null</span>
          );
          expect(
            find(theList,<span class="hljs-literal">null</span>, (item) =&gt; {
              <span class="hljs-keyword">return</span> (item === <span class="hljs-number">2</span>);
            })
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(list_find_test) */</span>
          next();
        }); 
        it(<span class="hljs-string">"継続渡しfind関数"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_find_cps) */</span>
          <span class="hljs-keyword">var</span> find = (alist,accumulator, predicate, continuesOnFailure, continuesOnSuccess) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: () =&gt; {
                <span class="hljs-keyword">return</span> continuesOnSuccess(accumulator); <span class="hljs-comment">// 成功継続で反復処理を抜ける</span>
              },
              cons: (head, tail) =&gt; { 
                <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) { <span class="hljs-comment">// 目的の要素を見つけた場合、</span>
                  <span class="hljs-keyword">return</span> continuesOnSuccess(head); <span class="hljs-comment">// 成功継続で反復処理を脱出する</span>
                } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 目的の要素を見つけられなった場合、失敗継続で次の反復処理を続ける</span>
                  <span class="hljs-keyword">return</span> continuesOnFailure(tail, accumulator, predicate,
                                            continuesOnFailure,
                                            continuesOnSuccess);
                };
              }
            });
          };
          <span class="hljs-comment">/* #@range_end(list_find_cps) */</span>
          <span class="hljs-comment">/* #@range_begin(list_find_cps_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>失敗継続では、反復処理を続ける</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> failureContinuation = (alist, accumulator, predicate, continuesOnRecursion, escapesFromRecursion) =&gt; { 
            <span class="hljs-keyword">return</span> find(alist, accumulator, predicate, continuesOnRecursion, escapesFromRecursion);  <span class="hljs-comment">// find関数を再帰的に呼び出す</span>
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>成功継続では、反復処理を脱出する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> successContinuation = identity; 
          <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            find(numbers,<span class="hljs-literal">null</span>, (item) =&gt; {
              <span class="hljs-keyword">return</span> (item === <span class="hljs-number">10</span>); <span class="hljs-comment">// 10の要素を探します</span>
            }, failureContinuation, successContinuation)
          ).to.eql(
            <span class="hljs-literal">null</span> <span class="hljs-comment">// 10の要素はないので、nullになります</span>
          );
          expect(
            find(numbers,<span class="hljs-literal">null</span>, (item) =&gt; {
              <span class="hljs-keyword">return</span> (item === <span class="hljs-number">2</span>); <span class="hljs-comment">// 2の要素を探します</span>
            }, failureContinuation, successContinuation)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(list_find_cps_test) */</span>
          next();
        }); 
        it(<span class="hljs-string">"継続による反復処理"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(loop_cps) */</span>
          <span class="hljs-keyword">var</span> loop = (predicate, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (continues) =&gt; {
              <span class="hljs-keyword">if</span>(predicate(accumulator)){
                <span class="hljs-keyword">return</span> loop(predicate, continues(accumulator))(continues);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> accumulator;
              }
            };
          };
          <span class="hljs-keyword">var</span> lessThan = (n) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> x &lt; n;
            };
          };
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          expect(
            loop(lessThan(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>)(succ)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(loop_cps) */</span>
          next();
        }); 
      }); 
      describe(<span class="hljs-string">"継続による非決定計算"</span>, () =&gt; {
        <span class="hljs-keyword">var</span> exp = {
          match : (anExp, pattern) =&gt; {
            <span class="hljs-keyword">return</span> anExp.call(exp, pattern);
          },
          <span class="hljs-comment">/* #@range_begin(amb_expression) */</span>
          amb : (alist) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.amb(alist);
            };
          },
          <span class="hljs-comment">/* #@range_end(amb_expression) */</span>
          num : (n) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.num(n);
            };
          },
          add : (exp1, exp2) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.add(exp1, exp2);
            };
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>mul : (exp1, exp2) =&gt; {
  return (pattern) =&gt; {
    return pattern.mul(exp1, exp2);
  };
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        };</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>mul: (x, y) =&gt; {
  return calculate(x, (resultX, alternativeForX) =&gt; { // 引数xを評価する
    return calculate(y, (resultY, alternativeForY) =&gt; { // 引数yを評価する
      return continuesOnSuccess(resultX * resultY, alternativeForY); // かけ算を計算する
    }, alternativeForX); // y の計算に失敗すれば、xの失敗継続を渡す
  }, continuesOnFailure);
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(amb_calculate) */</span>
        <span class="hljs-keyword">var</span> calculate = (anExp, continuesOnSuccess, continuesOnFailure) =&gt; {
          <span class="hljs-keyword">return</span> exp.match(anExp, { <span class="hljs-comment">// 式に対してパターンマッチを実行する</span></pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>数値を評価する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            num: (n) =&gt; {
              <span class="hljs-keyword">return</span> continuesOnSuccess(n, continuesOnFailure);
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>足し算を評価する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            add: (x, y) =&gt; {
              <span class="hljs-keyword">return</span> calculate(x, (resultX, continuesOnFailureX) =&gt; { <span class="hljs-comment">// 引数xを評価する</span>
                <span class="hljs-keyword">return</span> calculate(y, (resultY, continuesOnFailureY) =&gt; { <span class="hljs-comment">// 引数yを評価する</span>
                  <span class="hljs-keyword">return</span> continuesOnSuccess(resultX + resultY, continuesOnFailureY); <span class="hljs-comment">// 足し算を計算する</span>
                }, continuesOnFailureX); <span class="hljs-comment">// y の計算に失敗すれば、xの失敗継続を渡す</span>
              }, continuesOnFailure);
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>amb式を評価する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            amb: (choices) =&gt; {
              <span class="hljs-keyword">var</span> calculateAmb = (choices) =&gt; {
                <span class="hljs-keyword">return</span> list.match(choices, {</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>amb(list.empty()) の場合、すなわち選択肢がなければ、失敗継続を実行する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  empty: () =&gt; {         
                    <span class="hljs-keyword">return</span> continuesOnFailure();
                  },</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>amb(list.cons(head, tail))の場合、最初の要素を計算して、殘りは失敗継続に渡す</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  cons: (head, tail) =&gt; { 
                    <span class="hljs-keyword">return</span> calculate(head, 
                                     continuesOnSuccess, 
                                     (_) =&gt; { <span class="hljs-comment">// 失敗継続を作り、そのなかで次の選択肢について計算する</span>
                                       <span class="hljs-keyword">return</span> calculateAmb(tail, continuesOnSuccess, continuesOnFailure);
                                     });
                  }
                });
              };
              <span class="hljs-keyword">return</span> calculateAmb(choices, continuesOnSuccess, continuesOnFailure);
            }
          });
        };
        <span class="hljs-comment">/* #@range_end(amb_calculate) */</span>
        <span class="hljs-comment">/* #@range_begin(amb_driver) */</span>
        <span class="hljs-keyword">var</span> driver = (expression) =&gt;{
          <span class="hljs-keyword">var</span> suspendedComputation = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 中断された計算を継続として保存する </span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>成功継続</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> continuesOnSuccess = (anyValue, continuesOnFailure) =&gt; {
            suspendedComputation = continuesOnFailure; <span class="hljs-comment">// 再開に備えて、失敗継続を保存しておく</span>
            <span class="hljs-keyword">return</span> anyValue;
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>失敗継続</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> continuesOnFailure = () =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          };
          <span class="hljs-keyword">return</span> () =&gt; {
            <span class="hljs-keyword">if</span>(suspendedComputation === <span class="hljs-literal">null</span>) { <span class="hljs-comment">// 中断された継続がなければ、最初から計算する</span>
              <span class="hljs-keyword">return</span> calculate(expression, continuesOnSuccess, continuesOnFailure);
            } <span class="hljs-keyword">else</span> {                            <span class="hljs-comment">// 中断された継続があれば、その継続を実行する</span>
              <span class="hljs-keyword">return</span> suspendedComputation();
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(amb_driver) */</span>
        it(<span class="hljs-string">"amb[1,2] + 3  = amb[4, 5]"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> ambExp = exp.add(exp.amb(list.cons(exp.num(<span class="hljs-number">1</span>),list.cons(exp.num(<span class="hljs-number">2</span>), list.empty()))), 
                                exp.num(<span class="hljs-number">3</span>));
          <span class="hljs-keyword">var</span> calculator = driver(ambExp);
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">4</span> <span class="hljs-comment">// 1 + 3 = 4</span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">5</span> <span class="hljs-comment">// 2 + 3 = 5 </span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-literal">null</span>
          );
          next();
        });
        it(<span class="hljs-string">"amb[1,2] + amb[3,4] = amb[4, 5, 5, 6]"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>var ambExp = exp.add(exp.amb(list.cons(exp.num(1),list.cons(exp.num(2), list.empty()))),
                     exp.amb(list.cons(exp.num(3),list.cons(exp.num(4), list.empty()))));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(amb_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>amb[1,2] + amb[3,4] = amb[4, 5, 5, 6]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> ambExp = exp.add(exp.amb(list.fromArray([exp.num(<span class="hljs-number">1</span>),exp.num(<span class="hljs-number">2</span>)])),
                               exp.amb(list.fromArray([exp.num(<span class="hljs-number">3</span>),exp.num(<span class="hljs-number">4</span>)])));
          <span class="hljs-keyword">var</span> calculator = driver(ambExp);
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">4</span> <span class="hljs-comment">// 1 + 3 = 4</span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">5</span> <span class="hljs-comment">// 2 + 3 = 5</span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">5</span> <span class="hljs-comment">// 1 + 4 = 5</span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-number">6</span> <span class="hljs-comment">// 2 + 4 = 6</span>
          );
          expect(
            calculator()
          ).to.eql(
            <span class="hljs-literal">null</span> <span class="hljs-comment">// これ以上の候補はないので、計算は終了</span>
          );
          <span class="hljs-comment">/* #@range_end(amb_test) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>it(“amb[2,3] <em> amb[4,5]  = amb[2, 3]”, (next) =&gt; {
  var ambExp = exp.mul(exp.amb(list.cons(exp.num(2),list.cons(exp.num(3), list.empty()))), 
                         exp.amb(list.cons(exp.num(4),list.cons(exp.num(5), list.empty()))));
  var calculator = driver(ambExp);
  expect(
    calculator()
  ).to.eql(
    8
  );
  expect(
    calculator()
  ).to.eql(
    10
  );
  expect(
    calculator()
  ).to.eql(
    12
  );
  next();
});
// ambExp = [1,2] + (2 </em> 3) = [6, 12]
var ambExp = add(
  amb(
    list.cons(num(1),list.cons(num(2), list.empty()))), 
  mul(num(2), num(3)));
expect(
  calculate(ambExp, continues.normally, continues.abnormally)
).to.eql(
  7
);
var exp = add(num(1), mul(num(2), num(3)));
expect(
  calculate(exp, continues.normally, continues.onFailure)
).to.eql(
  7
);
var exp = add(num(1), mul(num(2), num(3)));
expect(
  calculate(exp, continues.normally, continues.onFailure)
).to.eql(
  7
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }); 
    }); <span class="hljs-comment">// 継続を渡す</span>
  }); <span class="hljs-comment">// 関数を渡す</span>
  describe(<span class="hljs-string">'コンビネーター'</span>, () =&gt; {
    it(<span class="hljs-string">'multipleOfコンビネータ'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(multipleOf_combinator) */</span>
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-keyword">var</span> even = multipleOf(<span class="hljs-number">2</span>);
      
      expect(
        even(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(multipleOf_combinator) */</span>
      next();
    }); 
    it(<span class="hljs-string">'論理コンビネータ'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-keyword">var</span> even = multipleOf(<span class="hljs-number">2</span>);
      <span class="hljs-comment">/* #@range_begin(not_combinator) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>not :: FUN[NUM =&gt; BOOL] =&gt; FUN[NUM =&gt; BOOL]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> not = (predicate) =&gt; { <span class="hljs-comment">// predicate:: FUN[NUM =&gt; BOOL]</span>
        <span class="hljs-keyword">return</span> (arg) =&gt; { <span class="hljs-comment">// FUN[NUM =&gt; BOOL]型を返す</span>
          <span class="hljs-keyword">return</span> ! predicate(arg); <span class="hljs-comment">// !演算子で論理を反転させる</span>
        };
      };
      <span class="hljs-comment">/* #@range_end(not_combinator) */</span>
      <span class="hljs-comment">/* #@range_begin(not_combinator_test) */</span>
      <span class="hljs-keyword">var</span> odd = not(even); <span class="hljs-comment">// notコンビネータでodd関数を定義する</span>
      <span class="hljs-comment">/******** テスト ********/</span>
      expect(
        odd(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      expect(
        odd(<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(not_combinator_test) */</span>
      <span class="hljs-comment">/* #@range_begin(and_or_combinator) */</span>
      <span class="hljs-comment">/* 「もしくは」を表す論理和  */</span>
      <span class="hljs-comment">/* or:: (NUMBER-&gt;BOOL, NUMBER-&gt;BOOL) -&gt; (NUMBER-&gt;BOOL) */</span>
      <span class="hljs-keyword">var</span> or = (f,g) =&gt; {
        <span class="hljs-keyword">return</span> (arg) =&gt; {
          <span class="hljs-keyword">return</span> f(arg) || g(arg);
        };
      };
      <span class="hljs-comment">/* 「かつ」を表す論理積  */</span>
      <span class="hljs-comment">/* and:: (NUMBER-&gt;BOOL, NUMBER-&gt;BOOL) -&gt; (NUMBER-&gt;BOOL) */</span>
      <span class="hljs-keyword">var</span> and = (f,g) =&gt; {
        <span class="hljs-keyword">return</span> (arg) =&gt; {
          <span class="hljs-keyword">return</span> f(arg) &amp;&amp; g(arg);
        };
      };
      <span class="hljs-comment">/* #@range_end(and_or_combinator) */</span>
      <span class="hljs-keyword">var</span> positive = (n) =&gt; {
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>;
      };
      <span class="hljs-keyword">var</span> zero = (n) =&gt; {
        <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span>;
      };
      <span class="hljs-keyword">var</span> negative = or(positive, not(zero));
      expect(
        negative(-<span class="hljs-number">3</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        negative(<span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">'パイプライン'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> pipe = (f, g) =&gt; {
        <span class="hljs-keyword">return</span> (input) =&gt; {
          <span class="hljs-keyword">return</span> compose(f,g)(input);
        };
      };
      <span class="hljs-keyword">var</span> pipelines = (combinators) =&gt; {
        <span class="hljs-keyword">return</span> (input) =&gt; {
          <span class="hljs-keyword">return</span> combinators.reduce((accumulator, combinator) =&gt; {
            <span class="hljs-keyword">return</span> compose(combinator,accumulator);
          });
        };
      };
      next();
    });
    describe(<span class="hljs-string">'コンビネーター・ライブラリー'</span>, () =&gt; {
      describe(<span class="hljs-string">'数値型検証コンビネータ'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(number_combinator) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>is:: FUNC[ANY -&gt; BOOL] -&gt; ANY -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> is = (predicate) =&gt; {
          expect(predicate).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">return</span> truthy(predicate(target));
          };
        };
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
          expect(predicate).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">return</span> ! is(predicate)(target);
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>eq:: ANY -&gt; ANY -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> eq = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x === y;
          };
        };
        <span class="hljs-keyword">var</span> remainder = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> n % m;
          };
        };
        it(<span class="hljs-string">'remainder'</span>, (next) =&gt; {
          expect(
            remainder(<span class="hljs-number">10</span>)(<span class="hljs-number">3</span>)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>multipleOf:: NUM -&gt; NUM -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
          expect(n).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> (m) =&gt; {
            expect(n).to.a(<span class="hljs-string">'number'</span>);
            <span class="hljs-keyword">return</span> eq(remainder(m)(n))(<span class="hljs-number">0</span>);
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>even:: NUM -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> even = multipleOf(<span class="hljs-number">2</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>odd:: NUM -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> odd = not(even);
        <span class="hljs-keyword">var</span> or = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) || g(arg);
          };
        };
        <span class="hljs-keyword">var</span> and = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) &amp;&amp; g(arg);
          };
        };
        <span class="hljs-keyword">var</span> zero = (n) =&gt; {
          <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span>;
        };
        <span class="hljs-keyword">var</span> isZero = is(zero);</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>positive:: NUM -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> positive = (n) =&gt; {
          <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>;
        };
        <span class="hljs-keyword">var</span> isNegative = or(is(positive),not(isZero));
        it(<span class="hljs-string">'isNegative'</span>, (next) =&gt; {
          expect(
            isNegative(<span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          next();
        });
        <span class="hljs-keyword">var</span> greater = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> n &lt; m;
          };
        };
        <span class="hljs-comment">/* #@range_end(number_combinator) */</span>
        <span class="hljs-comment">/* #@range_begin(number_combinator_greater) */</span>
        <span class="hljs-keyword">var</span> greater = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> n &lt; m;
          };
        };
        it(<span class="hljs-string">'greater'</span>, (next) =&gt; {
          expect(
            is(greater(<span class="hljs-number">0</span>))(<span class="hljs-number">1</span>)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          expect(
            is(greater(<span class="hljs-number">0</span>))(<span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          expect(
            is(greater(<span class="hljs-number">0</span>))(-<span class="hljs-number">1</span>)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          next();
        });
        <span class="hljs-comment">/* #@range_end(number_combinator_greater) */</span>
        <span class="hljs-comment">/* #@range_begin(number_combinator_smaller) */</span>
        <span class="hljs-keyword">var</span> smaller = flip(greater);
        it(<span class="hljs-string">'smaller'</span>, (next) =&gt; {
          expect(
            is(smaller(<span class="hljs-number">0</span>))(<span class="hljs-number">1</span>)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          expect(
            is(smaller(<span class="hljs-number">0</span>))(<span class="hljs-number">0</span>)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          expect(
            is(smaller(<span class="hljs-number">0</span>))(-<span class="hljs-number">1</span>)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          next();
        });
        <span class="hljs-comment">/* #@range_end(number_combinator_smaller) */</span>
        
        <span class="hljs-keyword">var</span> gcd = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">if</span>(is(zero)(y)){
              <span class="hljs-keyword">return</span> x;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span>(is(zero)(x)){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"gcd(0)(0) is not defined"</span>);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> gcd(y)(remainder(x)(y));
              }            
            }
          };
        };
        it(<span class="hljs-string">'gcd'</span>, (next) =&gt; {
          expect(
            gcd(<span class="hljs-number">36</span>)(<span class="hljs-number">12</span>)
          ).to.eql(
            <span class="hljs-number">12</span>
          );
          next();
        });
        <span class="hljs-keyword">var</span> leastDivisor = (n) =&gt; {
          expect(n).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">var</span> leastDivisorHelper = (k, n) =&gt; {
            expect(k).to.a(<span class="hljs-string">'number'</span>);
            expect(n).to.a(<span class="hljs-string">'number'</span>);
            <span class="hljs-keyword">if</span>(multipleOf(k)(n)) {
              <span class="hljs-keyword">return</span> k;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span>(is(greater(n))(k * k)) {
                <span class="hljs-keyword">return</span> n;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> leastDivisorHelper(k+<span class="hljs-number">1</span>, n);
              }
            };
          };
          <span class="hljs-keyword">return</span> leastDivisorHelper(<span class="hljs-number">2</span>,n);
        };
        <span class="hljs-comment">/*
          c.f. Haskell Road, p.19
          ~~~haskell
          factors :: Integer -&gt; [Integer]
          factors n | n &lt; 1 = error "argument not positive"
                    | n == 1 = []
                    | otherwise = p : factors (div n p) where p = ld n
          ~~~
        */</span>
        <span class="hljs-keyword">var</span> factors = (n) =&gt; {
          <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"argument not positive"</span>);
          }
          <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> list.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> leastDivisorOfN = leastDivisor(n);
            <span class="hljs-keyword">return</span> list.cons(leastDivisorOfN, factors(n / leastDivisorOfN));
          }
        };
        it(<span class="hljs-string">'factorsで素因数分解を求める'</span>, (next) =&gt; {
          expect(
            list.toArray(factors(<span class="hljs-number">84</span>))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>var cond = (predicate) =&gt; {
  return (thenClause) =&gt; {
    return (elseClause) =&gt; {
      if(truthy(predicate)
    };
  };
};
// abs:: NUM -&gt; NUM
var abs = (n) =&gt; {
  expect(n).to.a(‘number’);
  return cond(positive)(n)(- n);
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      });
      describe(<span class="hljs-string">'文字列検証コンビネータ'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>is:: FUNC[ANY -&gt; BOOL] -&gt; ANY -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> is = (predicate) =&gt; {
          expect(predicate).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">return</span> truthy(predicate(target));
          };
        };
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
          expect(predicate).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">return</span> ! is(predicate)(target);
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>eq:: ANY -&gt; ANY -&gt; BOOL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> eq = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x === y;
          };
        };
        <span class="hljs-keyword">var</span> greater = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> n &lt; m;
          };
        };
        <span class="hljs-keyword">var</span> smaller = flip(greater);
        <span class="hljs-keyword">var</span> or = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) || g(arg);
          };
        };
        <span class="hljs-keyword">var</span> and = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) &amp;&amp; g(arg);
          };
        };
        it(<span class="hljs-string">'文字列の長さをチェックする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_length_check) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>文字列をリスト型に変換する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> stringAsList = list.fromString(<span class="hljs-string">"abcd"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>文字列の長さが6より長いかどうかを判定する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            is(greater(<span class="hljs-number">6</span>))(list.length(stringAsList))
          ).to.be(
            <span class="hljs-literal">false</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>文字列の長さが3より長く6より短いかどうかを判定する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            and(greater(<span class="hljs-number">3</span>),
                smaller(<span class="hljs-number">6</span>))(list.length(stringAsList))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-comment">/* #@range_end(list_length_check) */</span>
          expect(
            is(greater(<span class="hljs-number">3</span>))(list.length(stringAsList))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          next();
        });
        it(<span class="hljs-string">'ある文字があるかどうかを list.any でチェックする'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> stringAsList = list.fromString(<span class="hljs-string">"abXd"</span>);
          expect(
            list.any(stringAsList)((ch) =&gt; {
              <span class="hljs-keyword">return</span> ch === <span class="hljs-string">'X'</span>;
            })
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          next();
        });
      });
      describe(<span class="hljs-string">'オブジェクト型検証コンビネータ'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
        <span class="hljs-keyword">var</span> isEmpty = (obj) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>null and null are “empty”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Assume if it has a length property with a non-zero value
that that property is correct.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (obj.length &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">if</span> (obj.length === <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Otherwise, does it have any properties of its own?
Note that this doesn’t handle
toString and valueOf enumeration bugs in IE &lt; 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
            <span class="hljs-keyword">if</span> (hasOwnProperty.call(obj, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };

        <span class="hljs-comment">/* パース結果の代数的データ型 */</span>
        <span class="hljs-keyword">var</span> result = {
          failed: (message) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.failed(message);
            };
          },
          successful: (value, inputObject) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.successful(value, inputObject);
            };
          }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>validate: PARSER -&gt; JSON -&gt; PARSERESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> validate = (validator, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> validator(inputObject, continues, continuesInFailure);
          };
        };
        <span class="hljs-comment">/* 基本パーサー */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>succeed:: ANY =&gt; LIST =&gt; RESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> succeed = (value, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> continues(result.successful(value, inputObject));
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>fail:: (ANY) =&gt; LIST =&gt; PARSERESULT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fail = (message, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">return</span> continuesInFailure(result.failed(message));
          };
        };
        <span class="hljs-keyword">var</span> continues = {
          normally: (result) =&gt; {
            <span class="hljs-keyword">return</span> result;
          },
          abnormally: (exception) =&gt; {
            <span class="hljs-keyword">return</span> exception;
          }
        };
        it(<span class="hljs-string">'succeed'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> object = {
            key: <span class="hljs-number">1</span>
          };
          match(validate(succeed(<span class="hljs-literal">true</span>, continues.normally, continues.abnormally)(object)),{
            failed: () =&gt; {
              expect().fail();
            },
            successful: (value, theObject) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-number">1</span>
              );
              expect(
                theObject
              ).to.eql(
                object
              );
            }
          });
          next();
        });
        it(<span class="hljs-string">'fail'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> object = {
            key: <span class="hljs-number">1</span>
          };
          match(validate(fail(<span class="hljs-string">"failed"</span>, continues.normally, continues.abnormally)(object)),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">"failed"</span>
              );
            },
            successful: (value, theObject) =&gt; {
              expect().fail();
            }
          });
          next();
        });
        <span class="hljs-keyword">var</span> is = (predicate, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (target) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(target)){
              <span class="hljs-keyword">return</span> continues(succeed(<span class="hljs-literal">true</span>, continues, continuesInFailure)(target));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> continuesInFailure(fail(<span class="hljs-string">"is not"</span>, continues, continuesInFailure)(target));
            }
          };
        };
        <span class="hljs-keyword">var</span> typeOf = (target) =&gt; {
          <span class="hljs-keyword">if</span>(target === <span class="hljs-literal">undefined</span> || target === <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(target);
          <span class="hljs-keyword">var</span> classToType = {
            <span class="hljs-string">'[object Boolean]'</span>: <span class="hljs-string">'boolean'</span>,
            <span class="hljs-string">'[object Number]'</span>: <span class="hljs-string">'number'</span>,
            <span class="hljs-string">'[object String]'</span>: <span class="hljs-string">'string'</span>,
            <span class="hljs-string">'[object Function]'</span>: <span class="hljs-string">'function'</span>,
            <span class="hljs-string">'[object Array]'</span>: <span class="hljs-string">'array'</span>,
            <span class="hljs-string">'[object Date]'</span>: <span class="hljs-string">'date'</span>,
            <span class="hljs-string">'[object RegExp]'</span>: <span class="hljs-string">'regexp'</span>,
            <span class="hljs-string">'[object Object]'</span>: <span class="hljs-string">'object'</span>
          };
          <span class="hljs-keyword">return</span> classToType[<span class="hljs-built_in">Object</span>.prototype.toString.call(target)];
        };
        <span class="hljs-keyword">var</span> bool = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'boolean'</span>;
        };
        <span class="hljs-keyword">var</span> string = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'string'</span>;
        };
        <span class="hljs-keyword">var</span> number = (value) =&gt; {
          <span class="hljs-keyword">return</span> typeOf(value) === <span class="hljs-string">'number'</span>;
        };
        it(<span class="hljs-string">'is'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(is_number_test) */</span>
          <span class="hljs-keyword">var</span> target = <span class="hljs-number">1</span>;
          match(validate(is(number, continues.normally, continues.abnormally)(target)),{
            failed: (message) =&gt; {
              expect().fail();
            },
            successful: (value, target) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-literal">true</span>
              );
            }
          });
          <span class="hljs-comment">/* #@range_end(is_number_test) */</span>
          next();
        });
        <span class="hljs-keyword">var</span> hasKey = (key, continues, continuesInFailure) =&gt; {
          <span class="hljs-keyword">return</span> (inputObject) =&gt; {
            <span class="hljs-keyword">if</span>(isEmpty(inputObject)) {
              <span class="hljs-keyword">return</span> continuesInFailure(fail(<span class="hljs-string">"empty"</span>, continues, continuesInFailure)(inputObject));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> theKey <span class="hljs-keyword">in</span> inputObject) {
                <span class="hljs-keyword">if</span> (hasOwnProperty.call(inputObject, key)) {
                  <span class="hljs-keyword">return</span> continues(succeed(<span class="hljs-literal">true</span>, continues, continuesInFailure)(inputObject));
                }
              }
              <span class="hljs-keyword">return</span> continuesInFailure(fail(key + <span class="hljs-string">" is not found"</span>, continues, continuesInFailure)(inputObject));
            }
          };
        };
        it(<span class="hljs-string">'hasKey'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> inputObject = {
            <span class="hljs-string">"key"</span>: <span class="hljs-number">1</span>
          };
          match(validate(hasKey(<span class="hljs-string">"key"</span>, continues.normally, continues.abnormally)(inputObject)),{
            failed: (message) =&gt; {
              expect().fail();
            },
            successful: (value, inputObject) =&gt; {
              expect(
                value
              ).to.eql(
                <span class="hljs-literal">true</span>
              );
            }
          });
          match(validate(hasKey(<span class="hljs-string">"nokey"</span>, continues.normally, continues.abnormally)({})),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">'empty'</span>
              );
            },
            successful: (value, inputObject) =&gt; {
              expect().fail();
            }
          });
          match(validate(hasKey(<span class="hljs-string">"nokey"</span>, continues.normally, continues.abnormally)(inputObject)),{
            failed: (message) =&gt; {
              expect(
                message
              ).to.eql(
                <span class="hljs-string">'nokey is not found'</span>
              );
            },
            successful: (value, inputObject) =&gt; {
              expect().fail();
            }
          });
          next();
        });
      });
      it(<span class="hljs-string">'ケージ監視'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(combinator_library) */</span>
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-keyword">var</span> get = (key) =&gt; {
          <span class="hljs-keyword">return</span> (obj) =&gt; {
            <span class="hljs-keyword">return</span> obj[key];
          };
        };
        <span class="hljs-keyword">var</span> isEqual = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n2 === n1;
          };
        };
        <span class="hljs-keyword">var</span> isLessThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &gt; n2;
          };
        };
        <span class="hljs-keyword">var</span> isMoreThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &lt; n2;
          };
        };
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
          <span class="hljs-keyword">return</span> (data) =&gt; {
            <span class="hljs-keyword">return</span> ! predicate(data);
          }
        };
        <span class="hljs-keyword">var</span> within = (lower) =&gt; {
          <span class="hljs-keyword">return</span> (upper) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">return</span> (extractor) =&gt; {
                <span class="hljs-keyword">return</span> and(extractor, isMoreThan(lower))(extractor, isLessThan(upper))(data);
              };
            };
          };
        };
        <span class="hljs-keyword">var</span> and = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(! firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-keyword">var</span> or = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(combinator_library) */</span>
        <span class="hljs-comment">/* #@range_begin(combinator_library_test) */</span>
        <span class="hljs-keyword">var</span> data = {
          temp: <span class="hljs-number">24</span>,
          time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"2013/2/15 17:57:27"</span>)
        };
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> and(getTemp, isMoreThan(<span class="hljs-number">20</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> or(getTemp, isMoreThan(<span class="hljs-number">30</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(get(<span class="hljs-string">'temp'</span>)(data))(id)
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)(get(<span class="hljs-string">'temp'</span>))
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)((data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data)
          })
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        <span class="hljs-comment">/* #@range_end(combinator_library_test) */</span>
        next();
      });
    });
    it(<span class="hljs-string">'Y combinator'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(Y_combinator) */</span>
      <span class="hljs-keyword">var</span> Y = (F) =&gt; {
        <span class="hljs-keyword">return</span> ((g) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt;  {
            <span class="hljs-keyword">return</span> F(g(g))(x);
          };
        })((g) =&gt;  {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> F(g(g))(x);
          };
        });
      };
      <span class="hljs-comment">/* #@range_end(Y_combinator)  */</span>
      <span class="hljs-comment">/* #@range_begin(Y_combinator_test) */</span>
      <span class="hljs-keyword">var</span> factorial = Y((fact) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);
          }
        };
      });
      expect(
        factorial(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 * 2 * 1 = 6</span>
      ).to.eql(
        <span class="hljs-number">6</span>
      );
      <span class="hljs-comment">/* #@range_end(Y_combinator_test) */</span>
      
      next();
    });
    
  }); <span class="hljs-comment">// コンビネータ</span>
  describe(<span class="hljs-string">'モナドを作る'</span>, () =&gt; {
    describe(<span class="hljs-string">'恒等モナド'</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_monad) */</span>
      <span class="hljs-keyword">var</span> ID = {</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>unit:: T =&gt; ID[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {  <span class="hljs-comment">// 単なる identity関数と同じ</span>
          <span class="hljs-keyword">return</span> value;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>flatMap:: ID[T] =&gt; FUN[T =&gt; ID[T]] =&gt; ID[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatMap: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> transform(instanceM); <span class="hljs-comment">// 単なる関数適用と同じ</span>
          };
        }
      };
      <span class="hljs-comment">/* #@range_end(identity_monad) */</span>
      it(<span class="hljs-string">"恒等モナドのunit関数"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_monad_unit_test) */</span>
        expect(
          ID.unit(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_unit_test) */</span>
        next();
      });
      it(<span class="hljs-string">"恒等モナドのflatMap関数"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-comment">/* #@range_begin(identity_monad_flatMap_test) */</span>
        expect(
          ID.flatMap(ID.unit(<span class="hljs-number">1</span>))((one) =&gt; {    
            <span class="hljs-keyword">return</span> ID.unit(succ(one));
          })
        ).to.eql(
          succ(<span class="hljs-number">1</span>)
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_flatMap_test) */</span>
        <span class="hljs-comment">/* #@range_begin(flatMap_and_composition) */</span>
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> double = (m) =&gt; {
          <span class="hljs-keyword">return</span> m * <span class="hljs-number">2</span>;
        };
        expect(
          ID.flatMap(ID.unit(<span class="hljs-number">1</span>))((one) =&gt; {    
            <span class="hljs-keyword">return</span> ID.flatMap(ID.unit(succ(one)))((two) =&gt; { <span class="hljs-comment">// succ関数を適用する</span>
              <span class="hljs-keyword">return</span> ID.unit(double(two));  <span class="hljs-comment">// double関数を適用する</span>
            });
          })
        ).to.eql(
          compose(double,succ)(<span class="hljs-number">1</span>)
        );
        <span class="hljs-comment">/* #@range_end(flatMap_and_composition) */</span>
        next();
      });
      describe(<span class="hljs-string">"恒等モナドのモナド則"</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(identity_monad_laws) */</span>
        it(<span class="hljs-string">"flatMap(instanceM)(unit) === instanceM"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(identity_monad_laws_right_unit_law) */</span>
          <span class="hljs-comment">/* flatMap(instanceM)(unit) === instanceM の一例 */</span>
          <span class="hljs-keyword">var</span> instanceM = ID.unit(<span class="hljs-number">1</span>);
          expect(
            ID.flatMap(instanceM)(ID.unit)
          ).to.eql(
            instanceM
          );
          <span class="hljs-comment">/* #@range_end(identity_monad_laws_right_unit_law) */</span>
          next();
        });
        it(<span class="hljs-string">"flatMap(unit(value))(f) == f(value)"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(identity_monad_laws_left_unit_law) */</span>
          <span class="hljs-comment">/* flatMap(unit(value))(f) === f(value) */</span>
          <span class="hljs-keyword">var</span> f = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          expect(
            ID.flatMap(ID.unit(<span class="hljs-number">1</span>))(f)
          ).to.eql(
            f(<span class="hljs-number">1</span>)
          );
          <span class="hljs-comment">/* #@range_end(identity_monad_laws_left_unit_law) */</span>
          next();
        });
        it(<span class="hljs-string">"flatMap(flatMap(instanceM)(f))(g) == flatMap(instanceM)((x) =&gt; flatMap(f(x))(g))"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(identity_monad_laws_associative_law) */</span>
          <span class="hljs-comment">/* flatMap(flatMap(instanceM)(f))(g) === 
             flatMap(instanceM)((x) =&gt; { return flatMap(f(x))(g); } } */</span>
          <span class="hljs-keyword">var</span> instanceM = ID.unit(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">var</span> f = (n) =&gt; {
            <span class="hljs-keyword">return</span> ID.unit(n * n);
          };
          <span class="hljs-keyword">var</span> g = (n) =&gt; {
            <span class="hljs-keyword">return</span> ID.unit(- n);
          };
          expect(
            ID.flatMap(ID.flatMap(instanceM)(f))(g)
          ).to.eql(
            ID.flatMap(instanceM)((x) =&gt; {
              <span class="hljs-keyword">return</span> ID.flatMap(f(x))(g);
            })
          );
          <span class="hljs-comment">/* #@range_end(identity_monad_laws_associative_law) */</span>
          <span class="hljs-comment">/* #@range_end(identity_monad_laws) */</span>
          next();
        });
      });
      it(<span class="hljs-string">"identity#flatMap"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(identity_monad_test) */</span>
        <span class="hljs-keyword">var</span> instance = ID.unit(<span class="hljs-number">1</span>);
        expect(
          ID.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> ID.unit(n * <span class="hljs-number">2</span>);
          })
        ).to.eql(
          ID.unit(<span class="hljs-number">2</span>)
        );
        expect(
          ID.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> ID.flatMap(ID.unit(n * <span class="hljs-number">2</span>))((m) =&gt; {
              <span class="hljs-keyword">return</span> ID.unit(m * <span class="hljs-number">3</span>);
            });
          })
        ).to.eql(
          ID.unit(<span class="hljs-number">6</span>)
        );
        expect(
          ID.flatMap(instance)((n) =&gt; {
            <span class="hljs-keyword">return</span> ID.flatMap(ID.unit(n))((m) =&gt; {
              <span class="hljs-keyword">return</span> ID.unit(m * n);
            });
          })
        ).to.eql(
          ID.unit(<span class="hljs-number">1</span>)
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'Maybeモナドを作る'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> id = (any) =&gt; {
        <span class="hljs-keyword">return</span> any;
      };
      <span class="hljs-keyword">var</span> match = (exp, pattern) =&gt; {
        <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
      };
      describe(<span class="hljs-string">'Maybeモナドを作る'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(algebraic_type_maybe) */</span>
        <span class="hljs-keyword">var</span> just = (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.just(value);
          };
        };
        <span class="hljs-keyword">var</span> nothing = (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.nothing(_);
          };
        };
        <span class="hljs-comment">/* #@range_end(algebraic_type_maybe) */</span>
        <span class="hljs-keyword">var</span> MAYBE = {
          <span class="hljs-comment">/* #@range_begin(maybe_monad) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>unit:: T =&gt; MAYBE[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit: (value) =&gt; {
            <span class="hljs-keyword">return</span> just(value);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>flatMap:: MAYBE[T] =&gt; FUN[T =&gt; MAYBE[U]] =&gt; MAYBE[U]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatMap: (instanceM) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              <span class="hljs-keyword">return</span> match(instanceM,{
                just: (value) =&gt; { <span class="hljs-comment">// 正常な値の場合は、transform関数を計算する</span>
                  <span class="hljs-keyword">return</span> transform(value);
                },
                nothing: (_) =&gt; { <span class="hljs-comment">// エラーの場合は、何もしない</span>
                  <span class="hljs-keyword">return</span> nothing(_);
                }
              });
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>ヘルパー関数 </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          getOrElse: (instanceM) =&gt; {
            <span class="hljs-keyword">return</span> (alternate) =&gt; {
              <span class="hljs-keyword">return</span> match(instanceM,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> value;
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> alternate;
                }
              });
            };
          },
          <span class="hljs-comment">/* #@range_end(maybe_monad) */</span>
          <span class="hljs-comment">/* #@range_begin(maybe_monad_helper) */</span>
          isEqual: (maybeA,maybeB) =&gt; {
            <span class="hljs-keyword">return</span> match(maybeA,{
              just: (valueA) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (valueB) =&gt; {
                    <span class="hljs-keyword">return</span> (valueA === valueB);
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  }
                });
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                });
              }
            });
          },
          map: (maybeInstance) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              <span class="hljs-keyword">return</span> match(maybeInstance,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> maybe.unit(transform(value));
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> nothing(_);
                }
              });
            };
          }
        };
        <span class="hljs-comment">/* #@range_end(maybe_monad_helper) */</span>
        it(<span class="hljs-string">"map id == id"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(maybe_monad_test) */</span>
          <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
          expect(
            MAYBE.isEqual(MAYBE.map(justOne)(id),
                          id(justOne))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          expect(
            MAYBE.isEqual(MAYBE.map(nothing())(id),
                          id(nothing()))
          ).to.be(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-comment">/* #@range_end(maybe_monad_test) */</span>
          next();
        });
        it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(maybe_monad_add_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>足し算を定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
            <span class="hljs-keyword">return</span> MAYBE.flatMap(maybeA)((a) =&gt; {
              <span class="hljs-keyword">return</span> MAYBE.flatMap(maybeB)((b) =&gt; {
                <span class="hljs-keyword">return</span> MAYBE.unit(a + b);
              });
            });
          };
          <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">var</span> justTwo = just(<span class="hljs-number">2</span>);
          expect(
            MAYBE.getOrElse(add(justOne,justOne))(<span class="hljs-literal">null</span>)
          ).to.eql(
            MAYBE.getOrElse(justTwo)(<span class="hljs-literal">null</span>)
          );
          expect(
            MAYBE.getOrElse(add(justOne,nothing()))(<span class="hljs-literal">null</span>)
          ).to.eql(
            <span class="hljs-literal">null</span>
          );
          <span class="hljs-comment">/* #@range_end(maybe_monad_add_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>expect(
  MAYBE.isEqual(add(justOne,justTwo),
                justThree)
).to.eql(
  true
);
expect(
  MAYBE.isEqual(add(justOne,nothing()),
                nothing())
).to.eql(
  true
);
expect(
  MAYBE.isEqual(add(justOne,nothing()),
                justThree)
).to.eql(
  false
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>it(“list(maybe)”, (next) =&gt; {
  /<em> #@range_begin(maybe_monad_list_test) </em>/
  var add = (maybeA,maybeB) =&gt; {
    return maybe.flatMap(maybeA)((a) =&gt; {
      return maybe.flatMap(maybeB)((b) =&gt; {
        return maybe.unit(a + b);
      });
    });
  };
  var sum = (alist) =&gt; {
    var sumHelper = (alist, accumulator) =&gt; {
      return match(list,{
        empty: () =&gt; {
          return accumulator;
        },
        cons: (head, tail) =&gt; {
          return maybe.flatMap(accumulator)((accumulatorValue) =&gt; {
            return maybe.flatMap(head)((headValue) =&gt; {
              return sumHelper(tail, maybe.unit(accumulatorValue + headValue));
            });
          });
        }
      });
    };
    return sumHelper(alist, li
  };
  var justOne = just(1);
  var justTwo = just(2);
  var justThree = just(3);
  expect(
    maybe.isEqual(add(justOne,justTwo))(justThree)
  ).to.eql(
    true
  );
  /<em> #@range_end(maybe_monad_list_test) </em>/
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      });
    });
    describe(<span class="hljs-string">'Listモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> list  = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data.call(list,pattern);
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (value, alist) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(value, alist);
          };
        },
        head: (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> head;
            }
          });
        },
        tail: (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> tail;
            }
          });
        },
        isEmpty: (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        <span class="hljs-comment">/* #@range_begin(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <h3 id="list-unit">list#unit</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(value, list.empty());
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
append [] ys = ys
append (x:xs) ys = x : (xs ++ ys)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        append: (xs) =&gt; {
          <span class="hljs-keyword">return</span> (ys) =&gt; {
            <span class="hljs-keyword">return</span> list.match(xs, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> ys;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> list.cons(head,list.append(tail)(ys)); 
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]
concat [] = []
concat (xs:xss) = xs ++ concat xss</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        concat: (list_of_list) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>return list.foldr(list_of_list)(list.empty())(list.append);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> list.match(list_of_list, {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> list.empty();
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> list.append(head)(list.concat(tail));
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUN[T-&gt;U] -&gt; LIST[U]
map [] _ = []
map (x:xs) f = f x : map xs f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        map: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> list.match(instanceM,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> list.empty();
              },
              cons: (head,tail) =&gt; {
                <span class="hljs-keyword">return</span> list.cons(transform(head),
                                 list.map(tail)(transform));
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">flatten</span> :: [[a]] -&gt; [a]
<span class="hljs-title">flatten</span> =  foldr (++) []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatten: (instanceMM) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>return list.foldr(list.join)(list.empty());</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> list.match(instanceMM,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> list.empty();
            },
            cons: (head,tail) =&gt; {
              <span class="hljs-keyword">return</span> list.append(head)(list.flatten(tail));
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">xs</span> &gt;&gt;= f = concat (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatMap: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; { <span class="hljs-comment">// FUN[T-&gt;LIST[T]]</span>
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> list.concat(list.map(instanceM)(transform));
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>flatMap xs f = concat (map f xs)
flatMap: (instanceM) =&gt; {
  return (transform) =&gt; { // FUN[T-&gt;LIST[T]]
    expect(transform).to.a(‘function’);
    return list.concat(list.map(instanceM)(transform));
  };
},
flatMap: (instanceM) =&gt; {
  return (transform) =&gt; { // FUN[T-&gt;LIST[T]]
    expect(transform).to.a(‘function’);
    var transformed = list.map(instanceM)(transform);
    return list.flatten(transformed);
    // return list.flatten(list.map(instanceM)(transform));
  };
},</p>
<h3 id="monad-list-flatmap">monad.list#flatMap</h3>
<p>flatMap: (instance) =&gt; {
  return (transform) =&gt; {
    expect(transform).to.a(‘function’);
    return list.join(list.map(instance)(transform));
  };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span>
        toArray: (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.foldr(alist)([])((item) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> [item].concat(accumulator);
            };
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUN[T -&gt; U -&gt; U] -&gt; T
foldr []     z _ = z
foldr (x:xs) z f = f x (foldr xs z f) </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        foldr: (alist) =&gt; {         <span class="hljs-comment">// alist:: LIST[T]</span>
          <span class="hljs-keyword">return</span> (accumulator) =&gt; { <span class="hljs-comment">// accumulator:: T</span>
            <span class="hljs-keyword">return</span> (glue) =&gt; {      <span class="hljs-comment">// glue:: FUN[T -&gt; U -&gt; U] </span>
              expect(glue).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> list.match(alist, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));;
                }
              });
            };
          };
        },
        <span class="hljs-comment">/* #@range_begin(list_monad_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]
map: (alist) =&gt; {
  return (transform) =&gt; {
    expect(transform).to.a(‘function’);
    return list.match(alist,{
      empty: (_) =&gt; {
        return list.empty();
      },
      cons: (head,tail) =&gt; {
        return list.cons(transform(head),list.map(tail)(transform));
      }
    });
  };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_end(list_monad_map) */</span>
      }; <span class="hljs-comment">// end of list</span>
      it(<span class="hljs-string">"'list#empty'"</span>, (next) =&gt; {
        list.match(list.empty,{
          empty: (_) =&gt; {
            expect(<span class="hljs-literal">true</span>).ok();
          },
          cons: (x,xs) =&gt; {
            expect().fail();
          }
        });
        next();
      });
      it(<span class="hljs-string">"'list#isEmpty'"</span>, (next) =&gt; {
        expect(
          list.isEmpty(list.empty())
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          list.isEmpty(list.cons(<span class="hljs-number">1</span>,list.empty()))
        ).to.eql(
          <span class="hljs-literal">false</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#cons'"</span>, (next) =&gt; {
        list.match(list.cons(<span class="hljs-number">1</span>,list.empty()),{
          empty: (_) =&gt; {
            expect().fail()
          },
          cons: (x,xs) =&gt; {
            expect(x).to.eql(<span class="hljs-number">1</span>)
          }
        });
        next();
      });
      it(<span class="hljs-string">"'list#head'"</span>, (next) =&gt; {
        expect(
          list.head(list.cons(<span class="hljs-number">1</span>,list.empty()))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#tail'"</span>, (next) =&gt; {
        expect(
          list.head(list.tail(list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#append'"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = list.append(list.cons(<span class="hljs-number">1</span>,list.empty()))(list.cons(<span class="hljs-number">2</span>,list.empty()));
        expect(
          list.head(theList)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          list.head(list.tail(theList))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          list.isEmpty(list.tail(list.tail(theList)))
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#concat'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>list = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> one_two = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()));
        <span class="hljs-keyword">var</span> three_four = list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()));

        <span class="hljs-keyword">var</span> list_of_list = list.cons(one_two,
                                     list.cons(three_four, list.empty()));</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>concated_list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> concated_list = list.concat(list_of_list);
        expect(
          list.toArray(concated_list)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
        );
        expect(
          list.head(concated_list)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          list.head(list.tail(concated_list))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          list.isEmpty(list.tail(list.tail(concated_list)))
        ).to.eql(
          <span class="hljs-literal">false</span>
        );
        next();
      });
      it(<span class="hljs-string">"'list#foldr'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)))
        expect(
          list.foldr(theList)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> accumulator + item;
            };
          })
        ).to.eql(
          <span class="hljs-number">10</span>
        )
        next();
      })
      it(<span class="hljs-string">"'list#toArray'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)))
        expect(
          list.toArray(theList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
        );
        next();
      });
      it(<span class="hljs-string">"'list#map'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)));
        expect(
          list.toArray(list.map(theList)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          }))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
        );
        next();
      });
      it(<span class="hljs-string">"'list#unit'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        expect(
          list.toArray(list.unit(<span class="hljs-number">1</span>))
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        expect(
          list.toArray(list.unit(<span class="hljs-literal">null</span>))
        ).to.eql(
          [<span class="hljs-literal">null</span>]
        );
        next();
      });
      it(<span class="hljs-string">"'list#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>, list.cons(<span class="hljs-number">3</span>, list.empty())));</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>var theList = list.append(list.unit(1))(list.append(list.unit(2))(list.unit(3)));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        expect(
          list.toArray(list.flatMap(theList)((item) =&gt; {
            <span class="hljs-keyword">return</span> list.append(list.unit(item))(list.unit(- item));
          }))
        ).to.eql(
          [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
        );
        next();
      });
      describe(<span class="hljs-string">"listモナドを活用する"</span>,() =&gt; {
        it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
          };
          <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
          expect(
            list.toArray(list.flatMap(theList)((item) =&gt; {
              <span class="hljs-keyword">if</span>(even(item)) {
                <span class="hljs-keyword">return</span> list.unit(item);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> list.empty();
              }
            }))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          next();
        });
        it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> theNumberList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()));
          <span class="hljs-keyword">var</span> theStringList = list.cons(<span class="hljs-string">"one"</span>,list.cons(<span class="hljs-string">"two"</span>,list.empty()));
          expect(
            list.toArray(list.flatMap(theNumberList)((n) =&gt; {
              <span class="hljs-keyword">return</span> list.flatMap(theStringList)((s) =&gt; {
                <span class="hljs-keyword">return</span> list.unit([n,s]);
              });
            }))
          ).to.eql(
            [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
          );
          next();
        });
        <span class="hljs-comment">/* #@range_begin(list_maybe) */</span>
        describe(<span class="hljs-string">"maybeと一緒に使う"</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>var maybe = {
  match: (data, pattern) =&gt; {
    return data.call(maybe,pattern);
  },
  just : (value) =&gt; {
    return (pattern) =&gt; {
      return pattern.just(value);
    };
  },
  nothing : (<em>) =&gt; {
    return (pattern) =&gt; {
      expect(pattern).not.to.be.a(‘null’);
      // console.log(pattern);
      return pattern.nothing(null);
    };
  },
  unit : (value) =&gt; {
    return maybe.just(value);
   // if(value !== false &amp;&amp; value != null){
   //    return maybe.just(value);
   //  } else {
   //    return maybe.nothing(null);
   //  }
  },
  flatMap : (maybeInstance) =&gt; {
    return (transform) =&gt; {
      expect(transform).to.a(‘function’);
      return maybe.match(maybeInstance,{
        just: (value) =&gt; {
          return transform(value);
        },
        nothing: (</em>) =&gt; {
          return maybe.nothing(null);
        }
      });
    };
  },
  // map : (maybeInstance) =&gt; {
  //   return (transform) =&gt; {
  //     expect(transform).to.a(‘function’);
  //     return maybe.match(maybeInstance,{
  //       just: (value) =&gt; {
  //         return maybe.unit(transform(value));
  //         // return maybe.unit(transform(value));
  //       },
  //       nothing: (_) =&gt; {
  //         return maybe.nothing(null);
  //       }
  //     });
  //   };
  // }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> theList = list.cons(maybe.just(<span class="hljs-number">1</span>),
                                    list.empty());
            <span class="hljs-keyword">var</span> justList = list.flatMap(theList)((maybeItem) =&gt; {
              <span class="hljs-keyword">return</span> maybe.flatMap(maybeItem)((value) =&gt; {
                <span class="hljs-keyword">return</span> list.unit(value);
              });
            });
            expect(
              list.toArray(justList)
            ).to.eql(
              [<span class="hljs-number">1</span>]
            );
            next();
          });
          it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> theList = list.cons(maybe.just(<span class="hljs-number">1</span>),
                                    list.cons(maybe.just(<span class="hljs-number">2</span>),list.empty()));
            <span class="hljs-keyword">var</span> justList = list.flatMap(theList)((listItem) =&gt; {
              <span class="hljs-keyword">return</span> maybe.flatMap(listItem)((value) =&gt; {
                <span class="hljs-keyword">return</span> list.unit(value);
              });
            });
            expect(
              list.toArray(justList)
            ).to.eql(
              [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
            );
            next();
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(null),
                          list.empty());
  var justList = list.flatMap(theList)((listItem) =&gt; {
    return maybe.flatMap(listItem)((value) =&gt; {
      return list.unit(value);
      // return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
        });
      });
    });
    describe(<span class="hljs-string">'Treeモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> tree  = {
        match: (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data.call(tree,pattern);
        },
        leaf: (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.leaf(value);
          };
        },
        node: (treeL, treeR) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.node(treeL, treeR);
          };
        },
        unit: (value) =&gt; {
          <span class="hljs-keyword">return</span> tree.leaf(value);
        },
        flatMap: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> tree.match(instanceM,{
              leaf: (value) =&gt; {
                <span class="hljs-keyword">return</span> transform(value);
              },
              node: (treeL, treeR) =&gt; {
                <span class="hljs-keyword">return</span> tree.node(tree.flatMap(treeL)(transform),
                                 tree.flatMap(treeL)(transform));
              }
            }); 
          };
        },
        map: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> tree.match(instanceM,{
              leaf: (value) =&gt; {
                <span class="hljs-keyword">return</span> tree.leaf(transform(value));
              },
              node: (treeL, treeR) =&gt; {
                <span class="hljs-keyword">return</span> tree.node(tree.map(treeL)(transform),
                                 tree.map(treeL)(transform));
              }
            }); 
          };
        }
      };
    });
    describe(<span class="hljs-string">'Streamモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
        <span class="hljs-keyword">return</span> data(pattern);
      };
      <span class="hljs-keyword">var</span> maybe = {
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.just(value);
          };
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.nothing(_);
          };
        },
        unit: (value) =&gt; {
          <span class="hljs-keyword">if</span>(value){
            <span class="hljs-keyword">return</span> self.maybe.just(value);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.maybe.nothing(<span class="hljs-literal">null</span>);
          }
        },
        get: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> match(maybe,{
            just: (value) =&gt; {
              <span class="hljs-keyword">return</span> value;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
          });
        },
        isEqual: (maybeA) =&gt; {
          <span class="hljs-keyword">return</span> (maybeB) =&gt; {
            <span class="hljs-keyword">return</span> match(maybeA,{
              just: (valueA) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (valueB) =&gt; {
                    <span class="hljs-keyword">return</span> (valueA === valueB);
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  }
                });
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> match(maybeB,{
                  just: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                  },
                  nothing: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                });
              }
            });
          };
        },
        map: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> unit(transform(value));
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing();
              }
            });
          };
        },
        flatMap: (maybe) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            expect(transform).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> transform(value);
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> nothing();
              }
            });
          };
        }
      }; <span class="hljs-comment">// end of maybe</span>
      <span class="hljs-comment">/* #@range_begin(stream_monad_definition) */</span>
      <span class="hljs-keyword">var</span> stream = {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (head,tailThunk) =&gt; {
          expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            expect(pattern).to.an(<span class="hljs-string">'object'</span>);
            <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        head: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> maybe.nothing();
            },
            cons: (value, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> maybe.just(value);
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tail: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> maybe.nothing();
            },
            cons: (head, tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> maybe.just(tailThunk());
            }
          });
        },
        isEmpty: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        toArray: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> [];
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">if</span>(stream.isEmpty(tailThunk())){
                <span class="hljs-keyword">return</span> [head];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
              }
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <h3 id="stream-unit">stream#unit</h3>
<p>unit:: ANY -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unit: (value) =&gt; {
          <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
            <span class="hljs-keyword">return</span> stream.cons(value, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.empty();
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <h3 id="stream-map">stream#map</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        map: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform)});
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <h2 id="stream-append">stream#append</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        append: (xs) =&gt; {
          <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
            <span class="hljs-keyword">return</span> match(xs,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> ysThunk();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.append(tailThunk())(ysThunk);
                });
              }
            });
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <h2 id="stream-concat">stream#concat</h2>
<p>concat:: STREAM[STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        concat: (astream) =&gt; {
          <span class="hljs-keyword">return</span> match(astream,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> stream.append(head,tailThunk());
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatten: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> match(lazyList,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            },
            cons: (head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> stream.append(head)((_) =&gt; {
                <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
              });
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <h3 id="stream-flatmap">stream#flatMap</h3>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>
<p>flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flatMap: (lazyList) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> stream.flatten(stream.map(lazyList)(transform));
          };
        }
      };
      <span class="hljs-comment">/* #@range_end(stream_monad_definition) */</span>
      it(<span class="hljs-string">"stream#unit"</span>, (next) =&gt; {
        match(maybe.nothing(<span class="hljs-literal">null</span>),{
          nothing: (_) =&gt; {
            <span class="hljs-keyword">return</span> expect(
              _
            ).to.eql(
              <span class="hljs-literal">null</span>
            );
          },
          just: (value) =&gt; {
            <span class="hljs-keyword">return</span> expect().fail()
          }
        });
        <span class="hljs-keyword">var</span> lazyList = stream.unit(<span class="hljs-number">1</span>);
        expect(
          maybe.get(stream.head(lazyList))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(stream.unit(<span class="hljs-number">1</span>)))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(stream.unit(<span class="hljs-number">0</span>)))
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        expect(
          maybe.get(stream.head(lazyList))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });
        expect(
          stream.tail(lazyList)
        ).to.a(<span class="hljs-string">"function"</span>);

        match(stream.tail(lazyList),{
          nothing: (_) =&gt; {
            expect().fail();
          },
          just: (tail) =&gt; {
            match(tail,{
              empty: (_) =&gt; {
                expect().fail();
              },
              cons: (head, tailThunk) =&gt; {
                expect(head).to.eql(<span class="hljs-number">2</span>);
              }
            });
          }
        });
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(lazyList))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#toArray"</span>, (next) =&gt; {
        expect(
          stream.toArray(stream.empty())
        ).to.eql(
          []
        );
        expect(
          stream.toArray(stream.unit(<span class="hljs-number">1</span>))
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        next();
      });
      it(<span class="hljs-string">"stream#append"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> xs = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
        <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        };
        <span class="hljs-keyword">var</span> theStream = stream.append(xs)(ysThunk);
        expect(
          maybe.get(stream.head(theStream))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(theStream))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"stream#flatten"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>innerStream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> innerStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>outerStream = [[1,2]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> outerStream = stream.unit(innerStream);
        <span class="hljs-keyword">var</span> flattenedStream = stream.flatten(outerStream);
        match(flattenedStream,{
          empty: (_) =&gt; {
            expect().fail()
          },
          cons: (head,tailThunk) =&gt; {
            expect(head).to.eql(<span class="hljs-number">1</span>)
          }
        });
        expect(
          maybe.get(stream.head(flattenedStream))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          maybe.get(stream.head(maybe.get(stream.tail(flattenedStream))))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      describe(<span class="hljs-string">"stream#map"</span>, () =&gt; {
        it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> doubledLazyList = stream.map(lazyList)((item) =&gt; {
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(doubledLazyList))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledLazyList))))
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          expect(
            stream.toArray(doubledLazyList)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          next();
        });
        it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(ones_infinite_sequence) */</span>
          <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          expect(
            maybe.get(stream.head(ones))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(ones))))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-comment">/* #@range_end(ones_infinite_sequence) */</span>
          <span class="hljs-keyword">var</span> twoes = stream.map(ones)((item) =&gt; {
            <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(twoes))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(twoes))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(maybe.get(stream.tail(twoes))))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
              <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
            });
          };
          expect(
            maybe.get(stream.head(integersFrom(<span class="hljs-number">0</span>)))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-keyword">var</span> doubledIntergerMapped = stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
            <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
          });
          expect(
            maybe.get(stream.head(doubledIntergerMapped))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledIntergerMapped))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-keyword">var</span> doubledInterger = stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
            <span class="hljs-keyword">return</span> stream.unit(integer * <span class="hljs-number">2</span>);
          });
          expect(
            maybe.get(stream.head(doubledInterger))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(doubledInterger))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> ones;
          });
          <span class="hljs-keyword">var</span> twoes = stream.flatMap(ones)((one) =&gt; {
            expect(one).to.a(<span class="hljs-string">'number'</span>);
            <span class="hljs-keyword">return</span> stream.unit(one * <span class="hljs-number">2</span>);
          });
          expect(
            maybe.get(stream.head(twoes))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {
          <span class="hljs-comment">/*
            scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))
            scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))
            res0: List[Int] = List(2, 4, 6, 8)
          */</span>
          <span class="hljs-keyword">var</span> innerStream12 = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> innerStream34 = stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>nestedStream = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> nestedStream = stream.cons(innerStream12, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(innerStream34,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          <span class="hljs-keyword">var</span> flattenedStream = stream.flatMap(nestedStream)((innerStream) =&gt; {
            <span class="hljs-keyword">return</span> stream.flatMap(innerStream)((n) =&gt; {
              expect(n).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">return</span> stream.unit(n * <span class="hljs-number">2</span>);
            });
          });
          expect(
            maybe.get(stream.head(flattenedStream))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            stream.toArray(flattenedStream)
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
          );
          next();
        });

      });
    }); <span class="hljs-comment">// streamモナド</span>
    describe(<span class="hljs-string">'Consoleモナド'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>unit:: A -&gt; IO A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> unit = (any) =&gt; {
        <span class="hljs-keyword">return</span> (_) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>flatMap:: IO a -&gt; (a -&gt; IO b) -&gt; IO b</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> flatMap = (instanceA) =&gt; {
        <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO b</span>
          <span class="hljs-keyword">return</span> unit(run(actionAB(run(instanceA))));
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>run:: IO A -&gt; A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> run = (instance) =&gt; {
        <span class="hljs-keyword">return</span> instance();
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>      expect(run(unit(<span class="hljs-number">1</span>))).to.eql(<span class="hljs-number">1</span>);
    });
    describe(<span class="hljs-string">'IOモナド'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>describe(‘IOモナド(world)’, () =&gt; {
  var fs = require(‘fs’);
  // ## ‘IO’ monad module
  var IO = {
    // unit:: a -&gt; IO[a]
    unit : (any) =&gt; {
      return (world) =&gt;  {  // 現在の外界
        return pair.cons(any, world);
      };
    },
    // run:: IO[A] -&gt; A
    run : (instance) =&gt; {
      return (world) =&gt; {
        return instance(world); // IOモナドのインスタンス(アクション)を現在の外界に適用する
      };
    },
    // flatMap:: IO a -&gt; (a -&gt; IO b) -&gt; IO b
    // flatMap f g = \world -&gt;
    //                  case f world of
    //                  (v, world’) -&gt; g v world’
    flatMap : (instanceA) =&gt; {
      return (actionAB) =&gt; { // actionAB:: a -&gt; IO b
        return (world) =&gt; {
          return pair.match(IO.run(instanceA)(world))({
            cons: (value, newWorld) =&gt; {
              return IO.run(actionAB(value))(newWorld);
            }
          });
        };
      };
    },
    readFile : (path) =&gt; {
      return (io) =&gt; {
        var content = fs.readFileSync(path, ‘utf8’);
        return content;
      };
    },
    writeFile : (content) =&gt; {
      return (io) =&gt; {
        console.log(content);
        return null;
      }
    },
    println : (message) =&gt; {
      return (io) =&gt; {
        console.log(message);
        return null;
      };
    }
  }; 
}); // IO monad with world </p>

            </div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>match : (data, pattern) =&gt; {
  return data.call(pair, pattern);
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(pair_datatype) */</span>
      <span class="hljs-keyword">var</span> pair = {</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>pair のデータ構造</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cons: (left, right) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(left, right);
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>ペアの右側を取得する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        right: (tuple) =&gt; {
          <span class="hljs-keyword">return</span> match(tuple, {
            cons: (left, right) =&gt; {
              <span class="hljs-keyword">return</span> right;
            }
          });
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>ペアの左側を取得する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        left: (tuple) =&gt; {
          <span class="hljs-keyword">return</span> match(tuple, {
            cons: (left, right) =&gt; {
              <span class="hljs-keyword">return</span> left;
            }
          });
        }
      };
      <span class="hljs-comment">/* #@range_end(pair_datatype) */</span>
      describe(<span class="hljs-string">'外界を引数に持つIOモナド'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> IO = {
          <span class="hljs-comment">/* #@range_begin(io_monad_definition_with_world) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>unit:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit: (any) =&gt; {
            <span class="hljs-keyword">return</span> (world) =&gt;  {  <span class="hljs-comment">// worldは現在の外界</span>
              <span class="hljs-keyword">return</span> pair.cons(any, world);
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatMap: (instanceA) =&gt; {
            <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: FUN[T =&gt; IO[U]]</span>
              <span class="hljs-keyword">return</span> (world) =&gt; {
                <span class="hljs-keyword">var</span> newPair = instanceA(world); <span class="hljs-comment">// 現在の外界のなかで instanceAのIOアクションを実行する</span>
                <span class="hljs-keyword">return</span> pair.match(newPair,{
                  cons: (value, newWorld) =&gt; {
                    <span class="hljs-keyword">return</span> actionAB(value)(newWorld); <span class="hljs-comment">// 新しい外界のなかで、actionAB(value)で作られたIOアクションを実行する</span>
                  }
                });
              };
            };
          },
          <span class="hljs-comment">/* #@range_end(io_monad_definition_with_world) */</span>
          <span class="hljs-comment">/* #@range_begin(io_monad_definition_with_world_helper_function) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>done:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          done: (any) =&gt; {
            <span class="hljs-keyword">return</span> IO.unit();
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>run:: IO[A] =&gt; A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          run: (instance) =&gt; {
            <span class="hljs-keyword">return</span> (world) =&gt; {
              <span class="hljs-keyword">var</span> newPair = instance(world); <span class="hljs-comment">// IOモナドのインスタンス(アクション)を現在の外界に適用する</span>
              <span class="hljs-keyword">return</span> pair.left(newPair);     <span class="hljs-comment">// 結果だけを返す</span>
            };
          }
          <span class="hljs-comment">/* #@range_end(io_monad_definition_with_world_helper_function) */</span>
        }; <span class="hljs-comment">// IO monad</span>
        <span class="hljs-keyword">var</span> println = (message) =&gt; {
          <span class="hljs-keyword">return</span> (world) =&gt; { <span class="hljs-comment">// IOモナドを返す</span>
            <span class="hljs-built_in">console</span>.log(message);
            <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(world);
          };
        };
        <span class="hljs-comment">/* #@range_begin(run_println) */</span>
        <span class="hljs-keyword">var</span> initialWorld = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初期の外界に null をバインドする</span>
        expect(
          IO.run(println(<span class="hljs-string">"this is a test"</span>))(initialWorld)
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        <span class="hljs-comment">/* #@range_end(run_println) */</span>
      });
      describe(<span class="hljs-string">'外界を引数に持たないIOモナド'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <h2 id="-io-monad-module">‘IO’ monad module</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(io_monad_definition) */</span>
        <span class="hljs-keyword">var</span> IO = {</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>unit:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit : (any) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界は明示する必要はありません</span>
              <span class="hljs-keyword">return</span> any;
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatMap : (instanceA) =&gt; {
            <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
              <span class="hljs-keyword">return</span> IO.unit(IO.run(actionAB(IO.run(instanceA))));
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>done:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          done : (any) =&gt; {
            <span class="hljs-keyword">return</span> IO.unit();
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>run:: IO[A] =&gt; A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          run : (instance) =&gt; {
            <span class="hljs-keyword">return</span> instance();
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>readFile:: STRING =&gt; IO[STRING]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          readFile : (path) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
              <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
              <span class="hljs-keyword">return</span> IO.unit(content)();
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>println:: STRING =&gt; IO[null]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          println : (message) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-built_in">console</span>.log(message);
              <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)();
            };
          },
          writeFile : (path) =&gt; {
            <span class="hljs-keyword">return</span> (content) =&gt; {
              <span class="hljs-keyword">return</span> (_) =&gt; {
                <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
                fs.writeFileSync(path,content);
                <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)();
              };
            };
          }
        }; <span class="hljs-comment">// IO monad</span>
        <span class="hljs-comment">/* #@range_end(io_monad_definition) */</span>
        it(<span class="hljs-string">'IO.println'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(run_println_without_world) */</span>
          expect(
            IO.run(IO.println(<span class="hljs-string">"this is another test"</span>)) <span class="hljs-comment">// 外界を指定する必要はありません</span>
          ).to.eql(
            <span class="hljs-literal">null</span>
          );
          <span class="hljs-comment">/* #@range_end(run_println_without_world) */</span>
          next();
        });
        it(<span class="hljs-string">'IOモナドは合成可能である'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(io_monad_is_composable) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          IO.seq = (instanceA) =&gt; {
            <span class="hljs-keyword">return</span> (instanceB) =&gt; {
              <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
                <span class="hljs-keyword">return</span> instanceB;
              });
            };
          };
          IO.seqs = (alist) =&gt; {
            <span class="hljs-keyword">return</span> list.foldr(alist)(list.empty())(IO.done());
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>IO.putc:: CHAR =&gt; IO[]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          IO.putc = (character) =&gt; {
            <span class="hljs-keyword">return</span> (io) =&gt; {
              process.stdout.write(character);
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            };
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>IO.puts:: LIST[CHAR] =&gt; IO[]</p>
<pre><code class="lang-haskell"><span class="hljs-title">puts</span> list = seqs (map putc list)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>          IO.puts = (alist) =&gt; {
            <span class="hljs-keyword">return</span> match(alist, {
              empty: () =&gt; {
                <span class="hljs-keyword">return</span> IO.done();
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
              }
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>IO.getc :: IO[CHAR]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          IO.getc =  () =&gt; {
            <span class="hljs-keyword">var</span> continuation = () =&gt; {
              <span class="hljs-keyword">var</span> chunk = process.stdin.read();
              <span class="hljs-keyword">return</span> chunk;
            }; 
            process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
            <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
          };
          <span class="hljs-comment">/* #@range_end(io_monad_is_composable) */</span>
          
          next();
        });
        it(<span class="hljs-string">'IOモナドで参照透過性を確保する'</span>, (next) =&gt; {
          expect(
            IO.flatMap(IO.readFile(<span class="hljs-string">"./test/resources/file.txt"</span>))((content) =&gt; {
              <span class="hljs-keyword">return</span> IO.flatMap(IO.println(content))((_) =&gt; {
                <span class="hljs-keyword">return</span> IO.done(_);
              });
            })()
          ).to.eql(
            IO.flatMap(IO.readFile(<span class="hljs-string">"./test/resources/file.txt"</span>))((content) =&gt; {
              <span class="hljs-keyword">return</span> IO.flatMap(IO.println(content))((_) =&gt; {
                <span class="hljs-keyword">return</span> IO.done(_);
              });
            })()
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>var path = “./test/resources/file.txt”;
expect(
  IO.flatMap(IO.writeFile(path)(“test output”))((content) =&gt; {
    return IO.flatMap(IO.readFile(path))((content) =&gt; {
      return IO.done(<em>);
    });
  })()
).to.eql(
  IO.flatMap(IO.readFile(“./test/resources/file.txt”))((content) =&gt; {
    return IO.flatMap(IO.println(content))((</em>) =&gt; {
      return IO.done(_);
    });
  })()
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
      }); <span class="hljs-comment">// IOモナド</span>
    }); <span class="hljs-comment">// IOモナド</span></pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>describe(“Variantモナド”, () =&gt; {
  var variant = {
    unit: (value, key) =&gt; {
      return (pattern) =&gt; {
        return pattern<a href="value">key</a>;
      };
    },
    flatMap: (instance) =&gt; {
      return (transform) =&gt; {
        return instance(transform);
      };
    },
    match: (instance, pattern) =&gt; {
      return flip(variant.flatMap)(pattern)(instance);
    }
  };
  it(“Maybe”, (next) =&gt; {
    var just = (value) =&gt; {
      return variant.unit(value, ‘just’);
    }; 
    var nothing = (<em>) =&gt; {
      return variant.unit(null, ‘nothing’);
    }; 
    var isEqual = (maybeA) =&gt; {
      return (maybeB) =&gt; {
        return variant.match(maybeA,{
          just: (valueA) =&gt; {
            return variant.match(maybeB,{
              just: (valueB) =&gt; {
                return (valueA === valueB);
              },
              nothing: (</em>) =&gt; {
                return false;
              }
            });
          },
          nothing: (<em>) =&gt; {
            return variant.match(maybeB,{
              just: (</em>) =&gt; {
                return false;
              },
              nothing: (_) =&gt; {
                return true;
              }
            });
          }
        });
      };
    };
    var add = (maybeA,maybeB) =&gt; {
      return variant.flatMap(maybeA)((a) =&gt; {
        return variant.flatMap(maybeB)((b) =&gt; {
          return variant.unit(a + b);
        });
      });
    };
    var justOne = just(1);
    var justTwo = just(2);
    var justThree = just(3);
    expect(
      isEqual(add(justOne,justTwo))(justThree)
    ).to.eql(
      true
    );
    next();
  });
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  }); <span class="hljs-comment">// モナド</span>
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
