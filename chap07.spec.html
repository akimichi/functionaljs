<!DOCTYPE html>

<html>
<head>
  <title>chap07.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <!-- <script type="text/x-mathjax-config"> -->
  <!--   MathJax.Hub.Config({ -->
  <!--   tex2jax: { -->
  <!--       inlineMath: [ ['$','$'], ['\\(','\\)'] ], -->
  <!--       displayMath: [ ['$$','$$'], ["\\[","\\]"] ], -->
  <!--       processEscapes: true -->
  <!--   } -->
  <!--   }); -->
  <!-- </script> -->
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap07.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-7-">第7章 高階関数を活用する</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="-">小目次</h2>
<div class="toc">
<ul class="toc">
  <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#currying">7.2 カリー化で関数を渡す</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#combinator">7.3 コンビネータで関数を組み合わせる</a>
    <ul>
      <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#combinator-creation">コンビネータの作り方</a></li>
      <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#composing-function">関数を合成する</a></li></ul>
  </li>
  <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#closure">7.4 クロージャーを使う</a>
     <ul>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#mechanism-of-closure">クロージャーの仕組み</a></li>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#encapsulation-with-closure">クロージャーで状態をカプセル化する</a></li>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#pure-closure">クロージャーの純粋性</a></li></ul>
  </li>
  <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#passing-function">7.5 関数を渡す</a>
     <ul>
        <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#callback">コールバックで処理をモジュール化する</a></li>
        <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#folding">畳み込み関数に関数を渡す</a></li>
        <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#asynchronous">非同期処理にコールバック関数を渡す</a></li>
        <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#continuation">継続で未来を渡す</a></li></ul>
  </li>
  <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#monad">7.6 モナドを作る</a>
    <ul>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#identity-monad">恒等モナド</a></li>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#maybe-monad">Maybeモナドでエラーを処理する</a></li>
       <li><a href="http://akimichi.github.io/functionaljs/chap07.spec.html#io-monad">IOモナドで副作用を閉じ込める</a></li></ul>
  </li>
</ul>
</div>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>テストで利用されるlistモジュールとstreamモジュールを定義しておく</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>listモジュール</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> list  = {
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(list, pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },
  <span class="hljs-comment">/* append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T] */</span>
  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> list.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(head, list.append(tail)(ys)); 
        }
      });
    };
  },
  <span class="hljs-comment">/* map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T] */</span>
  map: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> list.match(alist,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> list.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(transform(head),list.map(tail)(transform));
        }
      });
    };
  },
  reverse: (alist) =&gt; {
    <span class="hljs-keyword">var</span> reverseAux = (alist, accumulator) =&gt; {
      <span class="hljs-keyword">return</span> list.match(alist, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> reverseAux(tail, list.cons(head, accumulator));
        }
      });
    };
    <span class="hljs-keyword">return</span> reverseAux(alist, list.empty());
  },
  toArray: (alist) =&gt; {
    <span class="hljs-keyword">var</span> toArrayAux = (alist,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> list.match(alist, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayAux(alist, []);
  },
  fromArray: (array) =&gt; {
    expect(array).to.an(<span class="hljs-string">'array'</span>);
    <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
      <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item, list.empty()));
    }, list.empty());
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>streamモジュール</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> stream = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(stream, pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },
  <span class="hljs-comment">/* head:: STREAM -&gt; MAYBE[STREAM] */</span>
  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> value;
      }
    });
  },
  <span class="hljs-comment">/* tail:: STREAM -&gt; MAYBE[STREAM] */</span>
  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> tailThunk();
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },
  <span class="hljs-comment">/* take:: STREAM -&gt; NUMBER -&gt; STREAM */</span>
  take: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (number) =&gt; {
      expect(number).to.a(<span class="hljs-string">'number'</span>);
      expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> stream.match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> stream.empty();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.take(tailThunk())(number -<span class="hljs-number">1</span>);
            });
          }
        }
      });
    };
  },
  enumFrom: (from) =&gt; {
    <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.enumFrom(from + <span class="hljs-number">1</span>);
    });
  },
  forAll: (astream) =&gt; {
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      <span class="hljs-keyword">var</span> forAllHelper = (astream) =&gt; {
        <span class="hljs-keyword">return</span> stream.match(astream,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> predicate(head) &amp;&amp; forAllHelper(tailThunk());
          }
        });
      };
      <span class="hljs-keyword">return</span> stream.match(astream,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 空のストリームの場合は、必ず false が返る</span>
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> forAllHelper(astream);   
        }
      });
    };
  }
}; <span class="hljs-comment">// end of 'stream' module</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="7-2-section-id-currying-section-">7.2 <section id='currying'>カリー化で関数を渡す</section></h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'カリー化で関数を渡す'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><strong>リスト7.1</strong> multipleOf関数の定義</p>
<blockquote>
<p>multipleOf関数は、multipleOf(n,m)でnの倍数がmかどうかを判定する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'multipleOf関数の定義'</span>, (next) =&gt; {
    <span class="hljs-comment">/* #@range_begin(multipleOf_uncurried) */</span>
    <span class="hljs-keyword">var</span> multipleOf = (n,m) =&gt; {
      <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) { <span class="hljs-comment">/* m / n の余りが 0 かどうか */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    };
    <span class="hljs-comment">/* #@range_end(multipleOf_uncurried) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><strong>リスト7.2</strong> multipleOf関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(multipleOf_uncurried_test) */</span>
    expect(
      multipleOf(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)     <span class="hljs-comment">/* 4は、2の倍数である */</span>
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-comment">/* #@range_end(multipleOf_uncurried_test) */</span>
    expect(
      multipleOf(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)     <span class="hljs-comment">/* 4は、3の倍数ではない */</span>
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><strong>リスト7.3</strong> カリー化されたmultipleOf関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'カリー化されたmultipleOf関数'</span>, (next) =&gt; {
    <span class="hljs-comment">/* #@range_begin(multipleOf_curried) */</span>
    <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; { <span class="hljs-comment">// 外側の関数定義</span>
      <span class="hljs-keyword">return</span> (m) =&gt; {         <span class="hljs-comment">// 内側の関数定義</span>
        <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
    };
    <span class="hljs-comment">/* #@range_end(multipleOf_curried) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><strong>リスト7.4</strong> カリー化されたmultipleOf関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(multipleOf_curried_test) */</span>
    expect(
      multipleOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)   <span class="hljs-comment">/* 関数適用を2回実行する */</span> 
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-comment">/* #@range_end(multipleOf_curried_test) */</span>
    expect(
      multipleOf(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)    <span class="hljs-comment">/* 4は、3の倍数ではない */</span>
    ).to.eql(
      <span class="hljs-literal">false</span>
    );</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><strong>リスト7.5</strong> multipleOf関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(multipleOf_curried_partilly_applied) */</span>
    <span class="hljs-keyword">var</span> twoFold = multipleOf(<span class="hljs-number">2</span>);
    expect(
      twoFold(<span class="hljs-number">4</span>)    <span class="hljs-comment">/* 4は、2の倍数である */</span>
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-comment">/* #@range_end(multipleOf_curried_partilly_applied) */</span>
    next();
  });
  it(<span class="hljs-string">'カリー化された指数関数'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><strong>リスト7.6</strong> 指数関数の例</p>
<blockquote>
<p>exponential関数は、exponential(b)(n)でbのn乗を計算する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(exponential_curried) */</span>
    <span class="hljs-keyword">var</span> exponential = (base) =&gt; {
      <span class="hljs-keyword">return</span> (index) =&gt; {
        <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> base * exponential(base)(index - <span class="hljs-number">1</span>);
        }
      };
    };
    <span class="hljs-comment">/****** テスト ******/</span>
    expect(
      exponential(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2の3乗を求める </span>
    ).to.eql(
      <span class="hljs-number">8</span>
    );
    <span class="hljs-comment">/* #@range_end(exponential_curried) */</span>
    expect(
      exponential(<span class="hljs-number">2</span>)(<span class="hljs-number">2</span>)
    ).to.eql(
      <span class="hljs-number">4</span>
    );</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><strong>リスト7.7</strong> flip関数の定義</p>
<blockquote>
<p>flip関数は、flip(fun)(x)(y)でfun(y)(x)を実行する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(flip_definition) */</span>
    <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
      <span class="hljs-keyword">return</span>  (x) =&gt; {
        <span class="hljs-keyword">return</span> (y) =&gt; {
          <span class="hljs-keyword">return</span> fun(y)(x); <span class="hljs-comment">// 適用する引数の順番を逆転させる</span>
        };
      };
    };
    <span class="hljs-comment">/* #@range_end(flip_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><strong>リスト7.8</strong> flip関数でexponential関数の引数の順番を変更する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(flipped_exponential) */</span>
    <span class="hljs-comment">/* flipで引数を逆転させて、2乗を定義する */</span>
    <span class="hljs-keyword">var</span> square = flip(exponential)(<span class="hljs-number">2</span>); 
    <span class="hljs-comment">/* flipで引数を逆転させて、3乗を定義する */</span>
    <span class="hljs-keyword">var</span> cube = flip(exponential)(<span class="hljs-number">3</span>);   
    <span class="hljs-comment">/* #@range_end(flipped_exponential) */</span>
    <span class="hljs-comment">/* #@range_begin(flipped_exponential_test) */</span>
    expect(
      square(<span class="hljs-number">2</span>)
    ).to.eql(
      <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * 2 = 4 */</span>
    );
    expect(
      cube(<span class="hljs-number">2</span>)
    ).to.eql(
      <span class="hljs-number">8</span> <span class="hljs-comment">/* 2 * 2 * 2 = 8 */</span>
    );
    <span class="hljs-comment">/* #@range_end(flipped_exponential_test) */</span>
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h3 id="-">コラム： チャーチ数</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'コラム： チャーチ数'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><strong>リスト7.9</strong> チャーチによる自然数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'チャーチによる自然数の定義'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(church_numeral) */</span>
      <span class="hljs-keyword">var</span> zero = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> x;           <span class="hljs-comment">// 関数を0回適用する</span>
        };
      };
      <span class="hljs-keyword">var</span> one = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(x);        <span class="hljs-comment">// 関数を1回適用する</span>
        };
      };
      <span class="hljs-keyword">var</span> two = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(f(x));     <span class="hljs-comment">// 関数を2回適用する</span>
        };
      };
      <span class="hljs-keyword">var</span> three = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(f(f(x)));  <span class="hljs-comment">// 関数を3回適用する</span>
        };
      };
      <span class="hljs-comment">/*#@range_end(church_numeral) */</span>
      <span class="hljs-keyword">var</span> add = (m) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> m(f)(n(f)(x));
            };
          };
        };
      };
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(n(f)(x));
          };
        };
      };
      <span class="hljs-keyword">var</span> counter = (init) =&gt; {
        <span class="hljs-keyword">var</span> _init = init;
        <span class="hljs-keyword">return</span> (_) =&gt; {
          _init = _init + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">return</span> _init;
        };
      };
      expect(one(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">1</span>);
      expect(two(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
      expect(three(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
      expect(succ(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
      expect(succ(two)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
      expect(add(zero)(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">1</span>);
      expect(add(one)(one)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">2</span>);
      expect(add(one)(two)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">3</span>);
      expect(add(two)(three)(counter(<span class="hljs-number">0</span>))()).to.eql(<span class="hljs-number">5</span>);
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="7-3-section-id-combinator-section-">7.3 <section id='combinator'>コンビネータで関数を組み合わせる</section></h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'コンビネータで関数を組み合わせる'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h3 id="-section-id-combinator-creation-section-"><section id='combinator-creation'>コンビネータの作り方</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'コンビネータの作り方'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><strong>リスト7.10</strong> multipleOf関数の再利用</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'multipleOf関数の再利用'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_begin(multipleOf_combinator) */</span>
      <span class="hljs-keyword">var</span> even = multipleOf(<span class="hljs-number">2</span>); <span class="hljs-comment">/* カリー化されたmultipleOf関数を使う */</span>
      
      expect(
        even(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(multipleOf_combinator) */</span>
      next();
    }); 
    describe(<span class="hljs-string">'論理コンビネータ'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-keyword">var</span> even = multipleOf(<span class="hljs-number">2</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p><strong>リスト7.13</strong> notコンビネータ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'notコンビネータ'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(not_combinator) */</span>
        <span class="hljs-comment">/* not:: FUN[NUM =&gt; BOOL] =&gt; FUN[NUM =&gt; BOOL] */</span>
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; { <span class="hljs-comment">// predicateの型はFUN[NUM =&gt; BOOL]</span>
          <span class="hljs-comment">/* 全体として、FUN[NUM =&gt; BOOL]型を返す */</span>
          <span class="hljs-keyword">return</span> (arg) =&gt; { <span class="hljs-comment">// argの型はNUM</span>
            <span class="hljs-keyword">return</span> ! predicate(arg); <span class="hljs-comment">// !演算子で論理を反転させて、BOOLを返す</span>
          };
        };
        <span class="hljs-comment">/* #@range_end(not_combinator) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><strong>リスト7.15</strong> notコンビネータによるodd関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(not_combinator_test) */</span>
        <span class="hljs-keyword">var</span> odd = not(even); <span class="hljs-comment">// notコンビネータでodd関数を定義する</span>
        <span class="hljs-comment">/******** テスト ********/</span>
        expect(
          odd(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3は奇数である</span>
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          odd(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2は奇数でない </span>
        ).to.eql(
          <span class="hljs-literal">false</span>
        );
        <span class="hljs-comment">/* #@range_end(not_combinator_test) */</span>
        next();
      });
      <span class="hljs-comment">/* 本書では割愛したが、論理和や論理積を実行するコンビネータも同様に定義できる */</span>
      it(<span class="hljs-string">'他の論理コンビネータ'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; { 
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> ! predicate(arg); 
          };
        };
        <span class="hljs-comment">/* 「もしくは」を表す論理和  */</span>
        <span class="hljs-comment">/* or:: (NUMBER-&gt;BOOL, NUMBER-&gt;BOOL) -&gt; (NUMBER-&gt;BOOL) */</span>
        <span class="hljs-keyword">var</span> or = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) || g(arg);
          };
        };
        <span class="hljs-comment">/* 「かつ」を表す論理積  */</span>
        <span class="hljs-comment">/* and:: (NUMBER-&gt;BOOL, NUMBER-&gt;BOOL) -&gt; (NUMBER-&gt;BOOL) */</span>
        <span class="hljs-keyword">var</span> and = (f,g) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> f(arg) &amp;&amp; g(arg);
          };
        };
        <span class="hljs-keyword">var</span> positive = (n) =&gt; {
          <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>;
        };
        <span class="hljs-keyword">var</span> zero = (n) =&gt; {
          <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span>;
        };
        <span class="hljs-comment">/* negativeは、0より小さな数値かどうかを判定する */</span>
        <span class="hljs-keyword">var</span> negative = and(not(positive), not(zero));
        expect(negative(-<span class="hljs-number">3</span>)).to.eql(<span class="hljs-literal">true</span>);
        expect(negative(<span class="hljs-number">3</span>)).to.eql(<span class="hljs-literal">false</span>);
        expect(negative(<span class="hljs-number">0</span>)).to.eql(<span class="hljs-literal">false</span>);
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3 id="-section-id-composing-function-section-"><section id='composing-function'>関数を合成する</section></h3>
<p>$$ 
   (f \circ g) x = f(g(x))
$$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'関数を合成する'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><strong>リスト7.16</strong> 関数合成の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(compose_definition) */</span>
    <span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
      <span class="hljs-keyword">return</span> (arg) =&gt; {
        <span class="hljs-keyword">return</span> f(g(arg));
      };
    };
    <span class="hljs-comment">/* #@range_end(compose_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><strong>リスト7.17</strong> 関数合成のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(compose_test) */</span>
    <span class="hljs-keyword">var</span> f = (x) =&gt; {
      <span class="hljs-keyword">return</span> x * x + <span class="hljs-number">1</span>; 
    };
    <span class="hljs-keyword">var</span> g = (x) =&gt; {
      <span class="hljs-keyword">return</span> x - <span class="hljs-number">2</span>;
    };
    expect(
      compose(f,g)(<span class="hljs-number">2</span>) <span class="hljs-comment">// f◦g で合成された関数</span>
    ).to.eql(
      f(g(<span class="hljs-number">2</span>))         <span class="hljs-comment">// 合成せずに順次実行した場合</span>
    );
    <span class="hljs-comment">/* #@range_end(compose_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4 id="-">関数合成の条件</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'関数合成の条件'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><strong>リスト7.18</strong> 反数関数の合成</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'反数関数の合成'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(composition_example_opposite_twice) */</span>
        <span class="hljs-comment">/* 反数の定義 */</span>
        <span class="hljs-keyword">var</span> opposite = (n) =&gt; { 
          <span class="hljs-keyword">return</span> - n;
        };
        expect(
          <span class="hljs-comment">/* 反数同士の合成は成功する */</span>
          compose(opposite,opposite)(<span class="hljs-number">2</span>) 
        ).to.eql(
          <span class="hljs-number">2</span> <span class="hljs-comment">// -(-2) === 2</span>
        );
        <span class="hljs-comment">/* #@range_end(composition_example_opposite_twice) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><strong>リスト7.20</strong> カリー化による合成</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'カリー化による合成'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_opposite_add_successful) */</span>
        <span class="hljs-keyword">var</span> opposite = (x) =&gt; {
          <span class="hljs-keyword">return</span> - x;
        };
        <span class="hljs-keyword">var</span> addCurried = (x) =&gt; { <span class="hljs-comment">// カリー化されたadd関数</span>
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
        };
        expect(
          compose(opposite,
                  addCurried(<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)
        ).to.eql(
          -<span class="hljs-number">5</span>
        );
        <span class="hljs-comment">/* #@range_end(compose_opposite_add_successful) */</span>
        next();
      });
    });
    <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
      <span class="hljs-keyword">return</span>  (f) =&gt; {
        <span class="hljs-keyword">return</span> (g) =&gt; {
          <span class="hljs-keyword">return</span> fun(g)(f);
        };
      };
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h4 id="-">関数合成による抽象化</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'関数合成による抽象化'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><strong>リスト7.21</strong> 具体的なlast関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'具体的なlast関数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_recursive) */</span>
        <span class="hljs-keyword">var</span> last = (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist, {
            empty: (_) =&gt; { <span class="hljs-comment">// alistが空の場合</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            cons: (head, tail) =&gt; { <span class="hljs-comment">// alistが空でない場合</span>
              <span class="hljs-keyword">return</span> list.match(tail, {
                empty: (_) =&gt; { <span class="hljs-comment">// alistの要素がただ1個の場合</span>
                  <span class="hljs-keyword">return</span> head;
                },
                cons: (_, __) =&gt; {
                  <span class="hljs-keyword">return</span> last(tail);
                }
              });
            }
          });
        };
        <span class="hljs-comment">/* #@range_end(list_last_recursive) */</span>
        <span class="hljs-keyword">var</span> aList = list.cons(<span class="hljs-number">1</span>,
                                list.cons(<span class="hljs-number">2</span>,
                                          list.cons(<span class="hljs-number">3</span>,
                                                    list.empty())));
        expect(
          last(aList)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong> リスト7.22</strong> 抽象的なlast関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'抽象的なlast関数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_last_compose) */</span>
        <span class="hljs-keyword">var</span> last = (alist) =&gt; {
          <span class="hljs-keyword">return</span> compose(list.head,
                         list.reverse)(alist);
        };
        <span class="hljs-comment">/* #@range_end(list_last_compose) */</span>
        <span class="hljs-keyword">var</span> sequence = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
        expect(
          last(sequence)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><strong>表7.1</strong> 関数合成による様々な関数定義</p>
<table>
<thead>
<tr>
<th style="text-align:left">関数名</th>
<th style="text-align:right">関数合成による定義</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:right">sum . map(alwaysOne)</td>
</tr>
<tr>
<td style="text-align:left">last</td>
<td style="text-align:right">head . reverse</td>
</tr>
<tr>
<td style="text-align:left">init</td>
<td style="text-align:right">reverse . tail . reverse</td>
</tr>
<tr>
<td style="text-align:left">all(predicate)</td>
<td style="text-align:right">and . map(predicate)</td>
</tr>
<tr>
<td style="text-align:left">any(predicate)</td>
<td style="text-align:right">or . map(predicate)</td>
</tr>
<tr>
<td style="text-align:left">none(predicate)</td>
<td style="text-align:right">and . map(not(predicate))</td>
</tr>
</tbody>
</table>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'関数合成による様々な関数定義'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> alwaysOne = (x) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        };
        <span class="hljs-keyword">var</span> alist = list.cons(<span class="hljs-number">1</span>,
                              list.cons(<span class="hljs-number">2</span>,
                                        list.cons(<span class="hljs-number">3</span>,
                                                  list.empty())));</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>length関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'length関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> alwaysOne = (x) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> sum = (alist) =&gt; {
            <span class="hljs-keyword">var</span> sumHelper = (alist, accumulator) =&gt; {
              <span class="hljs-keyword">return</span> list.match(alist,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> sumHelper(tail, accumulator + head);
                }
              });
            };
            <span class="hljs-keyword">return</span> sumHelper(alist,<span class="hljs-number">0</span>);
          };
          <span class="hljs-keyword">var</span> length = (alist) =&gt; {
            <span class="hljs-keyword">return</span> compose(sum,
                           flip(list.map)(alwaysOne))(alist);
          };
          <span class="hljs-comment">/****** テスト *******/</span>
          expect(
            length(alist)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>last関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'last関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> last = (alist) =&gt; {
            <span class="hljs-keyword">return</span> compose(list.head,
                           list.reverse)(alist);
          };
          expect(
            last(alist)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>init関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'init関数の義'</span>, (next) =&gt; {
          <span class="hljs-comment">/* init = reverse . tail . reverse  */</span>
          <span class="hljs-keyword">var</span> init = (alist) =&gt; {
            <span class="hljs-keyword">return</span> compose(list.reverse,
                           compose(list.tail,
                                   list.reverse)
                          )(alist);
          };
          <span class="hljs-comment">/****** テスト *******/</span>
          expect(
            list.toArray(init(alist))
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>all関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'all関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> and = (alist) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head &amp;&amp; and(tail);
              }
            });
          };
          <span class="hljs-keyword">var</span> all = (predicate) =&gt; {
            <span class="hljs-keyword">return</span> (alist) =&gt; {
              <span class="hljs-keyword">return</span> compose(and,
                             flip(list.map)(predicate))(alist);
            };
          };
          expect(
            all((x) =&gt; {
              <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span>;
            })(alist)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>any関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'any関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> or = (alist) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head || or(tail);
              }
            });
          };
          <span class="hljs-keyword">var</span> any = (predicate) =&gt; {
            <span class="hljs-keyword">return</span> (alist) =&gt; {
              <span class="hljs-keyword">return</span> compose(or,
                             flip(list.map)(predicate))(alist);
            };
          };
          expect(
            any((x) =&gt; {
              <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">2</span>;
            })(alist)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          expect(
            any((x) =&gt; {
              <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">1</span>;
            })(alist)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>none関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'none関数の定義'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> and = (alist) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head &amp;&amp; and(tail);
              }
            });
          };
          <span class="hljs-keyword">var</span> not = (predicate) =&gt; { <span class="hljs-comment">// predicate::FUN[NUM =&gt; BOOL]</span>
            <span class="hljs-keyword">return</span> (arg) =&gt; { <span class="hljs-comment">// FUN[NUM =&gt; BOOL]型を返す</span>
              <span class="hljs-keyword">return</span> ! predicate(arg); <span class="hljs-comment">// !演算子で論理を反転させる</span>
            };
          };
          <span class="hljs-keyword">var</span> none = (predicate) =&gt; {
            <span class="hljs-keyword">return</span> (alist) =&gt; {
              <span class="hljs-keyword">return</span> compose(and,
                             flip(list.map)(not(predicate)))(alist);
            };
          };
          expect(
            none((x) =&gt; {
              <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span>;
            })(alist)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          next();
        });
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h3 id="-y-">コラム: Yコンビネータ</h3>
<p><a href="https://www.youtube.com/watch?v=FITJMJjASUs" title="Ruby Conf 12 - Y Not- Adventures in Functional Programming by Jim Weirich"><img src="http://img.youtube.com/vi/FITJMJjASUs/0.jpg" alt="IMAGE ALT TEXT"></a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'Y combinator'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(Y_combinator) */</span>
      <span class="hljs-keyword">var</span> Y = (F) =&gt; {
        <span class="hljs-keyword">return</span> ((x) =&gt; {
          <span class="hljs-keyword">return</span> F((y) =&gt; {
            <span class="hljs-keyword">return</span> x(x)(y);
          }) ;
        })((x) =&gt;  {
          <span class="hljs-keyword">return</span> F((y) =&gt; {
            <span class="hljs-keyword">return</span> x(x)(y);
          }) ;
        });
      };
      <span class="hljs-comment">/* #@range_end(Y_combinator)  */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><strong>リスト7.24</strong> Yコンビネータによるfactorial関数の実装</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(Y_combinator_test) */</span>
      <span class="hljs-keyword">var</span> factorial = Y((fact) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);
          }
        };
      });
      expect(
        factorial(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 * 2 * 1 = 6</span>
      ).to.eql(
        <span class="hljs-number">6</span>
      );
      <span class="hljs-comment">/* #@range_end(Y_combinator_test) */</span>
      next();
    });
  }); <span class="hljs-comment">// 関数を合成する</span>
}); <span class="hljs-comment">// コンビネータ</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h2 id="-section-id-closure-7-4-section-"><section id='closure'>7.4 クロージャーを使う</section></h2>
<blockquote>
<p>参考資料: <a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3">Wikipediaでのクロージャーの解説</a></p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'クロージャーを使う'</span>, () =&gt; {
  <span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h3 id="-section-id-mechanism-of-closure-section-"><section id='mechanism-of-closure'>クロージャーの仕組み</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'クロージャーの仕組み'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p><strong>リスト7.25</strong> 環境における変数のバインディング</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'環境における変数のバインディング'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(variable_binding_in_environment) */</span>
      <span class="hljs-comment">/* 変数fooに数値1をバインドする */</span>
      <span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;
      <span class="hljs-comment">/* 変数bar に文字列 "a string" をバインドする */</span>
      <span class="hljs-keyword">var</span> bar = <span class="hljs-string">"a string"</span>; 
      <span class="hljs-comment">/* #@range_end(variable_binding_in_environment) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p><strong>リスト7.26</strong> 環境からバインディングを参照する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(variable_binding_in_environment_test) */</span>
      <span class="hljs-comment">/* 環境 &lt;foo |-&gt; 1, bar |-&gt; "a string"&gt; のもとで評価する */</span>
      expect(
        foo  <span class="hljs-comment">// 上記環境から変数fooの値を取り出す</span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(variable_binding_in_environment_test) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><strong>リスト7.27</strong> 部分適用と環境</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'部分適用と環境'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; { <span class="hljs-comment">// 外側の関数定義</span>
        <span class="hljs-keyword">return</span> (m) =&gt; {         <span class="hljs-comment">// 内側の関数定義</span>
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_begin(partial_application_with_environment) */</span>
      <span class="hljs-keyword">var</span> twoFold = multipleOf(<span class="hljs-number">2</span>);
      expect(
        twoFold(<span class="hljs-number">4</span>) 
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      <span class="hljs-comment">/* #@range_end(partial_application_with_environment) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h3 id="-section-id-encapsulation-with-closure-section-"><section id='encapsulation-with-closure'>クロージャーで状態をカプセル化する</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'クロージャーで状態をカプセル化する'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p><strong>リスト7.28</strong> クロージャーとしてのcounter関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'クロージャーとしてのcounter関数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(counter_as_closure) */</span>
        <span class="hljs-keyword">var</span> counter = (init) =&gt; {
          <span class="hljs-keyword">var</span> countingNumber =  init;
          <span class="hljs-comment">/* countingNumberの環境を持つクロージャーを返す */</span>
          <span class="hljs-keyword">return</span> (_) =&gt; {  
            countingNumber = countingNumber + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> countingNumber ;
          };
        };
        <span class="hljs-comment">/* #@range_end(counter_as_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><strong>リスト7.29</strong> counter関数の利用法</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(counter_as_closure_test) */</span>
        <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
        expect(
          counterFromZero() <span class="hljs-comment">// 1回目の実行</span>
        ).to.eql( 
          <span class="hljs-number">1</span>
        );
        expect(
          counterFromZero() <span class="hljs-comment">// 2回目の実行</span>
        ).to.eql( 
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(counter_as_closure_test) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h4 id="-">クロージャーで不変なデータ型を作る</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'クロージャーで不変なデータ型を作る'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p><strong>リスト7.31</strong> カリー化された不変なオブジェクト型</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'カリー化された不変なオブジェクト型'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(immutable_object_type_curried) */</span>
          <span class="hljs-keyword">var</span> object = {  <span class="hljs-comment">// objectモジュール</span>
            <span class="hljs-comment">/* empty:: STRING =&gt; Any */</span>
            empty: (key) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            <span class="hljs-comment">/* set:: (STRING,Any) =&gt; (STRING =&gt; Any) =&gt; STRING =&gt; Any */</span>
            set: (key, value) =&gt; {
              <span class="hljs-keyword">return</span> (obj) =&gt; {
                <span class="hljs-keyword">return</span> (queryKey) =&gt; {
                  <span class="hljs-keyword">if</span>(key === queryKey) {
                    <span class="hljs-keyword">return</span> value;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> object.get(queryKey)(obj);
                  }
                };
              };
            },
            <span class="hljs-comment">/* get:: (STRING) =&gt; (STRING =&gt; Any) =&gt; Any */</span>
            get: (key) =&gt; {
              <span class="hljs-keyword">return</span> (obj) =&gt; {
                <span class="hljs-keyword">return</span> obj(key);
              };
            }
          };
          <span class="hljs-comment">/* #@range_end(immutable_object_type_curried) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p><strong>リスト7.32</strong> カリー化された不変なオブジェクト型のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(immutable_object_type_curried_test) */</span>
          <span class="hljs-keyword">var</span> robots = compose( <span class="hljs-comment">// object.setを合成する</span>
            object.set(<span class="hljs-string">"C3PO"</span>, <span class="hljs-string">"Star Wars"</span>), <span class="hljs-comment">// (STRING =&gt; Any) =&gt; STRING =&gt; Any</span>
            object.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>) <span class="hljs-comment">// (STRING =&gt; Any) =&gt; STRING =&gt; Any</span>
          )(object.empty);
          <span class="hljs-comment">/* )(object.empty()); これは適切でない */</span>

          expect(
            object.get(<span class="hljs-string">"HAL9000"</span>)(robots)
          ).to.eql(
            <span class="hljs-string">"2001: a space odessay"</span>
          );
          expect(
            object.get(<span class="hljs-string">"C3PO"</span>)(robots)
          ).to.eql(
            <span class="hljs-string">"Star Wars"</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>該当するデータがなければ、nullが返る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            object.get(<span class="hljs-string">"鉄腕アトム"</span>)(robots)
          ).to.eql(
            <span class="hljs-literal">null</span> 
          );
          <span class="hljs-comment">/* #@range_end(immutable_object_type_curried_test) */</span>
          next();
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h4 id="-">クロージャーでジェネレーターを作る</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'クロージャーでジェネレーターを作る'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p><strong>リスト7.33</strong> ストリームからジェネレータを作る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        describe(<span class="hljs-string">'ストリームからジェネレータを作る'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(generator_from_stream) */</span>
          <span class="hljs-keyword">var</span> generate = (aStream) =&gt; {
            <span class="hljs-comment">/* いったんローカル変数にストリームを格納する */</span>
            <span class="hljs-keyword">var</span> _stream = aStream; 
            <span class="hljs-comment">/* ジェネレータ関数が返る */</span>
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.match(_stream, {
                empty: () =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                },
                cons: (head, tailThunk) =&gt; {
                  _stream = tailThunk();  <span class="hljs-comment">// ローカル変数を更新する</span>
                  <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// ストリームの先頭要素を返す</span>
                }
              });
            };
          };
          <span class="hljs-comment">/* #@range_end(generator_from_stream) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p><strong>リスト7.34</strong> 整数列のジェネレータ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          it(<span class="hljs-string">'整数列のジェネレータ'</span>,(next) =&gt; {
            <span class="hljs-keyword">var</span> enumFrom = (from) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
                <span class="hljs-keyword">return</span> enumFrom(from + <span class="hljs-number">1</span>);
              });
            };
            <span class="hljs-comment">/* #@range_begin(integer_generator) */</span>
            <span class="hljs-comment">/* 無限の整数列を生成する */</span>
            <span class="hljs-keyword">var</span> integers = enumFrom(<span class="hljs-number">0</span>);            
            <span class="hljs-comment">/* 無限ストリームからジェネレータを生成する */</span>
            <span class="hljs-keyword">var</span> intGenerator = generate(integers); 
            expect(intGenerator()).to.eql(
              <span class="hljs-number">0</span>
            );
            expect(intGenerator()).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(intGenerator()).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(integer_generator) */</span>
            next();
          });
          it(<span class="hljs-string">'無限の素数列を作る'</span>,(next) =&gt; {
            <span class="hljs-keyword">this</span>.timeout(<span class="hljs-number">4000</span>);

            <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt; {
                <span class="hljs-keyword">return</span> ! predicate(arg);
              };
            };

            <span class="hljs-keyword">var</span> stream = {
              match: (data, pattern) =&gt; {
                <span class="hljs-keyword">return</span> data.call(stream, pattern);
              },
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> (pattern) =&gt; {
                  expect(pattern).to.an(<span class="hljs-string">'object'</span>);
                  <span class="hljs-keyword">return</span> pattern.empty();
                };
              },
              cons: (head,tailThunk) =&gt; {
                expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">return</span> (pattern) =&gt; {
                  expect(pattern).to.an(<span class="hljs-string">'object'</span>);
                  <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
                };
              },
              head: (lazyList) =&gt; {
                <span class="hljs-keyword">return</span> stream.match(lazyList,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  },
                  cons: (value, tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> value;
                  }
                });
              },
              tail: (lazyList) =&gt; {
                <span class="hljs-keyword">return</span> stream.match(lazyList,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  },
                  cons: (head, tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> tailThunk();
                  }
                });
              },
              toArray: (lazyList) =&gt; {
                <span class="hljs-keyword">return</span> stream.match(lazyList,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> [];
                  },
                  cons: (head,tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> stream.match(tailThunk(),{
                      empty: (_) =&gt; {
                        <span class="hljs-keyword">return</span> [head];
                      },
                      cons: (head_,tailThunk_) =&gt; {
                        <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
                      }
                    });
                  }
                });
              },
              take: (lazyList) =&gt; {
                <span class="hljs-keyword">return</span> (number) =&gt; {
                  expect(number).to.a(<span class="hljs-string">'number'</span>);
                  expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
                  <span class="hljs-keyword">return</span> stream.match(lazyList,{
                    empty: (_) =&gt; {
                      <span class="hljs-keyword">return</span> stream.empty();
                    },
                    cons: (head,tailThunk) =&gt; {
                      <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> stream.empty();
                      } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                          <span class="hljs-keyword">return</span> stream.take(tailThunk())(number -<span class="hljs-number">1</span>);
                        });
                      }
                    }
                  });
                };
              },</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p><strong>リスト7.35</strong> ストリームのfilter関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-comment">/* #@range_begin(stream_filter) */</span>
              <span class="hljs-comment">/* filter:: FUN[T =&gt; BOOL] =&gt; STREAM[T] =&gt; STREAM[T] */</span>
              filter: (predicate) =&gt; {
                <span class="hljs-keyword">return</span> (aStream) =&gt; {
                  <span class="hljs-keyword">return</span> stream.match(aStream,{
                    empty: (_) =&gt; {
                      <span class="hljs-keyword">return</span> stream.empty();
                    },
                    cons: (head,tailThunk) =&gt; {
                      <span class="hljs-keyword">if</span>(predicate(head)){ <span class="hljs-comment">// 条件に合致する場合</span>
                        <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                          <span class="hljs-keyword">return</span> stream.filter(predicate)(tailThunk());
                        });
                      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 条件に合致しない場合</span>
                        <span class="hljs-keyword">return</span> stream.filter(predicate)(tailThunk());
                      }
                    }
                  });
                };
              },
              <span class="hljs-comment">/* #@range_end(stream_filter) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p><strong>リスト7.36</strong> ストリームのremove関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-comment">/* #@range_begin(stream_remove) */</span>
              <span class="hljs-comment">/* remove:: FUN[T =&gt; BOOL] =&gt; STREAM[T] =&gt; STREAM[T] */</span>
              remove: (predicate) =&gt; {
                <span class="hljs-keyword">return</span> (aStream) =&gt; {
                  <span class="hljs-keyword">return</span> stream.filter(not(predicate))(aStream);
                };
              },
              <span class="hljs-comment">/* #@range_end(stream_remove) */</span>
              enumFrom: (from) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.enumFrom(from + <span class="hljs-number">1</span>);
                });
              },
              <span class="hljs-comment">/* #@range_begin(stream_generate) */</span>
              generate: (astream) =&gt; {
                <span class="hljs-keyword">var</span> theStream = astream;
                <span class="hljs-keyword">return</span> (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.match(theStream,{
                    empty: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
                    },
                    cons: (head,tailThunk) =&gt; {
                      theStream = tailThunk();
                      <span class="hljs-keyword">return</span> head;
                    }
                  });
                };
              }
              <span class="hljs-comment">/* #@range_end(stream_generate) */</span>
            }; <span class="hljs-comment">// end of 'stream' module</span>

            <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
              <span class="hljs-keyword">return</span> (m) =&gt; {
                <span class="hljs-keyword">if</span>(n % m === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              };
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p><strong>リスト7.37</strong> 素数列の生成 
<a href="http://www.youtube.com/watch?v=1NzrrU8BawA" title="エラトステネスのふるいの動画"><img src="http://img.youtube.com/vi/1NzrrU8BawA/0.jpg" alt="IMAGE ALT TEXT"></a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(eratosthenes_sieve) */</span>
            <span class="hljs-comment">/* エラトステネスのふるい */</span>
            <span class="hljs-keyword">var</span> sieve = (aStream) =&gt; {
              <span class="hljs-keyword">return</span> stream.match(aStream, {
                empty: () =&gt; { 
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                },
                cons: (head, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> stream.cons(head, (_) =&gt; {
                    <span class="hljs-keyword">return</span> sieve(stream.remove( <span class="hljs-comment">// 後尾を素数の倍数でふるいにかける</span>
                      (item) =&gt; { 
                        <span class="hljs-keyword">return</span> multipleOf(item)(head);  
                      }
                    )(tailThunk()));
                  }); 
                }
              });
            };
            <span class="hljs-keyword">var</span> primes = sieve(stream.enumFrom(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 無限の素数列</span>
            <span class="hljs-comment">/* #@range_end(eratosthenes_sieve) */</span>
            <span class="hljs-comment">/* #@range_begin(eratosthenes_sieve_test) */</span>
            expect(
              stream.toArray(stream.take(primes)(<span class="hljs-number">10</span>))
            ).to.eql(
              [ <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span> ]
            );
            <span class="hljs-comment">/* #@range_end(eratosthenes_sieve_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p><strong>リスト7.39</strong> 素数のジェネレータ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-comment">/* #@range_begin(prime_generator) */</span>
            <span class="hljs-keyword">var</span> primes = sieve(stream.enumFrom(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 無限の素数列</span>
            <span class="hljs-keyword">var</span> primeGenerator = generate(primes);  <span class="hljs-comment">// 素数のジェネレータ</span>
            <span class="hljs-comment">/******* テスト ********/</span>
            expect(primeGenerator()).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(primeGenerator()).to.eql(
              <span class="hljs-number">3</span>
            );
            expect(primeGenerator()).to.eql(
              <span class="hljs-number">5</span>
            );
            <span class="hljs-comment">/* #@range_end(prime_generator) */</span>
            next();
          });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h4 id="-ecmascript2015-es6-">コラム：ECMAScript2015（ES6）におけるジェネレータ</h4>
<blockquote>
<p>参考資料: <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Generator</a> </p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'ECMAScript2015（ES6）におけるジェネレータ'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p><strong>リスト7.40</strong> ECMAScript2015のジェネレータ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(es6_generator) */</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genCounter</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
          };
          <span class="hljs-keyword">var</span> counter = genCounter();
          expect(
            counter.next().value
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            counter.next().value
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(es6_generator) */</span>
          next();
        });
      });
    }); <span class="hljs-comment">// クロージャーで状態をカプセル化する</span>
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h3 id="-section-id-pure-closure-section-"><section id='pure-closure'>クロージャーの純粋性 </section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'クロージャーの純粋性'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p><strong>リスト 7.41</strong> multipleOf関数の参照透過性</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'multipleOf関数の参照透過性'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> multipleOf = (n) =&gt; {
        <span class="hljs-keyword">return</span> (m) =&gt; {
          <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
      };
      <span class="hljs-comment">/* #@range_begin(multipleOf_is_transparent) */</span>
      expect(
        multipleOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
      ).to.eql(
        multipleOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
      );
      expect(
        multipleOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
      ).to.eql(
        multipleOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
      );
      <span class="hljs-comment">/* #@range_end(multipleOf_is_transparent) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p><strong>リスト7.42</strong> 参照透過性のないクロージャーの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'参照透過性のないクロージャーの例'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> counter = (init) =&gt; {
        <span class="hljs-keyword">var</span> _init = init;
        <span class="hljs-keyword">return</span> (_) =&gt; {
          _init = _init + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">return</span> _init;
        };
      };
      <span class="hljs-comment">/* #@range_begin(counter_is_not_transparent) */</span>
      <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
      expect(
        counterFromZero()
      ).not.to.eql( <span class="hljs-comment">// notで一致しないことをテストしている</span>
        counterFromZero()
      );
      <span class="hljs-comment">/* #@range_end(counter_is_not_transparent) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p><strong>リスト7.44</strong> カウンターをクロージャーで定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'カウンターをクロージャーで定義する'</span>, (next) =&gt; {
      <span class="hljs-comment">/* チャーチ数 church numeral */</span>
      <span class="hljs-keyword">var</span> zero = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p><strong>リスト7.45</strong> チャーチ数のone関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(church_one) */</span>
      <span class="hljs-keyword">var</span> one = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(x); <span class="hljs-comment">// f関数を1回適用する</span>
        };
      };
      <span class="hljs-comment">/* #@range_end(church_one) */</span>
      <span class="hljs-keyword">var</span> two = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(f(x));
        };
      };
      <span class="hljs-keyword">var</span> three = (f) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> f(f(f(x)));
        };
      };
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> (f) =&gt; {
          <span class="hljs-keyword">return</span> (x) =&gt; {
            <span class="hljs-keyword">return</span> f(n(f)(x));
          };
        };
      };
      <span class="hljs-keyword">var</span> add = (m) =&gt; {
        <span class="hljs-keyword">return</span> (n) =&gt; {
          <span class="hljs-keyword">return</span> (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt;{
              <span class="hljs-keyword">return</span> m(f)(n(f)(x));
            };
          };
        };
      };
      <span class="hljs-comment">/* 関数適用の回数を数えるcounterクロージャー */</span>
      <span class="hljs-keyword">var</span> counter = (init) =&gt; {
        <span class="hljs-keyword">var</span> _init = init; <span class="hljs-comment">// 可変な変数</span>
        <span class="hljs-keyword">return</span> (_) =&gt; {
          _init = _init + <span class="hljs-number">1</span>; <span class="hljs-comment">// 代入で変数_initを更新する</span>
          <span class="hljs-keyword">return</span> _init;
        };
      };
      <span class="hljs-comment">/***** counterクロージャーを用いたチャーチ数のテスト *****/</span>
      <span class="hljs-comment">/* #@range_begin(church_numeral_counter) */</span>
      expect(
        one(counter(<span class="hljs-number">0</span>))() <span class="hljs-comment">// oneはチャーチ数（@&lt;list&gt;{church_numeral}）の1</span>
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        two(counter(<span class="hljs-number">0</span>))() <span class="hljs-comment">// twoはチャーチ数（@&lt;list&gt;{church_numeral}）の2</span>
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-comment">/* #@range_end(church_numeral_counter) */</span>
      expect(
        add(one)(two)(counter(<span class="hljs-number">0</span>))()
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h2 id="7-5-section-id-passing-function-section-">7.5 <section id='passing-function'>関数を渡す</section></h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数を渡す'</span>, () =&gt; {
  <span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h3 id="-section-id-callback-section-"><section id='callback'>コールバックで処理をモジュール化する</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'コールバックで処理をモジュール化する'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p><strong>リスト7.47</strong> 直接的な呼び出しの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'直接的な呼び出しの例'</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(direct_call) */</span>
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-keyword">var</span> doCall = (arg) =&gt; {
        <span class="hljs-keyword">return</span> succ(arg);  <span class="hljs-comment">// succ関数を直接呼び出す</span>
      };
      expect(
        doCall(<span class="hljs-number">2</span>)
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      <span class="hljs-comment">/* #@range_end(direct_call) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p><strong>リスト7.48</strong> 単純なコールバックの例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'単純なコールバックの例'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_begin(call_callback) */</span>
      <span class="hljs-keyword">var</span> setupCallback = (callback) =&gt; {
        <span class="hljs-comment">/* コールバック関数を実行する無名関数を返す */</span>
        <span class="hljs-keyword">return</span> (arg) =&gt; {  
          <span class="hljs-keyword">return</span> callback(arg);
        };
      };
      <span class="hljs-comment">/* コールバック関数を設定する */</span>
      <span class="hljs-keyword">var</span> doCallback = setupCallback(succ);  
      expect(
        doCallback(<span class="hljs-number">2</span>) <span class="hljs-comment">// 設定されたコールバック関数を実行する</span>
      ).to.eql(
        <span class="hljs-number">3</span>
      );
      <span class="hljs-comment">/* #@range_end(call_callback) */</span>
      next();
    });
    it(<span class="hljs-string">'リストのmap関数'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p><strong>リスト7.49</strong> リストのmap関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(list_map) */</span>
      <span class="hljs-comment">/* map:: FUN[T =&gt; T] =&gt; LIST[T] =&gt;  LIST[T] */</span>
      <span class="hljs-keyword">var</span> map = (callback) =&gt; {
        <span class="hljs-keyword">return</span> (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.match(alist,{
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> list.empty();
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-comment">/* コールバック関数を実行する */</span>
              <span class="hljs-keyword">return</span> list.cons(callback(head),  
                               map(callback)(tail)); <span class="hljs-comment">// 再帰呼び出し</span>
            }
          });
        };
      };
      <span class="hljs-comment">/* #@range_end(list_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p><strong>リスト7.50</strong> map関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(list_map_test) */</span>
      <span class="hljs-comment">/* map処理の対象となる数値のリスト */</span>
      <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,
                              list.cons(<span class="hljs-number">2</span>,
                                        list.cons(<span class="hljs-number">3</span>,
                                                  list.empty())));
      <span class="hljs-comment">/* 要素を2倍するmap処理 */</span>
      <span class="hljs-keyword">var</span> mapDouble = map((n) =&gt; { 
        <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
      });
      expect(
        compose(list.toArray,mapDouble)(numbers)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]
      );
      <span class="hljs-comment">/* 要素を2乗するmap処理 */</span>
      <span class="hljs-keyword">var</span> mapSquare = map((n) =&gt; { 
        <span class="hljs-keyword">return</span> n * n;
      });
      expect(
        compose(list.toArray,mapSquare)(numbers)
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>]
      );
      <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <h3 id="-section-id-folding-section-"><section id='folding'>畳み込み関数に関数を渡す</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'畳み込み関数に関数を渡す'</span>, () =&gt; {
    describe(<span class="hljs-string">'コールバックによるリストの再帰関数'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p><strong>リスト7.51</strong> sum関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'sum関数の定義'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> list = {
          match : (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data.call(list, pattern);
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, alist) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, alist);
            };
          },
          <span class="hljs-comment">/* #@range_begin(list_sum) */</span>
          sum: (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> list.match(alist,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> list.sum(tail)(accumulator + head);
                }
              });
            };
          },
          <span class="hljs-comment">/* #@range_end(list_sum) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p><strong>リスト7.52</strong> コールバック関数を用いたsum関数の再定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(list_sum_callback) */</span>
          sumWithCallback: (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (CALLBACK) =&gt; { <span class="hljs-comment">// コールバック関数を受け取る</span>
                <span class="hljs-keyword">return</span> list.match(alist,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> CALLBACK(head)( <span class="hljs-comment">// コールバック関数を呼び出す</span>
                      list.sumWithCallback(tail)(accumulator)(CALLBACK)
                    );
                  }
                });
              };
            };
          }
          <span class="hljs-comment">/* #@range_end(list_sum_callback) */</span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p><strong>リスト7.53</strong> sumWithCallback関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(list_sum_callback_test) */</span>
        <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>, 
                                list.cons(<span class="hljs-number">2</span>,
                                          list.cons(<span class="hljs-number">3</span>,
                                                    list.empty())));
        <span class="hljs-comment">/* sumWithCallback関数に渡すコールバック関数 */</span>
        <span class="hljs-keyword">var</span> callback = (n) =&gt; {  
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> n + m;
          };
        };
        expect(
          list.sumWithCallback(numbers)(<span class="hljs-number">0</span>)(callback)
        ).to.eql(
          <span class="hljs-number">6</span>  <span class="hljs-comment">// 1 + 2 + 3 = 6</span>
        );
        <span class="hljs-comment">/* #@range_end(list_sum_callback_test) */</span>
        expect(
          list.sum(numbers)(<span class="hljs-number">0</span>)
        ).to.eql(
          <span class="hljs-number">6</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p><strong>リスト7.54</strong> length関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'length関数の定義'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> list = {
          match : (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data.call(list, pattern);
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, alist) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, alist);
            };
          },
          <span class="hljs-comment">/* #@range_begin(list_length) */</span>
          length: (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> list.match(alist,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> list.length(tail)(accumulator + <span class="hljs-number">1</span>);
                }
              });
            };
          },
          <span class="hljs-comment">/* #@range_end(list_length) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p><strong>リスト7.55</strong> length関数の再定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(list_length_callback) */</span>
          lengthWithCallback: (alist) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (CALLBACK) =&gt; { <span class="hljs-comment">// コールバック関数を受け取る</span>
                <span class="hljs-keyword">return</span> list.match(alist,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> CALLBACK(head)(
                      list.lengthWithCallback(tail)(accumulator)(CALLBACK)
                    );
                  }
                });
              };
            };
          }
          <span class="hljs-comment">/* #@range_end(list_length_callback) */</span>
        };
        <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>, 
                                list.cons(<span class="hljs-number">2</span>,
                                          list.cons(<span class="hljs-number">3</span>,
                                                    list.empty())));
        expect(
          list.length(numbers)(<span class="hljs-number">0</span>)
        ).to.eql(
          <span class="hljs-number">3</span>
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><strong>リスト7.56</strong> lengthWithCallback関数でリストの長さをテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(list_length_callback_test) */</span>
        <span class="hljs-comment">/* lengthWithCallback関数に渡すコールバック関数 */</span>
        <span class="hljs-keyword">var</span> callback = (n) =&gt; {  
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + m;
          };
        };
        expect(
          list.lengthWithCallback(numbers)(<span class="hljs-number">0</span>)(callback)
        ).to.eql(
          <span class="hljs-number">3</span>
        );
        <span class="hljs-comment">/* #@range_end(list_length_callback_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'畳み込み関数'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p><strong>リスト7.58</strong> リストの畳み込み関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(list_foldr) */</span>
      <span class="hljs-keyword">var</span> foldr = (alist) =&gt; {
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> (callback) =&gt; {
            <span class="hljs-keyword">return</span> list.match(alist,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> callback(head)(foldr(tail)(accumulator)(callback));
              }
            });
          };
        };
      };
      <span class="hljs-comment">/* #@range_end(list_foldr) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p><strong> リスト7.59</strong> foldr関数によるsum関数とlength関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* foldr関数によるsum関数 */</span>
      it(<span class="hljs-string">"foldr関数によるsum関数"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(foldr_sum) */</span>
        <span class="hljs-keyword">var</span> sum = (alist) =&gt; {
          <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">0</span>)((item) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> accumulator + item;
            };
          });
        };
        <span class="hljs-comment">/* #@range_end(foldr_sum) */</span>
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
        expect(
          sum(seq)
        ).to.eql(
          <span class="hljs-number">10</span>  <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span>
        );
        next();
      });
      <span class="hljs-comment">/* foldr関数によるlength関数 */</span>
      it(<span class="hljs-string">"foldrでlength関数を作る"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(foldr_length) */</span>
        <span class="hljs-keyword">var</span> length = (alist) =&gt; {
          <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">0</span>)((item) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> accumulator + <span class="hljs-number">1</span>;
            };
          });
        };
        <span class="hljs-comment">/* #@range_end(foldr_length) */</span>
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
        expect(
          length(seq)
        ).to.eql(
          <span class="hljs-number">4</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p><strong>表7.2</strong> 反復処理における蓄積変数の初期値とコールバック関数の関係</p>
<table>
<thead>
<tr>
<th style="text-align:left">関数名</th>
<th style="text-align:center">蓄積変数の初期値</th>
<th style="text-align:left">関数合成による定義</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sum</td>
<td style="text-align:center">0</td>
<td style="text-align:left">(n) =&gt; { return (m) =&gt; { return n + m;};}</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:center">0</td>
<td style="text-align:left">(n) =&gt; { return (m) =&gt; { return 1 + m;};}</td>
</tr>
<tr>
<td style="text-align:left">product</td>
<td style="text-align:center">1</td>
<td style="text-align:left">(n) =&gt; { return (m) =&gt; { return n ＊ m;};}</td>
</tr>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:center">true</td>
<td style="text-align:left">(n) =&gt; { return (m) =&gt; { return n ＆＆ m;};}</td>
</tr>
<tr>
<td style="text-align:left">any</td>
<td style="text-align:center">true</td>
<td style="text-align:left">(n) =&gt; { return (m) =&gt; { return n ｜｜ m;};}</td>
</tr>
</tbody>
</table>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'反復処理における蓄積変数の初期値とコールバック関数の関係'</span>, () =&gt; {
        it(<span class="hljs-string">"foldrでproductを作る"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(foldr_product) */</span>
          <span class="hljs-keyword">var</span> product = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-number">1</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator * item;
              };
            });
          };
          <span class="hljs-comment">/********* テスト **********/</span>
          <span class="hljs-comment">/* list = [1,2,3] */</span>
          <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,
                              list.cons(<span class="hljs-number">2</span>,
                                        list.cons(<span class="hljs-number">3</span>,
                                                  list.empty())));
          expect(
            product(seq)
          ).to.eql(
            <span class="hljs-number">6</span> <span class="hljs-comment">// 1 * 2 * 3 = 6</span>
          );
          <span class="hljs-comment">/* #@range_end(foldr_product) */</span>
          next();
        });
        it(<span class="hljs-string">"foldrでallを作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> all = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-literal">true</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator &amp;&amp; item;
              };
            });
          };
          <span class="hljs-comment">/********* テスト **********/</span>
          <span class="hljs-keyword">var</span> allTrueList = list.cons(<span class="hljs-literal">true</span>,
                                      list.cons(<span class="hljs-literal">true</span>,
                                                list.cons(<span class="hljs-literal">true</span>,
                                                          list.empty())));
          expect(
            all(allTrueList)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-keyword">var</span> someFalseList = list.cons(<span class="hljs-literal">true</span>,
                                        list.cons(<span class="hljs-literal">false</span>,
                                                  list.cons(<span class="hljs-literal">true</span>,
                                                            list.empty())));
          expect(
            all(someFalseList)
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          next();
        });
        it(<span class="hljs-string">"foldrでanyを作る"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> any = (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-literal">false</span>)((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator || item;
              };
            });
          };
          <span class="hljs-comment">/********* テスト **********/</span>
          <span class="hljs-keyword">var</span> allTrueList = list.cons(<span class="hljs-literal">true</span>,
                                      list.cons(<span class="hljs-literal">true</span>,
                                                list.cons(<span class="hljs-literal">true</span>,
                                                          list.empty())));
          expect(
            any(allTrueList)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-keyword">var</span> someFalseList = list.cons(<span class="hljs-literal">true</span>,
                                        list.cons(<span class="hljs-literal">false</span>,
                                                  list.cons(<span class="hljs-literal">true</span>,
                                                            list.empty())));
          expect(
            any(someFalseList)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          next();
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p><strong>リス7.60</strong> foldr関数によるreverse関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"foldr関数によるreverse関数の定義"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> list = {
          match : (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data.call(list, pattern);
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, alist) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, alist);
            };
          },
          toArray: (alist) =&gt; {
            <span class="hljs-keyword">var</span> toArrayAux = (alist,accumulator) =&gt; {
              <span class="hljs-keyword">return</span> list.match(alist, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;  
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
                }
              });
            };
            <span class="hljs-keyword">return</span> toArrayAux(alist, []);
          },
          <span class="hljs-comment">/* #@range_begin(foldr_reverse) */</span>
          <span class="hljs-comment">/* listのappend関数は、2つのリストを連結する */</span>
          append: (xs) =&gt; {
            <span class="hljs-keyword">return</span> (ys) =&gt; {
              <span class="hljs-keyword">return</span> list.match(xs, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> ys;
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> list.cons(head, list.append(tail)(ys)); 
                }
              });
            };
          },
          <span class="hljs-comment">/* list.reverse関数は、リストを逆転する */</span>
          reverse: (alist) =&gt; {
            <span class="hljs-keyword">return</span> foldr(alist)(list.empty(<span class="hljs-number">0</span>))((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item,
                                                          list.empty()));
              };
            });
          }
          <span class="hljs-comment">/* #@range_end(foldr_reverse) */</span>
        };
        <span class="hljs-comment">/* list = [1,2,3,4] */</span>
        <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,
                            list.cons(<span class="hljs-number">2</span>,
                                      list.cons(<span class="hljs-number">3</span>,
                                                list.cons(<span class="hljs-number">4</span>,
                                                          list.empty()))));
        expect(
          list.toArray(list.reverse(seq))
        ).to.eql(
          [ <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p><strong>リスト7.61</strong> foldr関数によるfind関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"foldr関数によるfind関数の定義"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> even = (n) =&gt; {
          <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
        };
        <span class="hljs-keyword">var</span> list = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, alist) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, alist);
            };
          },
          <span class="hljs-comment">/* #@range_begin(foldr_find) */</span>
          <span class="hljs-comment">/* list.find関数は、条件に合致した要素をリストから探す */</span>
          find:  (alist) =&gt; {
            <span class="hljs-keyword">return</span> (predicate) =&gt; { <span class="hljs-comment">// 要素を判定する述語関数</span>
              <span class="hljs-keyword">return</span> foldr(alist)(<span class="hljs-literal">null</span>)((item) =&gt; { <span class="hljs-comment">// foldrを利用する</span>
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-comment">/* 要素が見つかった場合、その要素を返す */</span>
                  <span class="hljs-keyword">if</span>(predicate(item) === <span class="hljs-literal">true</span>) { 
                    <span class="hljs-keyword">return</span> item;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> accumulator;
                  };
                };
              });
            };
          }
          <span class="hljs-comment">/* #@range_end(foldr_find) */</span>
        };
        <span class="hljs-comment">/******** テスト *********/</span>
        <span class="hljs-keyword">var</span> numbers = list.cons(<span class="hljs-number">1</span>,
                                list.cons(<span class="hljs-number">2</span>,
                                          list.cons(<span class="hljs-number">3</span>,
                                                    list.empty())));
        expect(
          list.find(numbers)(even) <span class="hljs-comment">// 最初に登場する偶数の要素を探す</span>
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        next();
      });
      it(<span class="hljs-string">"foldrで map関数を作る"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> double = (number) =&gt; {
          <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
        };
        <span class="hljs-comment">/* #@range_begin(foldr_map) */</span>
        <span class="hljs-keyword">var</span> map = (alist) =&gt; {
          <span class="hljs-keyword">return</span> (callback) =&gt; { <span class="hljs-comment">// 個々の要素を変換するコールバック関数</span>
            <span class="hljs-keyword">return</span> foldr(alist)(list.empty())((item) =&gt; {
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> list.cons(callback(item), accumulator);
              };
            });
          };
        };
        <span class="hljs-comment">/****** テスト ******/</span>
        <span class="hljs-comment">/* list = [1,2,3] */</span>
        <span class="hljs-keyword">var</span> seq = list.cons(<span class="hljs-number">1</span>,
                            list.cons(<span class="hljs-number">2</span>,
                                      list.cons(<span class="hljs-number">3</span>,
                                                list.empty())));
        expect(
          list.toArray(map(seq)(double))
        ).to.eql(
          [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>] <span class="hljs-comment">// 2 * [1,2,3] = [2,4,6]</span>
        );
        <span class="hljs-comment">/* #@range_end(foldr_map) */</span>
        next();
      });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <h4 id="-">コラム：配列の畳み込み関数</h4>
<blockquote>
<p>参考資料: <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce</a></p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">"コラム：配列の畳み込み関数"</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p><strong>リスト7.62</strong> reduceメソッドによるfromArray関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"reduceメソッドによるfromArray関数"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(list_fromArray) */</span>
        <span class="hljs-keyword">var</span> fromArray = (array) =&gt; {
          <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
            <span class="hljs-keyword">return</span> list.append(accumulator)(list.cons(item, list.empty()));
          }, list.empty());
        };
        <span class="hljs-comment">/******* テスト *******/</span>
        <span class="hljs-keyword">var</span> theList = fromArray([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
        expect(
          list.toArray(theList)
        ).to.eql(
          [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_fromArray) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h3 id="-section-id-asynchronous-section-"><section id='asynchronous'>非同期処理にコールバック関数を渡す</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'非同期処理にコールバック関数を渡す'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p><strong>リスト7.64</strong> tarai関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"tarai関数の定義"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(tarai_function) */</span>
      <span class="hljs-comment">/* たらいまわし関数 */</span>
      <span class="hljs-keyword">var</span> tarai = (x,y,z) =&gt; {
        <span class="hljs-keyword">if</span>(x &gt; y) {
          <span class="hljs-keyword">return</span> tarai(tarai(x - <span class="hljs-number">1</span>, y, z), 
                       tarai(y - <span class="hljs-number">1</span>, z, x), 
                       tarai(z - <span class="hljs-number">1</span>, x, y));
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> y;
        }
      };
      expect(
        tarai(<span class="hljs-number">1</span> * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
      ).to.eql(
        <span class="hljs-number">2</span> 
      );
      <span class="hljs-comment">/* #@range_end(tarai_function) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p><a name="tarai_system"> taraiサーバークライアント</a>
<img src="images/tarai-system.gif" alt=""> </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  });</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h3 id="-section-id-continuation-section-"><section id='continuation'>継続で未来を渡す</section></h3>
<blockquote>
<p>参考資料: <a href="https://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A">Wikipediaの記事</a></p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'継続で未来を渡す'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <h4 id="-">継続とは何か</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'継続とは何か'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p><strong>リスト7.67</strong> 継続渡しのsucc関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"継続渡しのsucc関数"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(succ_cps) */</span>
        <span class="hljs-comment">/* continues関数は、succ(n)のあとに続く継続 */</span>
        <span class="hljs-keyword">var</span> succ = (n, continues) =&gt; { 
          <span class="hljs-keyword">return</span> continues(n + <span class="hljs-number">1</span>);
        };
        <span class="hljs-comment">/* #@range_end(succ_cps) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p><strong>リスト7.68</strong> 継続渡しのsucc関数をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> identity = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };

        <span class="hljs-comment">/* #@range_begin(succ_cps_test) */</span>
        <span class="hljs-comment">/* identity関数を継続として渡すことで、
           succ(1)の結果がそのまま返る */</span>
        expect(
          succ(<span class="hljs-number">1</span>, identity) 
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(succ_cps_test) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p><strong>リスト7.70</strong> add(2, succ(3))の継続渡し</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"add(2, succ(3))の継続渡し"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> identity = (any) =&gt; { <span class="hljs-comment">// 値をそのまま返すだけの継続</span>
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-comment">/* #@range_begin(continuation_in_arithmetic) */</span>
        <span class="hljs-comment">/* 継続渡しのsucc関数 */</span>
        <span class="hljs-keyword">var</span> succ = (n, continues) =&gt; { 
          <span class="hljs-keyword">return</span> continues(n + <span class="hljs-number">1</span>);
        };
        <span class="hljs-comment">/* 継続渡しのadd関数 */</span>
        <span class="hljs-keyword">var</span> add = (n,m, continues) =&gt; { 
          <span class="hljs-keyword">return</span> continues(n + m);
        };
        <span class="hljs-comment">/* 継続渡しのsucc関数とadd関数を使って 
           add(2, succ(3)) を計算する */</span>
        expect(
          succ(<span class="hljs-number">3</span>, (succResult) =&gt; {
            <span class="hljs-keyword">return</span> add(<span class="hljs-number">2</span>, succResult, identity);
          })
        ).to.eql(
          <span class="hljs-number">6</span>
        );
        <span class="hljs-comment">/* #@range_end(continuation_in_arithmetic) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">"継続で未来を選ぶ"</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p><strong>リスト7.71</strong> 継続による反復処理からの脱出</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"継続による反復処理からの脱出"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(stream_find_cps) */</span>
        <span class="hljs-keyword">var</span> find = (aStream,
                    predicate, 
                    continuesOnFailure, 
                    continuesOnSuccess) =&gt; {
                      <span class="hljs-keyword">return</span> list.match(aStream, {
                        <span class="hljs-comment">/* リストの最末尾に到着した場合
                           成功継続で反復処理を抜ける */</span>
                        empty: () =&gt; {
                          <span class="hljs-keyword">return</span> continuesOnSuccess(<span class="hljs-literal">null</span>); 
                        },
                        cons: (head, tailThunk) =&gt; { 
                          <span class="hljs-comment">/* 目的の要素を見つけた場合
                             成功継続で反復処理を脱出する */</span>
                          <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>) { 
                            <span class="hljs-keyword">return</span> continuesOnSuccess(head); 
                          } <span class="hljs-keyword">else</span> { 
                            <span class="hljs-comment">/* 目的の要素を見つけられなった場合、
                               失敗継続で次の反復処理を続ける */</span>
                            <span class="hljs-keyword">return</span> continuesOnFailure(tailThunk(), 
                                                      predicate,
                                                      continuesOnFailure,
                                                      continuesOnSuccess);
                          };
                        }
                      });
                    };
        <span class="hljs-comment">/* #@range_end(stream_find_cps) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>find関数に渡す2つの継続</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> identity = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p><strong>リスト7.72</strong> find関数に渡す2つの継続</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(stream_find_continuations) */</span>
        <span class="hljs-comment">/* 成功継続では、反復処理を脱出する */</span>
        <span class="hljs-keyword">var</span> continuesOnSuccess = identity; 

        <span class="hljs-comment">/* 失敗継続では、反復処理を続ける */</span>
        <span class="hljs-keyword">var</span> continuesOnFailure = (aStream,
                                  predicate, 
                                  continuesOnRecursion, 
                                  escapesFromRecursion) =&gt; { 
                                    <span class="hljs-comment">/* find関数を再帰的に呼び出す */</span>
                                    <span class="hljs-keyword">return</span> find( 
                                      aStream, 
                                      predicate, 
                                      continuesOnRecursion, 
                                      escapesFromRecursion
                                    );  
                                  };
        <span class="hljs-comment">/* #@range_end(stream_find_continuations) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p><strong>リスト7.73</strong> find関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* upto3変数は、1から3までの有限ストリーム */</span>
        <span class="hljs-keyword">var</span> upto3 = stream.cons(<span class="hljs-number">1</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
        });
        expect(
          find(upto3, (item) =&gt; {
            <span class="hljs-keyword">return</span> (item === <span class="hljs-number">4</span>); <span class="hljs-comment">// 4を探します</span>
          }, continuesOnFailure, continuesOnSuccess)
        ).to.eql(
          <span class="hljs-literal">null</span> <span class="hljs-comment">// リスト中に4の要素はないので、nullになります</span>
        );
        <span class="hljs-comment">/* #@range_begin(stream_find_cps_test) */</span>
        <span class="hljs-comment">/* 変数integersは、無限の整数ストリーム */</span>
        <span class="hljs-keyword">var</span> integers = stream.enumFrom(<span class="hljs-number">0</span>);
        
        <span class="hljs-comment">/* 無限の整数列のなかから100を探す */</span>
        expect(
          find(integers, (item) =&gt; {
            <span class="hljs-keyword">return</span> (item === <span class="hljs-number">100</span>); 
          }, continuesOnFailure, continuesOnSuccess)
        ).to.eql(
          <span class="hljs-number">100</span> <span class="hljs-comment">// 100を見つけて返ってくる</span>
        );
        <span class="hljs-comment">/* #@range_end(stream_find_cps_test) */</span>
        next();
      }); 
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h4 id="-">非決定計算機を作る</h4>
<blockquote>
<p>参考資料: <a href="http://sicp.iijlab.net/fulltext/x430.html">SICPの非決定計算の章</a></p>
</blockquote>
<p><strong>リスト7.74</strong> 決定性計算機</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">"決定計算機"</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>式の代数的データ構造</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> exp = {
        match : (anExp, pattern) =&gt; { <span class="hljs-comment">// 代数的データ構造のパターンマッチ</span>
          <span class="hljs-keyword">return</span> anExp.call(exp, pattern);
        },
        num: (n) =&gt; {             <span class="hljs-comment">// 数値の式</span>
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.num(n);
          };
        }, 
        add: (exp1, exp2) =&gt; {    <span class="hljs-comment">// 足し算の式</span>
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.add(exp1, exp2);
          };
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>式の評価関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> calculate = (anExp) =&gt; {
        <span class="hljs-keyword">return</span> match(anExp, { 
          num: (n) =&gt; {           <span class="hljs-comment">// 数値を評価する</span>
            <span class="hljs-keyword">return</span> n;
          }, 
          add: (exp1, exp2) =&gt; {  <span class="hljs-comment">// 足し算の式を評価する</span>
            <span class="hljs-keyword">return</span> calculate(exp1) + calculate(exp2); 
          }
        });
      };
    }); 
    describe(<span class="hljs-string">"非決定計算機を作る"</span>, () =&gt; {
      <span class="hljs-keyword">var</span> exp = {
        match : (anExp, pattern) =&gt; {
          <span class="hljs-keyword">return</span> anExp.call(exp, pattern);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p><strong>リスト7.75</strong> 非決定計算機の式</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(amb_expression) */</span>
        amb : (alist) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.amb(alist);
          };
        },
        <span class="hljs-comment">/* #@range_end(amb_expression) */</span>
        num : (n) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.num(n);
          };
        },
        add : (exp1, exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.add(exp1, exp2);
          };
        }
      };
      <span class="hljs-comment">/* #@range_begin(amb_calculate) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <section id='amb_calculate'>非決定性計算機の評価関数</section>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> calculate = (anExp, 
                       continuesOnSuccess, 
                       continuesOnFailure) =&gt; {
                         <span class="hljs-comment">/* 式に対してパターンマッチを実行する */</span>
                         <span class="hljs-keyword">return</span> exp.match(anExp, {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p><strong>リスト7.79</strong> 数値の評価</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                           <span class="hljs-comment">/* #@range_begin(amb_calculate_num) */</span>
                           <span class="hljs-comment">/* 数値を評価する */</span>
                           num: (n) =&gt; {
                             <span class="hljs-keyword">return</span> continuesOnSuccess(n, continuesOnFailure);
                           },
                           <span class="hljs-comment">/* #@range_end(amb_calculate_num) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p><strong>リスト7.80</strong> 足し算の評価 </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                           <span class="hljs-comment">/* #@range_begin(amb_calculate_add) */</span>
                           <span class="hljs-comment">/* 足し算の式を評価する */</span>
                           add: (x, y) =&gt; {
                             <span class="hljs-comment">/* まず引数xを評価する */</span>
                             <span class="hljs-keyword">return</span> calculate(x, (resultX, continuesOnFailureX) =&gt; { 
                               <span class="hljs-comment">/* 次に引数yを評価する */</span>
                               <span class="hljs-keyword">return</span> calculate(y, (resultY, continuesOnFailureY) =&gt; { 
                                 <span class="hljs-comment">/* 引数xとyがともに成功すれば、両者の値で足し算を計算する */</span>
                                 <span class="hljs-keyword">return</span> continuesOnSuccess(resultX + resultY, continuesOnFailureY); 
                               }, continuesOnFailureX); <span class="hljs-comment">/* y の計算に失敗すれば、xの失敗継続を渡す */</span>
                             }, continuesOnFailure);    <span class="hljs-comment">/* x の計算に失敗すれば、おおもとの失敗継続を渡す */</span>
                           },
                           <span class="hljs-comment">/* #@range_end(amb_calculate_add) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p><strong>リスト7.81</strong> amb式の評価</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                           <span class="hljs-comment">/* #@range_begin(amb_calculate_amb) */</span>
                           <span class="hljs-comment">/* amb式を評価する */</span>
                           amb: (choices) =&gt; {
                              <span class="hljs-keyword">var</span> calculateAmb = (choices) =&gt; {
                               <span class="hljs-keyword">return</span> list.match(choices, {
                                 <span class="hljs-comment">/* 
                                    amb(list.empty()) の場合、
                                    すなわち選択肢がなければ、失敗継続を実行する
                                 */</span>
                                 empty: () =&gt; {         
                                   <span class="hljs-keyword">return</span> continuesOnFailure();
                                 },
                                 <span class="hljs-comment">/* 
                                    amb(list.cons(head, tail))の場合、
                                    先頭要素を計算して、後尾は失敗継続に渡す
                                 */</span>
                                 cons: (head, tail) =&gt; { 
                                   <span class="hljs-keyword">return</span> calculate(head, continuesOnSuccess, (_) =&gt; { 
                                     <span class="hljs-comment">/* 失敗継続で後尾を計算する */</span>
                                     <span class="hljs-keyword">return</span> calculateAmb(tail);
                                   });
                                 }
                               });
                             };
                             <span class="hljs-keyword">return</span> calculateAmb(choices);
                           }
                           <span class="hljs-comment">/* #@range_end(amb_calculate_amb) */</span>
                         });
                       };
      <span class="hljs-comment">/* #@range_end(amb_calculate) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p><strong>リスト7.82</strong> 非決定計算機の駆動関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(amb_driver) */</span>
      <span class="hljs-keyword">var</span> driver = (expression) =&gt;{
        <span class="hljs-comment">/* 中断された計算を継続として保存する変数 */</span>
        <span class="hljs-keyword">var</span> suspendedComputation = <span class="hljs-literal">null</span>; 
        <span class="hljs-comment">/* 成功継続 */</span>
        <span class="hljs-keyword">var</span> continuesOnSuccess = (anyValue, 
                                  continuesOnFailure) =&gt; {
                                    <span class="hljs-comment">/* 再開に備えて、失敗継続を保存しておく */</span>
                                    suspendedComputation = continuesOnFailure; 
                                    <span class="hljs-keyword">return</span> anyValue;
                                  };
        <span class="hljs-comment">/* 失敗継続 */</span>
        <span class="hljs-keyword">var</span> continuesOnFailure = () =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        };

        <span class="hljs-comment">/* 内部に可変な状態suspendedComputationを持つクロージャーを返す */</span>
        <span class="hljs-keyword">return</span> () =&gt; {
          <span class="hljs-comment">/* 中断された継続がなければ、最初から計算する */</span>
          <span class="hljs-keyword">if</span>(suspendedComputation === <span class="hljs-literal">null</span>) { 
            <span class="hljs-keyword">return</span> calculate(expression, 
                             continuesOnSuccess, 
                             continuesOnFailure);
          } <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 中断された継続があれば、その継続を実行する */</span>
            <span class="hljs-keyword">return</span> suspendedComputation();
          }
        };
      };
      <span class="hljs-comment">/* #@range_end(amb_driver) */</span>
      it(<span class="hljs-string">"amb[1,2] + 3  = amb[4, 5]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> ambExp = exp.add(exp.amb(list.cons(exp.num(<span class="hljs-number">1</span>),list.cons(exp.num(<span class="hljs-number">2</span>), list.empty()))), 
                             exp.num(<span class="hljs-number">3</span>));
        <span class="hljs-keyword">var</span> calculator = driver(ambExp);
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">4</span> <span class="hljs-comment">// 1 + 3 = 4</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">5</span> <span class="hljs-comment">// 2 + 3 = 5 </span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p><strong>リスト7.83</strong> 非決定計算機のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"非決定計算機のテスト"</span>, (next) =&gt; {
        <span class="hljs-comment">/* amb[1,2] + amb[3,4] = amb[4, 5, 5, 6] */</span>
        <span class="hljs-comment">/* #@range_begin(amb_test) */</span>
        <span class="hljs-comment">/* amb[1,2] + amb[3,4] = 4, 5, 5, 6 */</span>
        <span class="hljs-keyword">var</span> ambExp = exp.add(
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">1</span>),exp.num(<span class="hljs-number">2</span>)])),
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">3</span>),exp.num(<span class="hljs-number">4</span>)])));
        <span class="hljs-keyword">var</span> calculator = driver(ambExp);
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">4</span> <span class="hljs-comment">// 1 + 3 = 4</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">5</span> <span class="hljs-comment">// 2 + 3 = 5</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">5</span> <span class="hljs-comment">// 1 + 4 = 5</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">6</span> <span class="hljs-comment">// 2 + 4 = 6</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-literal">null</span> <span class="hljs-comment">// これ以上の候補はないので、計算は終了</span>
        );
        <span class="hljs-comment">/* #@range_end(amb_test) */</span>
        next();
      });
      it(<span class="hljs-string">"amb[1,2,3] + amb[10,20] = amb[11,21,12,22,13,23]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> ambExp = exp.add(
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">1</span>),exp.num(<span class="hljs-number">2</span>),exp.num(<span class="hljs-number">3</span>)])),
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">10</span>),exp.num(<span class="hljs-number">20</span>)])));
        <span class="hljs-keyword">var</span> calculator = driver(ambExp);
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">11</span> <span class="hljs-comment">// 1 + 10 = 11</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">21</span> <span class="hljs-comment">// 1 + 20 = 21</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">12</span> <span class="hljs-comment">// 2 + 10 = 12</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">22</span> <span class="hljs-comment">// 2 + 20 = 22</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">13</span> <span class="hljs-comment">// 3 + 10 = 13</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">23</span> <span class="hljs-comment">// 3 + 20 = 23</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-literal">null</span> <span class="hljs-comment">// これ以上の候補はないので、計算は終了</span>
        );
        next();
      });
      it(<span class="hljs-string">"amb[1,2] + amb[10,20,30] = amb[11,21,31,12,22,32]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> ambExp = exp.add(
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">1</span>),exp.num(<span class="hljs-number">2</span>)])),
          exp.amb(list.fromArray([exp.num(<span class="hljs-number">10</span>),exp.num(<span class="hljs-number">20</span>),exp.num(<span class="hljs-number">30</span>)])));
        <span class="hljs-keyword">var</span> calculator = driver(ambExp);
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">11</span> <span class="hljs-comment">// 1 + 10 = 11</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">21</span> <span class="hljs-comment">// 1 + 20 = 21</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">31</span> <span class="hljs-comment">// 1 + 30 = 31</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">12</span> <span class="hljs-comment">// 2 + 10 = 12</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">22</span> <span class="hljs-comment">// 2 + 20 = 22</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-number">32</span> <span class="hljs-comment">// 2 + 30 = 32</span>
        );
        expect(
          calculator()
        ).to.eql(
          <span class="hljs-literal">null</span> <span class="hljs-comment">// これ以上の候補はないので、計算は終了</span>
        );
        next();
      });
    }); 
  }); <span class="hljs-comment">// 継続を渡す</span>
}); <span class="hljs-comment">// 関数を渡す</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h2 id="7-6-section-id-monad-section-">7.6 <section id='monad'>モナドを作る</section></h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'モナドを作る'</span>, () =&gt; {
  <span class="hljs-keyword">var</span> compose = (f,g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <h3 id="-section-id-identity-monad-section-"><section id='identity-monad'>恒等モナド</section></h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'恒等モナド'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p><strong>リスト7.85</strong> 恒等モナドの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> ID = {
      <span class="hljs-comment">/* #@range_begin(identity_monad) */</span>
      <span class="hljs-comment">/* unit:: T =&gt; ID[T] */</span>
      unit: (value) =&gt; {  <span class="hljs-comment">// 単なる identity関数と同じ</span>
        <span class="hljs-keyword">return</span> value;
      },
      <span class="hljs-comment">/* flatMap:: ID[T] =&gt; FUN[T =&gt; ID[T]] =&gt; ID[T] */</span>
      flatMap: (instanceM) =&gt; {
        <span class="hljs-keyword">return</span> (transform) =&gt; {
          <span class="hljs-keyword">return</span> transform(instanceM); <span class="hljs-comment">// 単なる関数適用と同じ</span>
        };
      },
      <span class="hljs-comment">/* #@range_end(identity_monad) */</span>
      compose: (f, g) =&gt; {
        <span class="hljs-keyword">return</span> (x) =&gt; {
          <span class="hljs-keyword">return</span> ID.flatMap(f(x))(g);
        };
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p><strong>リスト7.86</strong> 恒等モナドunit関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"恒等モナドunit関数のテスト"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_monad_unit_test) */</span>
      expect(
        ID.unit(<span class="hljs-number">1</span>)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(identity_monad_unit_test) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p><strong>リスト7.87</strong> 恒等モナドflatMap関数のテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"恒等モナドflatMap関数のテスト"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_begin(identity_monad_flatMap_test) */</span>
      expect(
        ID.flatMap(ID.unit(<span class="hljs-number">1</span>))((one) =&gt; {    
          <span class="hljs-keyword">return</span> ID.unit(succ(one));
        })
      ).to.eql(
        succ(<span class="hljs-number">1</span>)
      );
      <span class="hljs-comment">/* #@range_end(identity_monad_flatMap_test) */</span>
      <span class="hljs-keyword">var</span> double = (m) =&gt; {
        <span class="hljs-keyword">return</span> m * <span class="hljs-number">2</span>;
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p><strong>リスト7.88</strong> flatMapと関数合成の類似性</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(flatMap_and_composition) */</span>
      expect(
        ID.flatMap(ID.unit(<span class="hljs-number">1</span>))((one) =&gt; {    
          <span class="hljs-comment">/* succ関数を適用する */</span>
          <span class="hljs-keyword">return</span> ID.flatMap(ID.unit(succ(one)))((two) =&gt; { 
            <span class="hljs-comment">/* double関数を適用する */</span>
            <span class="hljs-keyword">return</span> ID.unit(double(two));  
          });
        })
      ).to.eql(
        compose(double,succ)(<span class="hljs-number">1</span>)
      );
      <span class="hljs-comment">/* #@range_end(flatMap_and_composition) */</span>
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p><strong>リスト7.89</strong>  恒等モナドのモナド則</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">"恒等モナドのモナド則"</span>, () =&gt; {
      <span class="hljs-comment">/* #@range_begin(identity_monad_laws) */</span>
      it(<span class="hljs-string">"flatMap(instanceM)(unit) === instanceM"</span>, (next) =&gt; {
        <span class="hljs-comment">/* flatMap(instanceM)(unit) === instanceM の一例 */</span>
        <span class="hljs-keyword">var</span> instanceM = ID.unit(<span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>右単位元則</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(identity_monad_laws_right_unit_law) */</span>
        expect(
          ID.flatMap(instanceM)(ID.unit)
        ).to.eql(
          instanceM
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_laws_right_unit_law) */</span>
        next();
      });
      it(<span class="hljs-string">"flatMap(unit(value))(f) == f(value)"</span>, (next) =&gt; {
        <span class="hljs-comment">/* flatMap(unit(value))(f) === f(value) */</span>
        <span class="hljs-keyword">var</span> f = (n) =&gt; {
          <span class="hljs-keyword">return</span> ID.unit(n + <span class="hljs-number">1</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>左単位元則</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(identity_monad_laws_left_unit_law) */</span>
        expect(
          ID.flatMap(ID.unit(<span class="hljs-number">1</span>))(f)
        ).to.eql(
          f(<span class="hljs-number">1</span>)
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_laws_left_unit_law) */</span>
        next();
      });
      it(<span class="hljs-string">"flatMap(flatMap(instanceM)(f))(g) == flatMap(instanceM)((x) =&gt; flatMap(f(x))(g))"</span>, (next) =&gt; {
        <span class="hljs-comment">/* 
           flatMap(flatMap(instanceM)(f))(g) 
           === 
           flatMap(instanceM)((x) =&gt; { 
              return flatMap(f(x))(g); } 
           } 
        */</span>
        <span class="hljs-keyword">var</span> f = (n) =&gt; {
          <span class="hljs-keyword">return</span> ID.unit(n + <span class="hljs-number">1</span>);
        };
        <span class="hljs-keyword">var</span> g = (n) =&gt; {
          <span class="hljs-keyword">return</span> ID.unit(- n);
        };
        <span class="hljs-keyword">var</span> instanceM = ID.unit(<span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>結合法則</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(identity_monad_laws_associative_law) */</span>
        expect(
          ID.flatMap(ID.flatMap(instanceM)(f))(g)
        ).to.eql(
          ID.flatMap(instanceM)((x) =&gt; {
            <span class="hljs-keyword">return</span> ID.flatMap(f(x))(g);
          })
        );
        <span class="hljs-comment">/* #@range_end(identity_monad_laws_associative_law) */</span>
        <span class="hljs-comment">/* #@range_end(identity_monad_laws) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <h3 id="-section-id-maybe-monad-maybe-section-"><section id='maybe-monad'>Maybeモナドでエラーを処理する</section></h3>
<blockquote>
<p>参考資料: <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe">https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe</a></p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'Maybeモナドでエラーを処理する'</span>, () =&gt; {
    describe(<span class="hljs-string">'Maybeモナドを作る'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p><strong>リスト7.91</strong> Maybeの代数的構造</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(algebraic_type_maybe) */</span>
      <span class="hljs-keyword">var</span> maybe = {
        match: (exp, pattern) =&gt; {
          <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
        },
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.just(value);
          };
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.nothing(_);
          };
        }
      };
      <span class="hljs-comment">/* #@range_end(algebraic_type_maybe) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p><strong>リスト7.92</strong> Maybeモナドの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> MAYBE = {
        <span class="hljs-comment">/* #@range_begin(maybe_monad) */</span>
        <span class="hljs-comment">/* unit:: T =&gt; MAYBE[T] */</span>
        unit: (value) =&gt; {
          <span class="hljs-keyword">return</span> maybe.just(value);
        },
        <span class="hljs-comment">/* flatMap:: MAYBE[T] =&gt; FUN[T =&gt; MAYBE[U]] =&gt; MAYBE[U] */</span>
        flatMap: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (transform) =&gt; {
            <span class="hljs-keyword">return</span> maybe.match(instanceM,{
              <span class="hljs-comment">/* 正常な値の場合は、transform関数を計算する */</span>
              just: (value) =&gt; { 
                <span class="hljs-keyword">return</span> transform(value);
              },
              <span class="hljs-comment">/* エラーの場合は、何もしない */</span>
              nothing: (_) =&gt; { 
                <span class="hljs-keyword">return</span> maybe.nothing();
              }
            });
          };
        },
        <span class="hljs-comment">/* ヘルパー関数  */</span>
        getOrElse: (instanceM) =&gt; {
          <span class="hljs-keyword">return</span> (alternate) =&gt; {
            <span class="hljs-keyword">return</span> maybe.match(instanceM,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> value;
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> alternate;
              }
            });
          };
        },
        <span class="hljs-comment">/* #@range_end(maybe_monad) */</span>
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p><strong>リスト7.93</strong> Maybeモナドの利用法</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">"Maybeモナドの利用法"</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(maybe_monad_add_test) */</span>
        <span class="hljs-comment">/* 足し算を定義する */</span>
        <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
          <span class="hljs-keyword">return</span> MAYBE.flatMap(maybeA)((a) =&gt; {
            <span class="hljs-keyword">return</span> MAYBE.flatMap(maybeB)((b) =&gt; {
              <span class="hljs-keyword">return</span> MAYBE.unit(a + b);
            });
          });
        };
        <span class="hljs-keyword">var</span> justOne = maybe.just(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">var</span> justTwo = maybe.just(<span class="hljs-number">2</span>);

        expect(
          MAYBE.getOrElse(add(justOne,justOne))(<span class="hljs-literal">null</span>) 
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        expect(
          MAYBE.getOrElse(add(justOne,maybe.nothing()))(<span class="hljs-literal">null</span>)
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        <span class="hljs-comment">/* #@range_end(maybe_monad_add_test) */</span>
        next();
      });
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <h3 id="-section-id-io-monad-io-section-"><section id='io-monad'>IOモナドで副作用を閉じ込める</section></h3>
<blockquote>
<p>参考資料: <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO">https://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO</a></p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'IOモナドで副作用を閉じ込める'</span>, () =&gt; {
    <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
      <span class="hljs-keyword">return</span> data.call(pattern, pattern);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p><strong>リスト7.94</strong> Pair型の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* #@range_begin(pair_datatype) */</span>
    <span class="hljs-keyword">var</span> pair = {
      <span class="hljs-comment">/* pair のデータ構造 */</span>
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(left, right);
        };
      },
      <span class="hljs-comment">/* ペアの右側を取得する */</span>
      right: (tuple) =&gt; {
        <span class="hljs-keyword">return</span> match(tuple, {
          cons: (left, right) =&gt; {
            <span class="hljs-keyword">return</span> right;
          }
        });
      },
      <span class="hljs-comment">/* ペアの左側を取得する */</span>
      left: (tuple) =&gt; {
        <span class="hljs-keyword">return</span> match(tuple, {
          cons: (left, right) =&gt; {
            <span class="hljs-keyword">return</span> left;
          }
        });
      }
    };
    <span class="hljs-comment">/* #@range_end(pair_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p><strong>リスト7.95</strong> 外界を明示したIOモナドの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    describe(<span class="hljs-string">'外界を明示したIOモナドの定義'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> IO = {
        <span class="hljs-comment">/* #@range_begin(io_monad_definition_with_world) */</span>
        <span class="hljs-comment">/* unit:: T =&gt; IO[T] */</span>
        unit: (any) =&gt; {
          <span class="hljs-keyword">return</span> (world) =&gt;  {  <span class="hljs-comment">// worldは現在の外界</span>
            <span class="hljs-keyword">return</span> pair.cons(any, world);
          };
        },
        <span class="hljs-comment">/* flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U] */</span>
        flatMap: (instanceA) =&gt; {
          <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: FUN[T =&gt; IO[U]]</span>
            <span class="hljs-keyword">return</span> (world) =&gt; {
              <span class="hljs-keyword">var</span> newPair = instanceA(world); <span class="hljs-comment">// 現在の外界のなかで instanceAのIOアクションを実行する</span>
              <span class="hljs-keyword">return</span> pair.match(newPair,{
                cons: (value, newWorld) =&gt; {
                  <span class="hljs-keyword">return</span> actionAB(value)(newWorld); <span class="hljs-comment">// 新しい外界のなかで、actionAB(value)で作られたIOアクションを実行する</span>
                }
              });
            };
          };
        },
        <span class="hljs-comment">/* #@range_end(io_monad_definition_with_world) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p><strong>リスト7.96</strong> IOモナドの補助関数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(io_monad_definition_with_world_helper_function) */</span>
        <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
        done: (any) =&gt; {
          <span class="hljs-keyword">return</span> IO.unit();
        },
        <span class="hljs-comment">/* run:: IO[A] =&gt; A */</span>
        run: (instance) =&gt; {
          <span class="hljs-keyword">return</span> (world) =&gt; {
            <span class="hljs-keyword">var</span> newPair = instance(world); <span class="hljs-comment">// IOモナドのインスタンス(アクション)を現在の外界に適用する</span>
            <span class="hljs-keyword">return</span> pair.left(newPair);     <span class="hljs-comment">// 結果だけを返す</span>
          };
        }
        <span class="hljs-comment">/* #@range_end(io_monad_definition_with_world_helper_function) */</span>
      }; <span class="hljs-comment">// IO monad</span>
      IO.println = (message) =&gt; {
        <span class="hljs-keyword">return</span> (world) =&gt; { <span class="hljs-comment">// IOモナドを返す</span>
          <span class="hljs-built_in">console</span>.log(message);
          <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(world);
        };
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p><strong>リスト7.98</strong> run関数の利用法</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(run_println) */</span>
      <span class="hljs-comment">/* 初期の外界に null をバインドする */</span>
      <span class="hljs-keyword">var</span> initialWorld = <span class="hljs-literal">null</span>; 
      expect(
        IO.run(IO.println(<span class="hljs-string">"我輩は猫である"</span>))(initialWorld)
      ).to.eql(
        <span class="hljs-literal">null</span>
      );
      <span class="hljs-comment">/* #@range_end(run_println) */</span>
    });
    describe(<span class="hljs-string">'外界を引数に持たないIOモナド'</span>, () =&gt; {
      <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p><strong>リスト7.99</strong> 外界を明示しないIOモナドの定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(io_monad_definition) */</span>
      <span class="hljs-keyword">var</span> IO = {
        <span class="hljs-comment">/* unit:: T =&gt; IO[T] */</span>
        unit : (any) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界を明示する必要はない</span>
            <span class="hljs-keyword">return</span> any;
          };
        },
        <span class="hljs-comment">/* flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U] */</span>
        flatMap : (instanceA) =&gt; {
          <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> IO.run(actionAB(IO.run(instanceA)));
            }
          };
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>間違った定義
flatMap: (instanceA) =&gt; {
  return (actionAB) =&gt; { // actionAB:: A =&gt; IO[B]
    return actionAB(IO.run(instanceA)); 
  };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
        done : (any) =&gt; {
          <span class="hljs-keyword">return</span> IO.unit();
        },
        <span class="hljs-comment">/* run:: IO[A] =&gt; A */</span>
        run : (instance) =&gt; {
          <span class="hljs-keyword">return</span> instance();
        },
        <span class="hljs-comment">/* readFile:: STRING =&gt; IO[STRING] */</span>
        readFile : (path) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; {
            <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
            <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
            <span class="hljs-keyword">return</span> IO.unit(content)();
          };
        },
        <span class="hljs-comment">/* println:: STRING =&gt; IO[null] */</span>
        println : (message) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; {
            <span class="hljs-built_in">console</span>.log(message);
            <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)();
          };
        },
        writeFile : (path) =&gt; {
          <span class="hljs-keyword">return</span> (content) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
              fs.writeFileSync(path,content);
              <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)();
            };
          };
        }
      }; <span class="hljs-comment">// IO monad</span>
      <span class="hljs-comment">/* #@range_end(io_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p><strong>リスト7.100</strong> run関数の利用法</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      it(<span class="hljs-string">'run関数の利用法'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(run_println_without_world) */</span>
        expect(
          <span class="hljs-comment">/* 外界を指定する必要はありません */</span>
          IO.run(IO.println(<span class="hljs-string">"名前はまだない"</span>)) 
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
        <span class="hljs-comment">/* #@range_end(run_println_without_world) */</span>
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <h4 id="io-">IOアクションを合成する</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>      describe(<span class="hljs-string">'IOアクションを合成する'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(io_monad_is_composable) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p><strong>リスト7.102</strong> seq関数の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b] */</span>
        IO.seq = (instanceA) =&gt; {
          <span class="hljs-keyword">return</span> (instanceB) =&gt; {
            <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
              <span class="hljs-keyword">return</span> instanceB;
            });
          };
        };
        IO.seqs = (alist) =&gt; {
          <span class="hljs-keyword">return</span> list.foldr(alist)(list.empty())(IO.done());
        };
        <span class="hljs-comment">/* IO.putc:: CHAR =&gt; IO[] */</span>
        IO.putc = (character) =&gt; {
          <span class="hljs-keyword">return</span> (_) =&gt; {
            process.stdout.write(character);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          };
        };
        <span class="hljs-comment">/* IO.puts:: LIST[CHAR] =&gt; IO[] */</span>
        IO.puts = (alist) =&gt; {
          <span class="hljs-keyword">return</span> match(alist, {
            empty: () =&gt; {
              <span class="hljs-keyword">return</span> IO.done();
            },
            cons: (head, tail) =&gt; {
              <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
            }
          });
        };
        <span class="hljs-comment">/* IO.getc:: IO[CHAR] */</span>
        IO.getc = () =&gt; {
          <span class="hljs-keyword">var</span> continuation = () =&gt; {
            <span class="hljs-keyword">var</span> chunk = process.stdin.read();
            <span class="hljs-keyword">return</span> chunk;
          }; 
          process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
          <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
        };
        <span class="hljs-comment">/* #@range_end(io_monad_is_composable) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p><strong>リスト7.103</strong> stringモジュール</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(string_module) */</span>
        <span class="hljs-keyword">var</span> string = {
          <span class="hljs-comment">/* 先頭文字を取得する */</span>
          head: (str) =&gt; {
            <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>];
          },
          <span class="hljs-comment">/* 後尾文字列を取得する */</span>
          tail: (str) =&gt; {
            <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">1</span>);
          },
          <span class="hljs-comment">/* 空の文字列かどうかを判定する */</span>
          isEmpty: (str) =&gt; {
            <span class="hljs-keyword">return</span> str.length === <span class="hljs-number">0</span>;
          },
          <span class="hljs-comment">/* 文字列を文字のリストに変換する */</span>
          toList: (str) =&gt; {
            <span class="hljs-keyword">if</span>(string.isEmpty(str)) {
              <span class="hljs-keyword">return</span> list.empty();
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> list.cons(string.head(str), 
                               string.toList(string.tail(str)));
            }
          }
        };
        <span class="hljs-comment">/* #@range_end(string_module) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>it(‘IO.putcのテスト’, (next) =&gt; {
  expect(
    IO.putc(‘a’)
  ).to.eql(
    IO.putc(‘a’)
  );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        it(<span class="hljs-string">'stringのテスト'</span>, (next) =&gt; {
          expect(
            string.head(<span class="hljs-string">"abc"</span>)
          ).to.eql(
            <span class="hljs-string">'a'</span>
          );
          expect(
            string.tail(<span class="hljs-string">"abc"</span>)
          ).to.eql(
            <span class="hljs-string">'bc'</span>
          );
          next();
        });
      });
    });
  }); <span class="hljs-comment">// IOモナドで副作用を閉じ込める</span>
}); <span class="hljs-comment">// モナド</span></pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p><a href="index.html">目次に戻る</a> <a href="chap08.spec.html">次章に移る</a> </p>

            </div>
            
        </li>
        
    </ul>
  <!-- <div id="footer">  目次に戻る。 </div> -->
  <!-- </div> -->
</body>
</html>
