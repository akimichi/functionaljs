<!DOCTYPE html>

<html>
<head>
  <title>chap06.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap06.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data(pattern);
};


<span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = fun;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
      result = result(<span class="hljs-built_in">arguments</span>[i]);
    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-keyword">var</span> flip = (fun) =&gt; {
  <span class="hljs-keyword">return</span>  (f) =&gt; {
    <span class="hljs-keyword">return</span> (g) =&gt; {
      <span class="hljs-keyword">return</span> fun(g)(f);
    };
  };
};

<span class="hljs-keyword">var</span> id = (any) =&gt; {
  <span class="hljs-keyword">return</span> any;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>var compose = (f) =&gt; {
  var self = this;
  return (g) =&gt; {
    return (arg) =&gt; {
      return f.call(self,
                    g.call(self,arg));
    };
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> compose = (f) =&gt; {
  <span class="hljs-keyword">return</span> (g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1 id="-">関数の使い方</h1>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数の使い方'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2 id="-">関数の基本</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'関数の基本'</span>, () =&gt; {
    <span class="hljs-keyword">var</span> seq = {
      match: (data, pattern) =&gt; {
        <span class="hljs-keyword">return</span> data(pattern);
      },
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty();
        };
      },
      cons: (value, list) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(value, list);
        };
      },
      isEmpty: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
          empty: <span class="hljs-literal">true</span>,
          cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });
      },
      head: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, {
          empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> head;
          }
        });
      },
      tail: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, {
          empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> tail;
          }
        });
      }
    };
    <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
      <span class="hljs-keyword">return</span> infiniteLoop(_);
    };
    describe(<span class="hljs-string">'関数の定義'</span>, () =&gt; {
      it(<span class="hljs-string">'恒等関数の定義'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(identity_function_definition) */</span>
        <span class="hljs-keyword">var</span> identity = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-comment">/* #@range_end(identity_function_definition) */</span>
        <span class="hljs-comment">/* #@range_begin(identity_function_test) */</span>
        expect(
          identity(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          identity(<span class="hljs-string">"a"</span>)
        ).to.eql(
          <span class="hljs-string">"a"</span>
        );
        <span class="hljs-comment">/* #@range_end(identity_function_test) */</span>
        next();
      });
      it(<span class="hljs-string">'succ関数の定義'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(succ_function_definition) */</span>
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        <span class="hljs-comment">/* #@range_end(succ_function_definition) */</span>
        <span class="hljs-comment">/* テスト */</span>
        <span class="hljs-comment">/* #@range_begin(succ_function_test) */</span>
        expect(
          succ(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 0 を引数にsucc関数を適用する</span>
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          succ(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 1 を引数にsucc関数を適用する</span>
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(succ_function_test) */</span>
        next();
      });
      it(<span class="hljs-string">'複数の引数を持つ関数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(add_function_definition) */</span>
        <span class="hljs-keyword">var</span> add = (n, m) =&gt; {
          <span class="hljs-keyword">return</span> n + m;
        };
        <span class="hljs-comment">/* #@range_end(add_function_definition) */</span>
        <span class="hljs-comment">/* テスト */</span>
        expect(
          add(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        next();
      });
      it(<span class="hljs-string">'引数を参照しない関数'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(constant_one_function) */</span>
        <span class="hljs-keyword">var</span> alwaysOne = (x) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        };
        <span class="hljs-comment">/* #@range_end(constant_one_function) */</span>
        expect(
          alwaysOne(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          alwaysOne(<span class="hljs-string">"a"</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/* #@range_begin(left_function) */</span>
        <span class="hljs-keyword">var</span> left = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
        <span class="hljs-comment">/* #@range_end(left_function) */</span>
        expect(
          left(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        next();
      });
      it(<span class="hljs-string">'関数の変数へのバインド'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(function_bound_to_variable) */</span>
        <span class="hljs-keyword">var</span> succ = (x) =&gt; {
          <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
        };
        <span class="hljs-comment">/* #@range_end(function_bound_to_variable) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'関数の適用'</span>, () =&gt; {
      describe(<span class="hljs-string">'関数適用と置換ルール'</span>, () =&gt; {
        describe(<span class="hljs-string">'関数の評価戦略'</span>, () =&gt; {
          it(<span class="hljs-string">'JavaScriptの正格評価'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(strict_evaluation_in_javascript) */</span>
            <span class="hljs-keyword">var</span> left = (x,y) =&gt; {
              <span class="hljs-keyword">return</span> x;
            };
            expect(
              left(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
              <span class="hljs-keyword">return</span> infiniteLoop(_);
            };

            <span class="hljs-comment">/* このテストは無限ループになるのでコメントアウトしています
               expect(
               left(1, infiniteLoop())
               ).to.be.ok()
            */</span>
            <span class="hljs-comment">/* #@range_end(strict_evaluation_in_javascript) */</span>
            next();
          });
          it(<span class="hljs-string">'条件文と遅延評価'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(conditional_is_nonstrict) */</span>
            <span class="hljs-keyword">var</span> infiniteLoop = () =&gt; {
              <span class="hljs-keyword">return</span> infiniteLoop();
            };
            
            <span class="hljs-keyword">var</span> conditional = (n) =&gt; {
              <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> infiniteLoop(); <span class="hljs-comment">// 条件文が真の場合には評価されない</span>
              }
            };
            expect(
              conditional(<span class="hljs-number">1</span>) 
            ).to.eql(
              <span class="hljs-literal">true</span>
            );
            <span class="hljs-comment">/* #@range_end(conditional_is_nonstrict) */</span>
            next();
          });
          it(<span class="hljs-string">'乗算の遅延評価'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(multiply_lazy_evaluation) */</span>
            <span class="hljs-keyword">var</span> multiply = (x,y) =&gt; {
              <span class="hljs-keyword">if</span>(x() === <span class="hljs-number">0</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> x() * y();
              }
            };
            expect(
              multiply((_) =&gt; { <span class="hljs-comment">// 0 を関数でラッピングする</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
              }, (_) =&gt; {       <span class="hljs-comment">// 3 を関数でラッピングする</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
              })
            ).to.eql(
              <span class="hljs-number">0</span>
            );
            <span class="hljs-comment">/* #@range_end(multiply_lazy_evaluation) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>var number = (n) =&gt; {
  return () =&gt; { // サンクを返す
    return n;
  };
};
expect(
  multiply(number(0),number(3))
).to.eql(
  0
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            next();
          });
        });
        describe(<span class="hljs-string">'thunkを使う'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(definition_thunk_force) */</span>
          <span class="hljs-keyword">var</span> thunk = (func) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt; {
              <span class="hljs-keyword">return</span> (_) =&gt; { <span class="hljs-comment">// サンクを返す</span>
                <span class="hljs-keyword">return</span> func(arg);
              };
            };
          };
          <span class="hljs-keyword">var</span> force = (thunk) =&gt; {
            <span class="hljs-keyword">return</span> thunk();
          };
          <span class="hljs-comment">/* #@range_end(definition_thunk_force) */</span>
          it(<span class="hljs-string">'thunkによる遅延評価'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(nonstrict_function_via_thunk) */</span>
            <span class="hljs-keyword">var</span> multiply = (thunkX,thunkY) =&gt; {
              <span class="hljs-keyword">if</span>(force(thunkX) === <span class="hljs-number">0</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> thunkX() * thunkY(); <span class="hljs-comment">// サンクを評価する</span>
              }
            };
            <span class="hljs-keyword">var</span> id = (any) =&gt; {
              <span class="hljs-keyword">return</span> any;
            };
            expect(
              multiply((_) =&gt; { <span class="hljs-comment">// サンクで包む</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
              }, (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
              })
            ).to.eql(
              <span class="hljs-number">0</span>
            );
            <span class="hljs-comment">/* #@range_end(nonstrict_function_via_thunk) */</span>
            next();
          });
          it(<span class="hljs-string">'thunkによる条件式'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(functionalIf_via_thunk) */</span>
            <span class="hljs-keyword">var</span> functionalIf = (predicate, trueClauseThunk, falseClauseThunk) =&gt; {
              <span class="hljs-keyword">if</span>(predicate){
                <span class="hljs-keyword">return</span> trueClauseThunk(); <span class="hljs-comment">// 判定式が真の場合に実行する</span>
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> falseClauseThunk();  <span class="hljs-comment">// 判定式が真の場合に実行する</span>
              }
            };
            <span class="hljs-comment">/* テスト */</span>
            expect(
              functionalIf((<span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span>), (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
              }, (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
              })
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(functionalIf_via_thunk) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>expect(
  functionalIf((2 &gt; 3), 2, 3)
).to.eql(
  3
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            next();
          });
          describe(<span class="hljs-string">'thunkによるStream型'</span>, () =&gt; {
            <span class="hljs-comment">/* #@range_begin(stream_with_thunk) */</span>
            <span class="hljs-keyword">var</span> stream = {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> (pattern) =&gt; {
                  <span class="hljs-keyword">return</span> pattern.empty();
                };
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> (pattern) =&gt; {
                  <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
                };
              },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>head:: STREAM[T] =&gt; T </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-comment">/* ストリーム型headの定義は、リスト型headと同じ */</span>
              head: (astream) =&gt; {      
                <span class="hljs-keyword">return</span> match(astream,{
                  empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; },
                  cons: (value, tailThunk) =&gt; { <span class="hljs-keyword">return</span> value; }
                });
              },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>tail:: STREAM[T] =&gt; STREAM[T] </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              tail: (astream) =&gt; {
                <span class="hljs-keyword">return</span> match(astream,{
                  empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; },
                  cons: (head, tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> tailThunk();  <span class="hljs-comment">// ここで初めてサンクを評価する</span>
                  }
                });
              }
            };
            <span class="hljs-comment">/* #@range_end(stream_with_thunk) */</span>
            it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
              <span class="hljs-comment">/* #@range_begin(stream_with_thunk_test) */</span>
              <span class="hljs-keyword">var</span> theStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.empty();
                });
              });
              expect(
                stream.head(theStream)
              ).to.eql(
                <span class="hljs-number">1</span>
              );
              <span class="hljs-comment">/* #@range_end(stream_with_thunk_test) */</span>
              next();
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>it(“stream#map”, (next) =&gt; {
 /<em> #@range_begin(stream_map_test) </em>/
 var lazyList = stream.cons(‘a’, (<em>) =&gt; {
   return stream.cons(‘b’,(</em>) =&gt; {
     return stream.empty();
   });
 });
 var capitalise = (ch) =&gt; {
   return ch.toUpperCase();
 };</p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p> expect(
   stream.toArray(stream.map(lazyList)(capitalise))
 ).to.eql(
   [“A”,”B”]
 );
 /<em> #@range_end(stream_map_test) </em>/
 next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            describe(<span class="hljs-string">"無限ストリーム"</span>, () =&gt; {
              <span class="hljs-comment">/* #@range_begin(infinite_ones) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>ones = [1,1,1,1,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
                <span class="hljs-keyword">return</span> ones; <span class="hljs-comment">// onesを再帰的に呼び出す</span>
              });
              <span class="hljs-comment">/* #@range_end(infinite_ones) */</span>
              <span class="hljs-comment">/* #@range_begin(infinite_integer) */</span>
              <span class="hljs-keyword">var</span> integersFrom = (n) =&gt; {
                <span class="hljs-keyword">return</span> stream.cons(n, (_) =&gt; {
                  <span class="hljs-keyword">return</span> integersFrom(n + <span class="hljs-number">1</span>);
                });
              };
              <span class="hljs-comment">/* #@range_end(infinite_integer) */</span>
              <span class="hljs-comment">/* #@range_begin(infinite_ones_test) */</span>
              expect(
                stream.head(ones) <span class="hljs-comment">// 最初の要素を取りだす</span>
              ).to.eql(
                <span class="hljs-number">1</span>
              );
              expect(
                stream.head(stream.tail(ones))  <span class="hljs-comment">// 2番目の要素を取りだす</span>
              ).to.eql(
                <span class="hljs-number">1</span>
              );
              <span class="hljs-comment">/* #@range_end(infinite_ones_test) */</span>
              it(<span class="hljs-string">"無限の整数列をテストする"</span>, (next) =&gt; {
                <span class="hljs-keyword">var</span> list = {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>match: (data, pattern) =&gt; {
  return data.call(list, pattern);
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> (pattern) =&gt; {
                      <span class="hljs-keyword">return</span> pattern.empty();
                    };
                  },
                  cons: (value, list) =&gt; {
                    <span class="hljs-keyword">return</span> (pattern) =&gt; {
                      <span class="hljs-keyword">return</span> pattern.cons(value, list);
                    };
                  },
                  isEmpty: (alist) =&gt; {
                    <span class="hljs-keyword">return</span> match(alist, { <span class="hljs-comment">// match関数で分岐する</span>
                      empty: <span class="hljs-literal">true</span>,
                      cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                      }
                    });
                  },
                  head: (alist) =&gt; {
                    <span class="hljs-keyword">return</span> match(alist, {
                      empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
                      cons: (head, tail) =&gt; {
                        <span class="hljs-keyword">return</span> head;
                      }
                    });
                  },
                  tail: (alist) =&gt; {
                    <span class="hljs-keyword">return</span> match(alist, {
                      empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
                      cons: (head, tail) =&gt; {
                        <span class="hljs-keyword">return</span> tail;
                      }
                    });
                  },
                  <span class="hljs-comment">/* #@range_begin(list_toArray) */</span>
                  toArray: (alist) =&gt; {
                    <span class="hljs-keyword">var</span> toArrayAux = (alist,accumulator) =&gt; {
                      <span class="hljs-keyword">return</span> match(alist, {
                        empty: (_) =&gt; {
                          <span class="hljs-keyword">return</span> accumulator;  
                        },
                        cons: (head, tail) =&gt; {
                          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
                        }
                      });
                    };
                    <span class="hljs-keyword">return</span> toArrayAux(alist, []);
                  }
                };
                <span class="hljs-comment">/* #@range_end(list_toArray) */</span>
                <span class="hljs-keyword">var</span> stream = {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>match: (data, pattern) =&gt; {
  return data.call(stream,pattern);
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> (pattern) =&gt; {
                      <span class="hljs-keyword">return</span> pattern.empty();
                    };
                  },
                  cons: (head,tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> (pattern) =&gt; {
                      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
                    };
                  },
                  head: (astream) =&gt; {      
                    <span class="hljs-keyword">return</span> match(astream,{
                      empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; },
                      cons: (value, tailThunk) =&gt; { <span class="hljs-keyword">return</span> value; }
                    });
                  },
                  tail: (astream) =&gt; {
                    <span class="hljs-keyword">return</span> match(astream,{
                      empty: (_) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; },
                      cons: (head, tailThunk) =&gt; {
                        <span class="hljs-keyword">return</span> tailThunk();  <span class="hljs-comment">// ここで初めてサンクを評価する</span>
                      }
                    });
                  },
                  <span class="hljs-comment">/* #@range_begin(stream_take) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>take:: (STREAM[T], NUM) =&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  take: (astream, n) =&gt; {
                    <span class="hljs-keyword">return</span> match(astream,{
                      empty: (_) =&gt; { 
                        <span class="hljs-keyword">return</span> list.empty();
                      },
                      cons: (head,tailThunk) =&gt; {
                        <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                          <span class="hljs-keyword">return</span> list.empty();
                        } <span class="hljs-keyword">else</span> {
                          <span class="hljs-keyword">return</span> list.cons(head,stream.take(tailThunk(),(n -<span class="hljs-number">1</span>)));
                        }
                      }
                    });
                  },
                  <span class="hljs-comment">/* #@range_end(stream_take) */</span>
                  <span class="hljs-comment">/* #@range_begin(stream_filter) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>filter :: (STREAM[T], FUN[T =&gt; BOOL]) =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  filter: (astream,predicate) =&gt; {
                    <span class="hljs-keyword">return</span> match(astream,{
                      empty: (_) =&gt; {
                        <span class="hljs-keyword">return</span> stream.empty();
                      },
                      cons: (head,tailThunk) =&gt; {
                        <span class="hljs-keyword">if</span>(predicate(head)){ <span class="hljs-comment">// 先頭の要素が条件に合致する場合、その要素を結果のリストの先頭に追加する</span>
                          <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                            <span class="hljs-keyword">return</span> stream.filter(tailThunk(),predicate);
                          });
                        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 先頭の要素が条件に合致しない場合、末尾要素に対してfilterを再帰的に呼び出す</span>
                          <span class="hljs-keyword">return</span> stream.filter(tailThunk(),predicate);
                        }
                      }
                    });
                  }
                  <span class="hljs-comment">/* #@range_end(stream_filter) */</span>
                };
                expect(
                  stream.head(integersFrom(<span class="hljs-number">1</span>))
                ).to.eql(
                  <span class="hljs-number">1</span>
                );
                expect(
                  stream.head(stream.tail(integersFrom(<span class="hljs-number">1</span>)))
                ).to.eql(
                  <span class="hljs-number">2</span>
                );
                <span class="hljs-comment">/* #@range_begin(infinite_integer_test) */</span>
                expect(
                  list.toArray(stream.take(integersFrom(<span class="hljs-number">1</span>), <span class="hljs-number">4</span>))
                ).to.eql(
                  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
                );
                <span class="hljs-comment">/* #@range_end(infinite_integer_test) */</span>
                <span class="hljs-comment">/* #@range_begin(stream_filter_test) */</span>
                expect(
                  <span class="hljs-comment">/* 無限の整数列から最初の4つの要素を取り出し、それを配列に変換する */</span>
                  list.toArray(stream.take(integersFrom(<span class="hljs-number">1</span>), <span class="hljs-number">4</span>))
                ).to.eql(
                  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
                );
                <span class="hljs-comment">/* #@range_end(stream_filter_test) */</span>
                <span class="hljs-comment">/* #@range_begin(infinite_even_integer) */</span>
                <span class="hljs-keyword">var</span> even = (n) =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> === (n % <span class="hljs-number">2</span>);
                };
                <span class="hljs-keyword">var</span> evenIntegers = stream.filter(integersFrom(<span class="hljs-number">1</span>),even);
                expect(
                  list.toArray(stream.take(evenIntegers, <span class="hljs-number">4</span>))
                ).to.eql(
                  [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span> ]
                );
                <span class="hljs-comment">/* #@range_end(infinite_even_integer) */</span>
                next();
              });
            });
          });
        }); <span class="hljs-comment">// thunk</span>
      });
      describe(<span class="hljs-string">'再帰的な関数適用'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> seq  = {
          match: (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data(pattern);
          },
          compose: (f,g) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt; {
              <span class="hljs-keyword">return</span> f(g(arg));
            };
          },
          flip: (fun) =&gt; {
            <span class="hljs-keyword">return</span>  (f) =&gt; {
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> fun(g)(f);
              };
            };
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          },
          head: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              }
            });
          },
          tail: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          },
          isEmpty: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          concat: (xs) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (ys) =&gt; {
              <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
                <span class="hljs-keyword">return</span> ys;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
              }
            };
          },
          last: (xs) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(xs, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> self.match(tail, {
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> head;
                  },
                  cons: (head, _) =&gt; {
                    <span class="hljs-keyword">return</span> self.last(tail);
                  }
                });
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          join: (list_of_list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
              <span class="hljs-keyword">return</span> self.empty();
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.concat(seq.head(list_of_list))(self.join(self.tail(list_of_list)));
            }
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          foldr: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (glue) =&gt; {
                expect(glue).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">return</span> self.match(list,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> glue(head)(self.foldr(tail)(accumulator)(glue));
                  }
                });</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>if(self.isEmpty(list)){
  return accumulator;
} else {
  var item = self.head(list);
  var tail = self.tail(list);
  return glue(item)(self.foldr(tail)(accumulator)(glue));
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              };
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          map: (list, transform) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> self.empty();
              },
              cons: (x,xs) =&gt; {
                <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs,transform));
              }
            });
          },
          <span class="hljs-comment">/* #@range_begin(list_reverse) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>reverse: (list, accumulator) =&gt; {
   var self = this;
   return self.match(list, {
    empty: (_) =&gt; {
       return accumulator;  // 空のリストの場合は終了
    },
    cons: (head, tail) =&gt; {
       return self.reverse(tail, self.cons(head, accumulator));
    }
   });
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
          <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
          filter: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (predicate) =&gt; {
              expect(predicate).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">var</span> filterAux = (list, accumulator) =&gt; {
                <span class="hljs-keyword">return</span> self.match(list,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head,tail) =&gt; {
                    <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
                      <span class="hljs-keyword">return</span> self.concat(self.concat(accumulator)(self.cons(head, self.empty())))(filterAux(tail, accumulator));</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>return self.concat(accumulator)(self.cons(head, self.empty()));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    } <span class="hljs-keyword">else</span>  {
                      <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
                    }
                  }
                });
              };
              <span class="hljs-keyword">return</span> filterAux(list, self.empty());
            };
          },
          <span class="hljs-comment">/* #@range_end(list_filter) */</span>
          <span class="hljs-comment">/* #@range_begin(list_toarray) */</span>
          toArray: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">var</span> toArrayHelper = (list,accumulator) =&gt; {
              <span class="hljs-keyword">return</span> self.match(list, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> toArrayHelper(tail, accumulator.concat(head));
                }
              });
            };
            <span class="hljs-keyword">return</span> toArrayHelper(list, []);
          }
          <span class="hljs-comment">/* #@range_end(list_toarray) */</span>
        };
        it(<span class="hljs-string">'dividesTimesの例'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(dividesTimes) */</span>
          <span class="hljs-keyword">var</span> multiplyOf = (n,m) =&gt; {
            <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          };
          expect(
            multiplyOf(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          <span class="hljs-keyword">var</span> dividesTimes = (n, m) =&gt; {
            <span class="hljs-keyword">var</span> dividesTimesHelper = (n,m,accumulator) =&gt; {
              <span class="hljs-keyword">if</span>(n &gt; m) {
                <span class="hljs-keyword">return</span> accumulator;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span>(multiplyOf(n,m)) {
                  <span class="hljs-keyword">return</span> dividesTimesHelper(n,m - n,accumulator + <span class="hljs-number">1</span>);
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> accumulator;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>return dividesTimesHelper(n,m,accumulator);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                }
              }
            };
            <span class="hljs-keyword">return</span> dividesTimesHelper(n,m,<span class="hljs-number">0</span>);
          };
          expect(
            dividesTimes(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            dividesTimes(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>)
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          <span class="hljs-comment">/* #@range_end(dividesTimes) */</span>
          next();
        });
        it(<span class="hljs-string">'list#lastをテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          expect(
            seq.last(list)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(list_last_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#mapをテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_map_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
          expect(
            seq.toArray(seq.map(list,(item) =&gt; {
              <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
            }))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#filterテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_filter_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
          };
          expect(
            seq.toArray(seq.filter(list)(even))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_filter_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#reverseをテストする'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> reverse = (list,accumulator) =&gt; {
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> reverse(tail, seq.cons(head, accumulator));
              }
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>/<strong><strong><strong><em>**</em></strong></strong></strong> テスト <strong><strong><strong><em>**</em></strong></strong></strong>/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(list_reverse_test) */</span>
          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.empty()));
          expect(
            seq.toArray(reverse(list, seq.empty()))</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>seq.toArray(seq.reverse(list, seq.empty()))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_reverse_test) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'関数を合成する'</span>, () =&gt; {
        it(<span class="hljs-string">'関数を連続して適用する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(function_applied_sequentially) */</span>
          <span class="hljs-keyword">var</span> double = (n) =&gt; {
            <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
          };
          <span class="hljs-keyword">var</span> negate = (n) =&gt; {
            <span class="hljs-keyword">return</span> - n;
          };
          expect(
            negate(double(<span class="hljs-number">2</span>))
          ).to.eql(
              -<span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_sequentially) */</span>
          <span class="hljs-comment">/* #@range_begin(function_applied_twice) */</span>
          <span class="hljs-keyword">var</span> twice = (f,arg) =&gt; {
            <span class="hljs-keyword">return</span> f(f(arg));
          };
          <span class="hljs-keyword">var</span> succ = (x) =&gt; {
            <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
          };
          expect(
            twice(succ,<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_twice) */</span>
          <span class="hljs-comment">/* #@range_begin(function_applied_ntimes) */</span>
          <span class="hljs-keyword">var</span> applyNTimes = (n, func) =&gt; {
            <span class="hljs-keyword">var</span> applyNTimesHelper = (n, func) =&gt; {
              <span class="hljs-keyword">return</span> (init) =&gt; {
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> accumulator;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> applyNTimesHelper(n - <span class="hljs-number">1</span>,func)(init)(func(accumulator));
                  };
                };
              };
            };
            <span class="hljs-keyword">return</span> applyNTimesHelper(n,func)(<span class="hljs-number">0</span>);
          };
          expect(
            applyNTimes(<span class="hljs-number">4</span>,succ)(<span class="hljs-number">0</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>applyNTimes(4)(succ)(0)(0) // succ(succ(succ(succ(0))))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_ntimes) */</span>
          next();
        });
        describe(<span class="hljs-string">'関数合成'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_definition) */</span>
          <span class="hljs-keyword">var</span> compose = (f,g,arg) =&gt; {
            <span class="hljs-keyword">return</span> f(g(arg));
          };
          <span class="hljs-comment">/* #@range_end(compose_definition) */</span>
          it(<span class="hljs-string">'否定を合成する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(compose_negation) */</span>
            <span class="hljs-keyword">var</span> negate = (n) =&gt; {
              <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> *  n;
            };
            expect(
              compose(negate,negate, <span class="hljs-number">2</span>)
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(compose_negation) */</span>
            next();
          });
          it(<span class="hljs-string">'1個の引数の関数を合成する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(compose_one_argument_functions) */</span>
            <span class="hljs-keyword">var</span> succ = (n) =&gt; {
              <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
            };
            <span class="hljs-keyword">var</span> prev = (n) =&gt; {
              <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
            };
            expect(
              compose(prev,succ,<span class="hljs-number">5</span>)
            ).to.eql(
              <span class="hljs-number">5</span>
            );
            expect(
              compose(prev,succ,<span class="hljs-number">2</span>)
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(compose_one_argument_functions) */</span>
            next();
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>it(“‘compose two argument functions’”, function(next) {
  var negate = function(x) {
    return -x;
  };
  var multiply = function(x,y){
    return x * y;
  };
  expect((<strong>.compose.bind(</strong>)(negate)(multiply))(2,3)).to.eql(-6);
  next();
});
it(“compose several functions”, function(next) {
  var not = function(x){
    return ! x;
  };
  expect(
    <strong>.compose.bind(</strong>)(not)(math.isEqual(3))(3)
  ).to.eql(
      false
  );
  // expect(
  //   <strong>.compose.bind(</strong>)(__.not)(math.isEqual(3))(3)
  // ).to.eql(
  //  false
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        });
        it(<span class="hljs-string">'再帰によるlast'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_recursive) */</span>
          <span class="hljs-keyword">var</span> last = (list) =&gt; {
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> seq.match(tail, {
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> head;
                  },
                  cons: (head, _) =&gt; {
                    <span class="hljs-keyword">return</span> last(tail);
                  }
                });
              }
            });
          };
          <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(list_last_recursive) */</span>
          next();
        });
        it(<span class="hljs-string">'合成によるlast'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_compose) */</span>
          <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          <span class="hljs-keyword">var</span> last = (list) =&gt; {
            <span class="hljs-keyword">return</span> compose(seq.head)(seq.reverse)(list);
          };
          <span class="hljs-comment">/* #@range_end(list_last_compose) */</span>
          next();
        });
      }); <span class="hljs-comment">// 関数を合成する</span>
    }); <span class="hljs-comment">// 関数の適用</span>
  }); <span class="hljs-comment">// 関数の基本</span>
  describe(<span class="hljs-string">'関数適用におけるJavaScriptの問題点'</span>, () =&gt; {
    it(<span class="hljs-string">'match and object'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> list = {
        match : (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        },
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty();
          };
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.cons(head,tail);
          };
        }
      };
      <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>, list.empty());
      list.match(theList, {
        empty: () =&gt; {
          <span class="hljs-keyword">return</span> expect().fail();
        },
        cons: (head, tail) =&gt; {
          expect(
            head
          ).to.eql(<span class="hljs-number">1</span>);
        }
      });
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>it(‘mother and baby’, (next) =&gt; {
  var mother = {
    name: ‘Eve’,
    eat : (food) =&gt; {
      return this.name + “ eats “ + food;
    },
    feed: (nutrition) =&gt; {
      return this.name + “ eats “ + nutrition;
      // return this.fetus.eat(nutrition);
    },
    fetus: {
      name: ‘Cain’,
      eat : (food) =&gt; {
        return this.name + “ eats “ + food;
      }
    }
  };
  var father = {
    name: ‘Adam’,
    feed: (fetus,nutrition) =&gt; {
      return fetus.eat(nutrition);
    }
  };
  expect(
    mother.feed(“an apple”)
  ).to.eql(
    “Cain eats an apple”
  );
  expect(
    mother.fetus.eat(“an apple”)
  ).to.eql(
    “Cain eats an apple”
  );
  expect(
    mother.eat(“an apple”)
  ).to.eql(
    “Eve eats an apple”
  );
  expect(
    mother.name
  ).to.eql(
    “Eve”
  );
  expect(
    father.name
  ).to.eql(
    “Adam”
  );
  expect(
    mother.fetus.name
  ).to.eql(
    “Cain”
  );
  var getName = (object) =&gt; {
    return object.name;
  };
  // expect(
  //   mother.eat(“an apple”)
  // ).to.eql(
  //   “A mother eats an apple”
  // );
  // expect(
  //   mother.feed(“some nutrition”)
  // ).to.eql(
  //   “The fetus eats some nutrition”
  // );
  // expect(
  //   father.feed(mother.fetus, “some nutrition”)
  // ).to.eql(
  //   “Fathers has no fetus”
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  });
  describe(<span class="hljs-string">'関数の純粋性'</span>, () =&gt; {
    it(<span class="hljs-string">'関数の参照透過性'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> succ = (n) =&gt; {
        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
      };
      <span class="hljs-comment">/* #@range_begin(succ_has_referential_transparency) */</span>
      expect(
        succ(<span class="hljs-number">1</span>)
      ).to.eql(
        succ(<span class="hljs-number">1</span>)
      );
      <span class="hljs-comment">/* #@range_end(succ_has_referential_transparency) */</span>
      next();
    });
    describe(<span class="hljs-string">'副作用が参照透過性を損なうこと'</span>, () =&gt; {
      describe(<span class="hljs-string">'ファイル操作が参照透過性を損なうこと'</span>, () =&gt; {
        it(<span class="hljs-string">'ファイルを操作する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(fileio_destroys_referential_transparency) */</span>
          <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// fsモジュールを変数fsにバインドする</span>
          <span class="hljs-comment">/* テストの実行前にあらかじめ "This is a test." という文字列をファイルに書きこんでおく。 */</span>
          fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is a test."</span>);

          <span class="hljs-comment">/* 第1回目のファイルの読込 */</span>
          <span class="hljs-keyword">var</span> text = fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>);
          expect(
            fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>)
          ).to.eql(
            <span class="hljs-string">"This is a test."</span>
          );
          <span class="hljs-comment">/* 途中でのファイルへの書込み */</span>
          fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is another test."</span>);
          
          <span class="hljs-comment">/* 第2回目のファイルの読込 */</span>
          expect(
            fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>)
          ).to.eql( 
            <span class="hljs-string">"This is another test."</span>  <span class="hljs-comment">// 最初の readFileSync関数の結果と異なっている</span>
          );
          <span class="hljs-comment">/* #@range_end(fileio_destroys_referential_transparency) */</span>
          next();
        });
      });
      it(<span class="hljs-string">'画面出力が参照透過性を損なうこと'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(log_destroys_referential_transparency) */</span>
        expect(
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is a test"</span>)
        ).to.eql(
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is anoter test"</span>)
        );
        <span class="hljs-comment">/* #@range_end(log_destroys_referential_transparency) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'副作用の分離'</span>, () =&gt; {
      it(<span class="hljs-string">'kestrelコンビネーター'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>this.timeout(2000);
var timeout = setTimeout(next, 2000);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(kestrel_combinator) */</span>
        <span class="hljs-keyword">var</span> kestrel = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x;
          };
        };
        <span class="hljs-comment">/* #@range_end(kestrel_combinator) */</span>
        <span class="hljs-comment">/* #@range_begin(kestrel_combinator_test) */</span>
        expect(
          kestrel(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/*
          expect(
          kestrel(1)(infiniteLoop())
          ).to.eql(
          1
          );
        */</span>
        <span class="hljs-comment">/* #@range_end(kestrel_combinator_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>setTimeout(function(){
  // happens 0.5 seconds later:
  expect(
 kestrel(1)(infiniteLoop())
  ).to.eql(
 1
  );
  next(); // this tells mocha to run the next test
},500);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      describe(<span class="hljs-string">'tapコンビネーター'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(tap_combinator) */</span>
        <span class="hljs-keyword">var</span> tap = (target,sideEffect) =&gt; {
          sideEffect(target); <span class="hljs-comment">// 副作用を実行する</span>
          <span class="hljs-keyword">return</span> target;
        };
        <span class="hljs-comment">/* #@range_end(tap_combinator) */</span>
        it(<span class="hljs-string">'tapコンビネーターによる console.logのテスト'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_console) */</span>
          <span class="hljs-keyword">var</span> consoleSideEffect = (any) =&gt; { <span class="hljs-comment">// 画面出力という副作用を実行する関数</span>
            <span class="hljs-built_in">console</span>.log(any);
          };
          expect(
            tap(succ(<span class="hljs-number">1</span>), consoleSideEffect)
          ).to.eql(
            tap(succ(<span class="hljs-number">1</span>), consoleSideEffect)
          );
          <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_console) */</span>
          <span class="hljs-keyword">var</span> updateSideEffect = (n) =&gt; {
            n = n + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> n;
          };
          expect(
            tap(succ(<span class="hljs-number">2</span>), updateSideEffect)
          ).to.eql(
            tap(succ(<span class="hljs-number">2</span>), updateSideEffect)
          );
          next();
        });
        it(<span class="hljs-string">'tapコンビネーターによるオブジェクトの操作'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_object) */</span>
          <span class="hljs-keyword">var</span> updateSideEffect = (obj) =&gt; {
            obj.name = <span class="hljs-string">"C3PO"</span>;
            <span class="hljs-keyword">return</span> obj;
          };
          <span class="hljs-keyword">var</span> r2d2 = {name: <span class="hljs-string">"R2D2"</span>};
          expect(
            tap(r2d2, updateSideEffect).name
          ).to.eql(
            tap(r2d2, updateSideEffect).name
          );
          expect(
           r2d2.name
          ).to.eql(
            <span class="hljs-string">"C3PO"</span>
          );
          <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_object) */</span>
          next();
        });
        it(<span class="hljs-string">'tapコンビネーターによるファイル入出力のテストは失敗する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(tap_combinator_test_in_fileio) */</span>
          <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// fsモジュールを変数fsにバインドする</span>
          fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is a test."</span>);

          <span class="hljs-keyword">var</span> fileioSideEffect = (n) =&gt; {
            <span class="hljs-keyword">var</span> content = fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>);
            <span class="hljs-comment">/* 途中でのファイルへの書込み */</span>
            fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is another test."</span>);
            <span class="hljs-keyword">return</span> content;
          };
          expect(
            tap(fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>), fileioSideEffect)
          ).not.to.eql( <span class="hljs-comment">// 両者は等しくない</span>
            tap(fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>), fileioSideEffect)
          );
          <span class="hljs-comment">/* #@range_end(tap_combinator_test_in_fileio) */</span>
          next();
        });
      });
    });
  }); <span class="hljs-comment">// 関数の純粋性</span>
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
