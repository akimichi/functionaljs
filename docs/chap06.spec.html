<!DOCTYPE html>

<html>
<head>
  <title>chap06.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap06.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = fun;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
      result = result(<span class="hljs-built_in">arguments</span>[i]);
    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
  <span class="hljs-keyword">return</span> data(pattern);
};

<span class="hljs-keyword">var</span> id = (any) =&gt; {
  <span class="hljs-keyword">return</span> any;
};

<span class="hljs-keyword">var</span> compose = (f) =&gt; {
  <span class="hljs-keyword">return</span> (g) =&gt; {
    <span class="hljs-keyword">return</span> (arg) =&gt; {
      <span class="hljs-keyword">return</span> f(g(arg));
    };
  };
};


<span class="hljs-keyword">var</span> seq  = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data(pattern);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>compose: (f,g) =&gt; {
   return (arg) =&gt; {
    return f(g(arg));
   };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flip: (fun) =&gt; {
    <span class="hljs-keyword">return</span>  (f) =&gt; {
      <span class="hljs-keyword">return</span> (g) =&gt; {
        <span class="hljs-keyword">return</span> fun(g)(f);
      };
    };
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, list) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, list);
    };
  },
  head: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> self.match(list, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> self.match(list, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> self.match(list, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xs) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
        <span class="hljs-keyword">return</span> ys;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
      }
    };
  },
  last: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> self.match(list, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> self.match(tail, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> head;
          },
          cons: (head, _) =&gt; {
            <span class="hljs-keyword">return</span> self.last(tail);
          }
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  join: (list_of_list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
      <span class="hljs-keyword">return</span> self.empty();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> self.concat(self.head(list_of_list))(self.join(self.tail(list_of_list)));
    }
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> self.match(list,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(self.foldr(tail)(accumulator)(glue));
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>if(self.isEmpty(list)){
  return accumulator;
} else {
  var item = self.head(list);
  var tail = self.tail(list);
  return glue(item)(self.foldr(tail)(accumulator)(glue));
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      };
    };
  },
  <span class="hljs-comment">/* #@range_begin(list_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]
map: (list, transform) =&gt; {
  return this.match(list,{
    empty: (_) =&gt; {
      return this.empty();
    },
    cons: (x,xs) =&gt; {
      return this.cons(transform(x),this.map(xs,transform));
    }
  });
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (list, transform) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> self.match(list,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> self.empty();
      },
      cons: (x,xs) =&gt; {
        <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs,transform));
      }
    });
  },
  <span class="hljs-comment">/* #@range_end(list_map) */</span>
  <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
  reverse: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> reverseAux = (list, accumulator) =&gt; {
      <span class="hljs-keyword">return</span> self.match(list, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> reverseAux(tail, self.cons(head, accumulator));
        }
      });
    };
    <span class="hljs-keyword">return</span> reverseAux(list, self.empty());
  },
  <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
  <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
  filter: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (predicate) =&gt; {
      expect(predicate).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">var</span> filterAux = (list, accumulator) =&gt; {
        <span class="hljs-keyword">return</span> self.match(list,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tail) =&gt; {
            <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
              <span class="hljs-keyword">return</span> self.concat(self.concat(accumulator)(self.cons(head, self.empty())))(filterAux(tail, accumulator));</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>return self.concat(accumulator)(self.cons(head, self.empty()));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="hljs-keyword">else</span>  {
              <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
            }
          }
        });
      };
      <span class="hljs-keyword">return</span> filterAux(list, self.empty());
    };
  },
  <span class="hljs-comment">/* #@range_end(list_filter) */</span>
  toArray: (list) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> toArrayAux = (list,accumulator) =&gt; {
      <span class="hljs-keyword">return</span> self.match(list, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
        }
      });
    };
    <span class="hljs-keyword">return</span> toArrayAux(list, []);
  }
};

it(<span class="hljs-string">'seqのテスト'</span>, (next) =&gt; {
  <span class="hljs-keyword">var</span> compose = (f) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> (g) =&gt; {
      <span class="hljs-keyword">return</span> (arg) =&gt; {
        <span class="hljs-keyword">return</span> f.call(self,
                      g.call(self,arg));
      };
    };
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>var compose = (f) =&gt; {
  return (g) =&gt; {
    return (arg) =&gt; {
      return f(g(arg));
    };
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
  expect(
    seq.head(sequence)
  ).to.eql(
    <span class="hljs-number">1</span>
  );
  expect(
    seq.toArray(sequence)
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
  );
  expect(
    seq.toArray(seq.reverse(sequence))
  ).to.eql(
    [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
  );
  expect(
    seq.head(seq.reverse(sequence))
  ).to.eql(
    <span class="hljs-number">4</span>
  );

  expect(
    seq.last(sequence)
  ).to.eql(
    <span class="hljs-number">4</span>
  );</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>init = reverse . tail . reverse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> init = (list) =&gt; {
    <span class="hljs-keyword">return</span> compose.call(seq,
                        seq.reverse)(compose.call(seq,
                                                  seq.tail)(seq.reverse))(list);
  };
  <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.empty())));
  expect(
    seq.toArray(init(list))
  ).to.eql(
    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
  );
  next();
});</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h1 id="-">関数の使い方</h1>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数の使い方'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="-">関数の基本</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'関数の基本'</span>, () =&gt; {
    <span class="hljs-keyword">var</span> seq = {
      match: (data, pattern) =&gt; {
        <span class="hljs-keyword">return</span> data(pattern);
      },
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.empty();
        };
      },
      cons: (value, list) =&gt; {
        <span class="hljs-keyword">return</span> (pattern) =&gt; {
          <span class="hljs-keyword">return</span> pattern.cons(value, list);
        };
      },
      isEmpty: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
          empty: <span class="hljs-literal">true</span>,
          cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });
      },
      head: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, {
          empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> head;
          },
        });
      },
      tail: (list) =&gt; {
        <span class="hljs-keyword">return</span> match(list, {
          empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> tail;
          }
        });
      }
    };
    <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
      <span class="hljs-keyword">return</span> infiniteLoop(_);
    };
    describe(<span class="hljs-string">'関数の定義'</span>, () =&gt; {
      it(<span class="hljs-string">'関数の変数へのバインド'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(function_bound_to_variable) */</span>
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-comment">/* #@range_end(function_bound_to_variable) */</span>
        <span class="hljs-comment">/* #@range_begin(identity_function_test) */</span>
        expect(
          id(<span class="hljs-number">1</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          id(<span class="hljs-string">"a"</span>)
        ).to.eql(
          <span class="hljs-string">"a"</span>
        );
        <span class="hljs-comment">/* #@range_end(identity_function_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'関数の適用'</span>, () =&gt; {
      describe(<span class="hljs-string">'関数適用と置換ルール'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> thunk = (func) =&gt; {
          <span class="hljs-keyword">return</span> (arg) =&gt; {
            <span class="hljs-keyword">return</span> (_) =&gt; {
              <span class="hljs-keyword">return</span> func(arg);
            };
          };
        };
        <span class="hljs-keyword">var</span> force = (thunk) =&gt; {
          <span class="hljs-keyword">return</span> thunk();
        };
        it(<span class="hljs-string">'thunkによる遅延評価'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(nonstrict_function_via_thunk) */</span>
          <span class="hljs-keyword">var</span> multiply = (thunkX,thunkY) =&gt; {
            <span class="hljs-keyword">if</span>(force(thunkX) === <span class="hljs-number">0</span>){
              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> force(thunkX) * force(thunkY);
            }
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>var multiply = (x,y) =&gt; {
  if(x() === 0){
    return 0;
  } else {
    return x() * y();
  }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> id = (any) =&gt; {
            <span class="hljs-keyword">return</span> any;
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>var thunk = (value) =&gt; {
  return () =&gt; {
    return value;
  };
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            multiply(thunk(id)(<span class="hljs-number">0</span>),thunk(id)(<span class="hljs-number">2</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>multiply(thunk(0),thunk(2))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ).to.eql(
            <span class="hljs-number">0</span>
          );
          <span class="hljs-comment">/* #@range_end(nonstrict_function_via_thunk) */</span>
          next();
        });
        it(<span class="hljs-string">'thunkによる条件式'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(functionalIf_via_thunk) */</span>
          <span class="hljs-keyword">var</span> functionalIf = (predicate, trueClauseThunk, falseClauseThunk) =&gt; {
            <span class="hljs-keyword">if</span>(predicate){
              <span class="hljs-keyword">return</span> force(trueClauseThunk); <span class="hljs-comment">// 判定式が真の場合に実行する</span>
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> force(falseClauseThunk);  <span class="hljs-comment">// 判定式が真の場合に実行する</span>
            }
          };
          <span class="hljs-comment">/* テスト */</span>
          expect(
            functionalIf((<span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span>), thunk(id)(<span class="hljs-number">2</span>), thunk(id)(<span class="hljs-number">3</span>))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(functionalIf_via_thunk) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>expect(
  functionalIf((2 &gt; 3), 2, 3)
).to.eql(
  3
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
        describe(<span class="hljs-string">'thunkによるStream型'</span>, () =&gt; {
          <span class="hljs-keyword">var</span> stream = {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                expect(pattern).to.an(<span class="hljs-string">'object'</span>);
                <span class="hljs-keyword">return</span> pattern.empty();
              };
            },
            cons: (head,tailThunk) =&gt; {
              expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                expect(pattern).to.an(<span class="hljs-string">'object'</span>);
                <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
              };
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            head: (lazyList) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
                },
                cons: (value, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> value;
                }
              });
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            tail: (lazyList) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
                },
                cons: (head, tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> tailThunk();
                }
              });
            },
            isEmpty: (lazyList) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });
            },
            map: (lazyList) =&gt; {
              <span class="hljs-keyword">return</span> (transform) =&gt; {
                <span class="hljs-keyword">return</span> match(lazyList,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> stream.empty();
                  },
                  cons: (head,tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
                      <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform)});
                  }
                });
              };
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="stream-concat">stream#concat</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>            concat: (xs) =&gt; {
              <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
                <span class="hljs-keyword">return</span> match(xs,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> ysThunk();
                  },
                  cons: (head,tailThunk) =&gt; {
                    <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                      <span class="hljs-keyword">return</span> stream.concat(tailThunk())(ysThunk);
                    });
                  }
                });
              };
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            flatten: (lazyList) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.empty();
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> stream.concat(head)((_) =&gt; {
                    <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
                  });
                }
              });
            }
          };
          it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,thunk(stream.empty)());
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>var lazyList = stream.cons(1, (<em>) =&gt; {
  return stream.cons(2,(</em>) =&gt; {
    return stream.empty();
  });
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            expect(
              stream.head(lazyList)
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            next();
          });
        });
      });
      describe(<span class="hljs-string">'関数の評価戦略'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(strict_evaluation_in_javascript) */</span>
        <span class="hljs-keyword">var</span> left = (x,y) =&gt; {
          <span class="hljs-keyword">return</span> x;
        };
        expect(
          left(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-keyword">var</span> infiniteLoop = (_) =&gt; {
          <span class="hljs-keyword">return</span> infiniteLoop(_);
        };

        <span class="hljs-comment">/* このテストは実行されると無限ループになるのでコメントアウトしています
           expect(
           left(1, infiniteLoop())
           ).to.be.ok()
        */</span>
        <span class="hljs-comment">/* #@range_end(strict_evaluation_in_javascript) */</span>

      });
      describe(<span class="hljs-string">'再帰的な関数の適用'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> seq  = {
          match: (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data(pattern);
          },
          compose: (f,g) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt; {
              <span class="hljs-keyword">return</span> f(g(arg));
            };
          },
          flip: (fun) =&gt; {
            <span class="hljs-keyword">return</span>  (f) =&gt; {
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> fun(g)(f);
              };
            };
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          },
          head: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              }
            });
          },
          tail: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          },
          isEmpty: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          concat: (xs) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (ys) =&gt; {
              <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
                <span class="hljs-keyword">return</span> ys;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
              }
            };
          },
          last: (xs) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(xs, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> self.match(tail, {
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> head;
                  },
                  cons: (head, _) =&gt; {
                    <span class="hljs-keyword">return</span> self.last(tail);
                  }
                });
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          join: (list_of_list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
              <span class="hljs-keyword">return</span> self.empty();
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.concat(seq.head(list_of_list))(self.join(self.tail(list_of_list)));
            }
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          foldr: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (glue) =&gt; {
                expect(glue).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">return</span> self.match(list,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head, tail) =&gt; {
                    <span class="hljs-keyword">return</span> glue(head)(self.foldr(tail)(accumulator)(glue));
                  }
                });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>if(self.isEmpty(list)){
  return accumulator;
} else {
  var item = self.head(list);
  var tail = self.tail(list);
  return glue(item)(self.foldr(tail)(accumulator)(glue));
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              };
            };
          },
          <span class="hljs-comment">/* #@range_begin(list_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]
map: (list, transform) =&gt; {
  return this.match(list,{
    empty: (_) =&gt; {
      return this.empty();
    },
    cons: (x,xs) =&gt; {
      return this.cons(transform(x),this.map(xs,transform));
    }
  });
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          map: (list, transform) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> self.empty();
              },
              cons: (x,xs) =&gt; {
                <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs,transform));
              }
            });
          },
          <span class="hljs-comment">/* #@range_end(list_map) */</span>
          <span class="hljs-comment">/* #@range_begin(list_reverse) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>reverse: (list, accumulator) =&gt; {
   var self = this;
   return self.match(list, {
    empty: (_) =&gt; {
       return accumulator;  // 空のリストの場合は終了
    },
    cons: (head, tail) =&gt; {
       return self.reverse(tail, self.cons(head, accumulator));
    }
   });
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
          <span class="hljs-comment">/* #@range_begin(list_filter) */</span>
          filter: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (predicate) =&gt; {
              expect(predicate).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">var</span> filterAux = (list, accumulator) =&gt; {
                <span class="hljs-keyword">return</span> self.match(list,{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> accumulator;
                  },
                  cons: (head,tail) =&gt; {
                    <span class="hljs-keyword">if</span>(predicate(head) === <span class="hljs-literal">true</span>){
                      <span class="hljs-keyword">return</span> self.concat(self.concat(accumulator)(self.cons(head, self.empty())))(filterAux(tail, accumulator));</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>return self.concat(accumulator)(self.cons(head, self.empty()));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    } <span class="hljs-keyword">else</span>  {
                      <span class="hljs-keyword">return</span> filterAux(tail, accumulator);
                    }
                  }
                });
              };
              <span class="hljs-keyword">return</span> filterAux(list, self.empty());
            };
          },
          <span class="hljs-comment">/* #@range_end(list_filter) */</span>
          <span class="hljs-comment">/* #@range_begin(list_toarray) */</span>
          toArray: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">var</span> toArrayAux = (list,accumulator) =&gt; {
              <span class="hljs-keyword">return</span> self.match(list, {
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
                },
                cons: (head, tail) =&gt; {
                  <span class="hljs-keyword">return</span> toArrayAux(tail, accumulator.concat(head));
                }
              });
            };
            <span class="hljs-keyword">return</span> toArrayAux(list, []);
          }
          <span class="hljs-comment">/* #@range_end(list_toarray) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>toArray: (list) =&gt; {
  var self = this;
  return self.foldr(list)([])(function (item) {
    return (accumulator) =&gt; {
      return [item].concat(accumulator);
      // return accumulator.concat(item);
    };
  });
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        };
        it(<span class="hljs-string">'factorialの例'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(naive_factorial) */</span>
          <span class="hljs-keyword">var</span> factorial = (n) =&gt; {
            <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);
            }
          };
          expect(
            factorial(<span class="hljs-number">3</span>)
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(naive_factorial) */</span>
          next();
        });
        it(<span class="hljs-string">'末尾再帰によるfactorialの例'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(tail_recursive_factorial) */</span>
          <span class="hljs-keyword">var</span> factorial = (n) =&gt; {
            <span class="hljs-keyword">var</span> factorialRec = (n, accumulator) =&gt; {
              <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * accumulator;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> factorialRec(n - <span class="hljs-number">1</span>, n * accumulator);
              };
            };
            <span class="hljs-keyword">return</span> factorialRec(n, <span class="hljs-number">1</span>);
          };
          expect(
            factorial(<span class="hljs-number">3</span>)
          ).to.eql(
            <span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(tail_recursive_factorial) */</span>
          next();
        });
        it(<span class="hljs-string">'list#lastをテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          expect(
            seq.last(list)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(list_last_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#mapをテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_map_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
          expect(
            seq.toArray(seq.map(list,(item) =&gt; {
              <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
            }))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_map_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#filterテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_filter_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty))));
          <span class="hljs-keyword">var</span> even = (n) =&gt; {
            <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
          };
          expect(
            seq.toArray(seq.filter(list)(even))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_filter_test) */</span>
          next();
        });
        it(<span class="hljs-string">'list#reverseをテストする'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> reverse = (list,accumulator) =&gt; {
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> accumulator;  <span class="hljs-comment">// 空のリストの場合は終了</span>
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> reverse(tail, seq.cons(head, accumulator))
              },
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>var toArray = (list) =&gt; {
  var toArrayAux = (list,accumulator) =&gt; {
    return seq.match(list, {
      empty: (_) =&gt; {
        return accumulator;  // 空のリストの場合は終了
      },
      cons: (head, tail) =&gt; {
        return toArrayAux(tail, accumulator.concat(head))
      },
    });
  };
  return toArrayAux(list, [])
};
/<strong><strong><strong><em>**</em></strong></strong></strong> テスト <strong><strong><strong><em>**</em></strong></strong></strong>/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(list_reverse_test) */</span>
          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.empty()));
          expect(
            seq.toArray(reverse(list, seq.empty()))</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>seq.toArray(seq.reverse(list, seq.empty()))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
          );
          <span class="hljs-comment">/* #@range_end(list_reverse_test) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'関数を合成する'</span>, () =&gt; {
        it(<span class="hljs-string">'関数を連続して適用する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(function_applied_sequentially) */</span>
          <span class="hljs-keyword">var</span> double = (n) =&gt; {
            <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
          };
          <span class="hljs-keyword">var</span> negate = (n) =&gt; {
            <span class="hljs-keyword">return</span> - n;
          };
          expect(
            negate(double(<span class="hljs-number">2</span>))
          ).to.eql(
              -<span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_sequentially) */</span>
          <span class="hljs-comment">/* #@range_begin(function_applied_twice) */</span>
          <span class="hljs-keyword">var</span> twice = (f,arg) =&gt; {
            <span class="hljs-keyword">return</span> f(f(arg));
          };
          <span class="hljs-keyword">var</span> succ = (x) =&gt; {
            <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
          };
          expect(
            twice(succ,<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_twice) */</span>
          <span class="hljs-comment">/* #@range_begin(function_applied_ntimes) */</span>
          <span class="hljs-keyword">var</span> applyNtimes = (n) =&gt; {
            <span class="hljs-keyword">return</span> (func) =&gt; {
              <span class="hljs-keyword">return</span> (init) =&gt; {
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> accumulator;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> applyNtimes(n - <span class="hljs-number">1</span>)(func)(init)(func(accumulator));
                  };
                };
              };
            };
          };
          expect(
            applyNtimes(<span class="hljs-number">4</span>)(succ)(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) <span class="hljs-comment">// succ(succ(succ(succ(0))))</span>
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(function_applied_ntimes) */</span>
          next();
        });
        describe(<span class="hljs-string">'関数合成'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_definition) */</span>
          <span class="hljs-keyword">var</span> compose = (f,g,arg) =&gt; {
            <span class="hljs-keyword">return</span> f(g(arg));
          };
          <span class="hljs-comment">/* #@range_end(compose_definition) */</span>
          it(<span class="hljs-string">'否定を合成する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(compose_negation) */</span>
            <span class="hljs-keyword">var</span> negate = (n) =&gt; {
              <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> *  n;
            };
            expect(
              compose(negate,negate, <span class="hljs-number">2</span>)
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(compose_negation) */</span>
            next();
          });
          it(<span class="hljs-string">'1個の引数の関数を合成する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(compose_one_argument_functions) */</span>
            <span class="hljs-keyword">var</span> succ = (n) =&gt; {
              <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
            };
            <span class="hljs-keyword">var</span> prev = (n) =&gt; {
              <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
            };
            expect(
              compose(prev,succ,<span class="hljs-number">5</span>)
            ).to.eql(
              <span class="hljs-number">5</span>
            );
            expect(
              compose(prev,succ,<span class="hljs-number">2</span>)
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(compose_one_argument_functions) */</span>
            next();
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>it(“‘compose two argument functions’”, function(next) {
  var negate = function(x) {
    return -x;
  };
  var multiply = function(x,y){
    return x * y;
  };
  expect((<strong>.compose.bind(</strong>)(negate)(multiply))(2,3)).to.eql(-6);
  next();
});
it(“compose several functions”, function(next) {
  var not = function(x){
    return ! x;
  };
  expect(
    <strong>.compose.bind(</strong>)(not)(math.isEqual(3))(3)
  ).to.eql(
      false
  );
  // expect(
  //   <strong>.compose.bind(</strong>)(__.not)(math.isEqual(3))(3)
  // ).to.eql(
  //  false
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        });
        it(<span class="hljs-string">'再帰によるlast'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_recursive) */</span>
          <span class="hljs-keyword">var</span> last = (list) =&gt; {
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> seq.match(tail, {
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> head;
                  },
                  cons: (head, _) =&gt; {
                    <span class="hljs-keyword">return</span> last(tail);
                  }
                });
              }
            });
          };
          <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          expect(
            last(sequence)
          ).to.eql(
            <span class="hljs-number">4</span>
          );
          <span class="hljs-comment">/* #@range_end(list_last_recursive) */</span>
          next();
        });
        it(<span class="hljs-string">'合成によるlast'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(list_last_compose) */</span>
          <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
          <span class="hljs-keyword">var</span> last = (list) =&gt; {
            <span class="hljs-keyword">return</span> compose(seq.head)(seq.reverse)(list);
          };
          <span class="hljs-comment">/* #@range_end(list_last_compose) */</span>
          next();
        });
      }); <span class="hljs-comment">// 関数を合成する</span>
    }); <span class="hljs-comment">// 関数の適用</span>
  }); <span class="hljs-comment">// 関数の基本</span>
  describe(<span class="hljs-string">'演算子'</span>, () =&gt; {

  });
  describe(<span class="hljs-string">'関数の純粋性'</span>, () =&gt; {
    describe(<span class="hljs-string">'副作用が参照透過性を損なうこと'</span>, () =&gt; {
      it(<span class="hljs-string">'console.logが参照透過性を損なうこと'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(log_destroys_referential_transparency) */</span>
        expect(
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is a test"</span>)
        ).to.eql(
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is anoter test"</span>)
        );
        <span class="hljs-comment">/* #@range_end(log_destroys_referential_transparency) */</span>
        next();
      });
      describe(<span class="hljs-string">'ファイル操作が参照透過性を損なうこと'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(fileio_destroys_referential_transparency) */</span>
        <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
        after(() =&gt; { <span class="hljs-comment">// テストの終了時に実行される</span>
          fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is a test."</span>);
        });
        it(<span class="hljs-string">'ファイルを操作する'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> text = fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>);
          fs.writeFileSync(<span class="hljs-string">'test/resources/file.txt'</span>, <span class="hljs-string">"This is another test."</span>)
          expect(
            fs.readFileSync(<span class="hljs-string">"test/resources/file.txt"</span>, <span class="hljs-string">'utf8'</span>)
          ).not.to.be(
            text
          );
          next();
        });
        <span class="hljs-comment">/* #@range_end(fileio_destroys_referential_transparency) */</span>
      });
    });
    describe(<span class="hljs-string">'副作用の分離'</span>, () =&gt; {
      it(<span class="hljs-string">'kestrelコンビネーター'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>this.timeout(2000);
var timeout = setTimeout(next, 2000);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* #@range_begin(kestrel_combinator) */</span>
        <span class="hljs-keyword">var</span> kestrel = (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x;
          };
        };
        <span class="hljs-comment">/* #@range_end(kestrel_combinator) */</span>
        <span class="hljs-comment">/* #@range_begin(kestrel_combinator_test) */</span>
        expect(
          kestrel(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-comment">/*
          expect(
          kestrel(1)(infiniteLoop())
          ).to.eql(
          1
          );
        */</span>
        <span class="hljs-comment">/* #@range_end(kestrel_combinator_test) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>setTimeout(function(){
  // happens 0.5 seconds later:
  expect(
 kestrel(1)(infiniteLoop())
  ).to.eql(
 1
  );
  next(); // this tells mocha to run the next test
},500);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        next();
      });
      it(<span class="hljs-string">'tapコンビネーター'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(tap_combinator) */</span>
        <span class="hljs-keyword">var</span> tap = (target) =&gt; {
          <span class="hljs-keyword">var</span> original = target;
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSideEffect</span>(<span class="hljs-params">sideEffect</span>) </span>{
            sideEffect(target);
            expect(original).to.eql(target);
            <span class="hljs-keyword">return</span> target;
          };
        };
        <span class="hljs-comment">/* #@range_end(tap_combinator) */</span>
        <span class="hljs-comment">/* #@range_begin(tap_combinator_test) */</span>
        <span class="hljs-keyword">var</span> consoleSideEffect = (any) =&gt; {
          <span class="hljs-built_in">console</span>.log(any);
        };
        <span class="hljs-keyword">var</span> target = <span class="hljs-number">1</span>;
        expect(
          tap(target)(consoleSideEffect)
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        <span class="hljs-keyword">var</span> updateSideEffect = (n) =&gt; {
          n = n + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">return</span> n;
        };
        expect(
          tap(target)(updateSideEffect)
        ).to.eql(
          target
        );
        <span class="hljs-comment">/* #@range_end(tap_combinator_test) */</span>
        next();
      });
    });
  }); <span class="hljs-comment">// 関数の純粋性</span>
  describe(<span class="hljs-string">'高階関数'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>var seq = {
  match: (data, pattern) =&gt; {
    return data(pattern);
  },
  empty: (pattern) =&gt; {
    return pattern.empty;
  },
  cons: (value, list) =&gt; {
    return (pattern) =&gt; {
      return pattern.cons(value, list);
    };
  },
  isEmpty: (list) =&gt; {
    return match(list, { // match関数で分岐する
      empty: true,
      cons: (head, tail) =&gt; { // headとtailにそれぞれ先頭要素、末尾要素が入る
        return false;
      }
    });
  },
  head: (list) =&gt; {
    return match(list, {
      empty: undefined, // 空のリストには先頭要素はありません
      cons: (head, tail) =&gt; {
        return head;
      }
    });
  },
  tail: (list) =&gt; {
    return match(list, {
      empty: undefined,  // 空のリストには末尾要素はありません
      cons: (head, tail) =&gt; {
        return tail;
      }
    });
  }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> stream = {
      empty: (index) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> (f) =&gt; {
          <span class="hljs-keyword">return</span> f(head,tailThunk);
        };
      },
      head: (lazyList) =&gt; {
        <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> head;
        });
      },
      tail: (lazyList) =&gt; {
        <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> tailThunk();
        });
      },
      at: (index,lazyList) =&gt; {
        <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head(lazyList);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.at(index -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.tail(lazyList));
        }
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>map: (lazyList, transform) =&gt; {
  var x = transform(this.head(lazyList));
  var xs = this.tail(lazyList);
  return this.cons(x, this.map(xs, transform));
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
    describe(<span class="hljs-string">'カリー化'</span>, () =&gt; {
      it(<span class="hljs-string">'カリー化された関数の単純な例'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(simple_curried_function) */</span>
        <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>) </span>{
          <span class="hljs-keyword">return</span> x + y ;
        };
        <span class="hljs-keyword">var</span> addCurried =  (x) =&gt; {
          <span class="hljs-keyword">return</span> (y) =&gt; {
            <span class="hljs-keyword">return</span> x + y ;
          };
        };
        expect(
          add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
        ).to.eql(
          addCurried(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
        );
        <span class="hljs-comment">/* #@range_end(simple_curried_function) */</span>
        next();
      });
      it(<span class="hljs-string">'カリー化による関数の部品化'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(multiplyOf_curried) */</span>
        <span class="hljs-keyword">var</span> multiplyOf = (n) =&gt; {
          <span class="hljs-keyword">return</span> (m) =&gt; {
            <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(multiplyOf_curried) */</span>
        <span class="hljs-comment">/* #@range_begin(multiplyOf_curried_test) */</span>
        <span class="hljs-keyword">var</span> twoFold = multiplyOf(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">var</span> threeFold = multiplyOf(<span class="hljs-number">3</span>);
        expect(
          twoFold(<span class="hljs-number">2</span>)
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        expect(
          threeFold(<span class="hljs-number">3</span>)
        ).to.eql(
          <span class="hljs-literal">true</span>
        );
        <span class="hljs-comment">/* #@range_end(multiplyOf_curried_test) */</span>
        next();
      });

      describe(<span class="hljs-string">'通常の関数とカリー化関数の相互変換'</span>, () =&gt; {
        it(<span class="hljs-string">'通常の関数をカリー化する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(curry_function_definition) */</span>
          <span class="hljs-keyword">var</span> curry = (fun) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">x,optionalY</span>)</span>{
              <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>){
                <span class="hljs-keyword">return</span> fun.call(<span class="hljs-keyword">this</span>, x,optionalY);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partiallyApplied</span>(<span class="hljs-params">y</span>) </span>{
                  <span class="hljs-keyword">return</span> fun.call(<span class="hljs-keyword">this</span>, x,y);
                };
              }
            };
          };
          <span class="hljs-keyword">var</span> add = (x,y) =&gt; {
            <span class="hljs-keyword">return</span> x + y;
          };
          <span class="hljs-keyword">var</span> curriedAdd = curry(add);
          expect(
            curriedAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(curry_function_definition) */</span>
          next();
        });
        it(<span class="hljs-string">'カリー化を通常の関数に変換する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(uncurry_function_definition) */</span>
          <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> result = fun;
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
                result = result(<span class="hljs-built_in">arguments</span>[i]);
              <span class="hljs-keyword">return</span> result;
            };
          };
          <span class="hljs-keyword">var</span> addCurried = (x) =&gt; {
            <span class="hljs-keyword">return</span> (y) =&gt; {
              <span class="hljs-keyword">return</span> x + y;
            };
          };
          <span class="hljs-keyword">var</span> add = uncurry(addCurried);
          expect(
            add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(uncurry_function_definition) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'関数合成のカリー化'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(compose_definition_curried) */</span>
        <span class="hljs-keyword">var</span> compose = (f) =&gt; {
          <span class="hljs-keyword">return</span> (g) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt;{
              <span class="hljs-keyword">return</span> f(g(arg));
            };
          };
        };
        <span class="hljs-comment">/* #@range_end(compose_definition_curried) */</span>

        <span class="hljs-comment">/* #@range_begin(flip) */</span>
        <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
          <span class="hljs-keyword">return</span>  (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> fun(g)(f);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>return fun.call(this, g)(f);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            };
          };
        };
        <span class="hljs-keyword">var</span> callee = (n) =&gt; {
          <span class="hljs-keyword">return</span> (callback) =&gt; {
            <span class="hljs-keyword">return</span> callback(n);
          };
        };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; {
          <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
        };
        expect(flip(callee)(succ)(<span class="hljs-number">2</span>)).to.eql(<span class="hljs-number">3</span>);
        <span class="hljs-comment">/* #@range_end(flip) */</span>
        it(<span class="hljs-string">'カリー化の合成で乗算と否定の合成は成功する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_negate_multiply_successful) */</span>
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (arg) =&gt;{
                <span class="hljs-keyword">return</span> f(g(arg));
              };
            };
          };
          <span class="hljs-keyword">var</span> negate = (x) =&gt; {
            <span class="hljs-keyword">return</span> - x;
          };
          <span class="hljs-keyword">var</span> multiply = (x) =&gt; {
            <span class="hljs-keyword">return</span> (y) =&gt; {
              <span class="hljs-keyword">return</span> x * y;
            };
          };
          expect(
            compose(negate)(multiply(<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)
          ).to.eql(
              -<span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_negate_multiply_successful) */</span>
          next();
        });
        it(<span class="hljs-string">'カリー化による関数の合成'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(compose_and_uncurry) */</span>
          <span class="hljs-keyword">var</span> compose = (f) =&gt; {
            <span class="hljs-keyword">return</span> (g) =&gt; {
              <span class="hljs-keyword">return</span> (_) =&gt; {
                <span class="hljs-keyword">return</span> f(g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
              };
            };
          };
          <span class="hljs-keyword">var</span> uncurry = (fun) =&gt; {
            <span class="hljs-keyword">return</span> () =&gt; {
              <span class="hljs-keyword">var</span> result = fun;
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)
                result = result(<span class="hljs-built_in">arguments</span>[i]);
              <span class="hljs-keyword">return</span> result;
            };
          };
          <span class="hljs-keyword">var</span> negate = (x) =&gt; {
            <span class="hljs-keyword">return</span> -x;
          };
          <span class="hljs-keyword">var</span> multiply = (x) =&gt; {
            <span class="hljs-keyword">return</span> (y) =&gt; {
              <span class="hljs-keyword">return</span> x * y;
            };
          };
          expect(
            compose(negate)(uncurry(multiply))(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
          ).to.eql(
              -<span class="hljs-number">6</span>
          );
          <span class="hljs-comment">/* #@range_end(compose_and_uncurry) */</span>
          next();
        });
        it(<span class="hljs-string">'マイナスのマイナスはプラス'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(composition_example_negation_twice) */</span>
          <span class="hljs-keyword">var</span> negate = (n) =&gt; {
            <span class="hljs-keyword">return</span> - n;
          };
          expect(
            compose(negate)(negate)(<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          <span class="hljs-comment">/* #@range_end(composition_example_negation_twice) */</span>
          next();
        });
        it(<span class="hljs-string">"1個の引数の関数を合成する"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> decrement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> double = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n;
          };
          expect(
            compose(increment)(decrement)(<span class="hljs-number">5</span>)
          ).to.eql(
            <span class="hljs-number">5</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>expect(<strong>.compose.bind(</strong>)(decrement)(increment)(5)).to.be(5);
expect(<strong>.compose.bind(</strong>)(increment)(increment)(5)).to.be(7);
// (n <em> 2) + 1
expect(<strong>.compose.bind(</strong>)(increment)(double)(5)).to.be(11);
// (n + 1) </em> 2
expect(<strong>.compose.bind(</strong>)(double)(increment)(5)).to.be(12);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
        describe(<span class="hljs-string">"pipe関数による合成"</span>, () =&gt; {
          it(<span class="hljs-string">"composeでlastを定義する"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> compose = (f) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> (arg) =&gt; {
                  <span class="hljs-keyword">return</span> f.call(self,
                                g.call(self,arg));
                };
              };
            };
            <span class="hljs-keyword">var</span> last = (list) =&gt; {
              <span class="hljs-keyword">return</span> compose.call(seq,
                                  seq.head)(seq.reverse)(list);
            };
            <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
            expect(
              last(sequence)
            ).to.eql(
              <span class="hljs-number">4</span>
            );
            next();
          });
          it(<span class="hljs-string">"pipeでlastを定義する"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> compose = (f) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> (arg) =&gt; {
                  <span class="hljs-keyword">return</span> f.call(self,
                                g.call(self,arg));
                };
              };
            };
            <span class="hljs-comment">/* #@range_begin(last_with_pipe) */</span>
            <span class="hljs-keyword">var</span> flip = (fun) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">return</span>  (f) =&gt; {
                <span class="hljs-keyword">return</span> (g) =&gt; {
                  <span class="hljs-keyword">return</span> fun.call(self, g)(f); <span class="hljs-comment">// return fun(g)(f);</span>
                };
              };
            };
            <span class="hljs-keyword">var</span> pipe = (fun) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              expect(fun).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> flip.call(self,
                               compose)(fun);
            };
            <span class="hljs-keyword">var</span> last = (list) =&gt; {
              <span class="hljs-keyword">return</span> pipe.call(seq,
                               seq.reverse)(seq.head)(list);
            };
            <span class="hljs-keyword">var</span> sequence = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()))));
            expect(
              last(sequence)
            ).to.eql(
              <span class="hljs-number">4</span>
            );
            <span class="hljs-comment">/* #@range_end(last_with_pipe) */</span>
            next();
          });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>it(“‘compose two argument functions’”, function(next) {
  var negate = function(x) {
    return -x;
  };
  var multiply = function(x,y){
    return x * y;
  };
  expect((<strong>.compose.bind(</strong>)(negate)(multiply))(2,3)).to.eql(-6);
  next();
});
it(“compose several functions”, function(next) {
  var not = function(x){
    return ! x;
  };
  expect(
    <strong>.compose.bind(</strong>)(not)(math.isEqual(3))(3)
  ).to.eql(
      false
  );
  // expect(
  //   <strong>.compose.bind(</strong>)(__.not)(math.isEqual(3))(3)
  // ).to.eql(
  //  false
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }); <span class="hljs-comment">// 関数合成のカリー化</span>
      it(<span class="hljs-string">'リストの逆順を求める'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> seq = {
          match: (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data(pattern);
          },
          empty: (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty;
          },
          cons: (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          },
          isEmpty: (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
              empty: <span class="hljs-literal">true</span>,
              cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              },
            });
          },
          head: (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, {
              empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              },
            });
          },
          tail: (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, {
              empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          }
        };
        <span class="hljs-comment">/* #@range_begin(list_reverse) */</span>
        <span class="hljs-keyword">var</span> reverse = (list) =&gt; {
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> reverse(tail)(seq.cons(head, accumulator))
              },
            });
          };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>toArray:: LIST -&gt; ARRAY -&gt; ARRAY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> toArray = (list) =&gt; {
          <span class="hljs-keyword">var</span> toArrayAux = (list) =&gt; {
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> seq.match.call(seq,
                                    list, {
                                      empty: accumulator,  <span class="hljs-comment">// 空のリストの場合は終了</span>
                                      cons: (head, tail) =&gt; {
                                        <span class="hljs-keyword">return</span> toArrayAux(tail)(accumulator.concat(head))
                                      },
                                    });
            };
          };
          <span class="hljs-keyword">return</span> toArrayAux(list)([])
        };
        <span class="hljs-comment">/**************** テスト ****************/</span>
        expect(
          toArray(reverse(seq.cons(<span class="hljs-number">1</span>, seq.cons(<span class="hljs-number">2</span>,seq.empty)))(seq.empty))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
        );
        <span class="hljs-comment">/* #@range_end(list_reverse) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'クロージャーで状態をカプセル化する'</span>, () =&gt; {
      describe(<span class="hljs-string">'関数とデータの類似性'</span>, (next) =&gt; {
        it(<span class="hljs-string">'関数とリストの類似性'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
            <span class="hljs-keyword">return</span> data(pattern);
          };
          <span class="hljs-keyword">var</span> empty = (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.empty;
          };
          <span class="hljs-keyword">var</span> cons = (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          };
          <span class="hljs-keyword">var</span> isEmpty = (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, { <span class="hljs-comment">// match関数で分岐する</span>
              empty: <span class="hljs-literal">true</span>,
              cons: (head, tail) =&gt; { <span class="hljs-comment">// headとtailにそれぞれ先頭要素、末尾要素が入る</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              },
            });
          };
          <span class="hljs-keyword">var</span> head = (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, {
              empty: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 空のリストには先頭要素はありません</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              },
            });
          };
          <span class="hljs-keyword">var</span> tail = (list) =&gt; {
            <span class="hljs-keyword">return</span> match(list, {
              empty: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 空のリストには末尾要素はありません</span>
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          };
          <span class="hljs-comment">/*
            ~~~haskell
            list2fct :: Eq a =&gt; [(a,b)] -&gt; a -&gt; b
            list2fct [] _ = error "function not total"
            list2fct ((u,v):uvs) x | x == u = v
            | otherwise = list2fct uvs x
            fct2list :: (a -&gt; b) -&gt; [a] -&gt; [(a,b)]
            fct2list f xs = [ (x, f x) | x &lt;- xs ]
            ~~~
          */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>var list2function = (list) =&gt; {
   return (any) =&gt; {
     if(head(list)) {
       if(head(list) === any){
         return
       } else {
       }
   } else {
   }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          next();
        });
        describe(<span class="hljs-string">'クロージャーによる「環境」の実装'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(environment_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h2 id="-">空の環境</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> emptyEnv = (variable) =&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
          };
          <span class="hljs-comment">/* 変数名に対応する値を環境から取りだす */</span>
          <span class="hljs-keyword">var</span> lookupEnv = (identifier, env) =&gt; {
            <span class="hljs-keyword">return</span> env(identifier);
          };
          <span class="hljs-comment">/* 環境を拡張する */</span>
          <span class="hljs-keyword">var</span> extendEnv = (identifier, value, env) =&gt; {
            <span class="hljs-keyword">return</span> (queryIdentifier) =&gt; {
              <span class="hljs-keyword">if</span>(identifier === queryIdentifier) {
                <span class="hljs-keyword">return</span> value;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> lookupEnv(queryIdentifier,env);
              }
            };
          };
          <span class="hljs-comment">/* #@range_end(environment_in_closure) */</span>
          it(<span class="hljs-string">'extendEnvで環境を作り、 lookupEnv で環境を探る'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(environment_in_closure_test) */</span>
            expect(
              lookupEnv(<span class="hljs-string">"a"</span>, emptyEnv)
            ).to.be(
              <span class="hljs-literal">undefined</span>
            );
            <span class="hljs-keyword">var</span> newEnv = extendEnv(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>, emptyEnv);
            expect(
              lookupEnv(<span class="hljs-string">"a"</span>, newEnv)
            ).to.be(
              <span class="hljs-number">1</span>
            );
            expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>var a = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> firstEnv = extendEnv(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>var b = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> secondEnv = extendEnv(<span class="hljs-string">"b"</span>,<span class="hljs-number">3</span>, firstEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>辞書から b の値を参照する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"b"</span>,secondEnv);
            })()).to.eql(
              <span class="hljs-number">3</span>
            );
            expect(((_) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>空の辞書を作成する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> initEnv = emptyEnv;</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>var x = 1 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> xEnv = extendEnv(<span class="hljs-string">"x"</span>, <span class="hljs-number">1</span>, initEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>var z = 2 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> zEnv = extendEnv(<span class="hljs-string">"z"</span>, <span class="hljs-number">2</span>, xEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>内部のスコープで var x = 3 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> xEnvInner = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">3</span>, zEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>内部のスコープで var y = 4 を実行して、辞書を拡張する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> innerMostEnv = extendEnv(<span class="hljs-string">"y"</span>,<span class="hljs-number">4</span>, xEnvInner);</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>一番内側のスコープを利用して x + y + z を計算する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> lookupEnv(<span class="hljs-string">"x"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"y"</span>,innerMostEnv) + lookupEnv(<span class="hljs-string">"z"</span>,innerMostEnv) ;
            })()).to.eql(
              <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">2</span>
            );
            <span class="hljs-comment">/* #@range_end(environment_in_closure_test) */</span>
            next();
          });
        });
      });
      it(<span class="hljs-string">'クロージャーの変数バインディング'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(free_variable_in_closure) */</span>
        <span class="hljs-keyword">var</span> outerFunction = (outerArgument) =&gt; {
          <span class="hljs-keyword">var</span> innerFunction = (innerArgument) =&gt; {
            <span class="hljs-keyword">return</span> outerArgument + innerArgument;
          };
          <span class="hljs-keyword">return</span> innerFunction;
        };
        <span class="hljs-comment">/* #@range_end(free_variable_in_closure) */</span>
        next();
      });
      describe(<span class="hljs-string">'クロージャーと参照透過性'</span>, () =&gt; {
        it(<span class="hljs-string">'multiplyOf関数は参照透過である'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> multiplyOf = (n) =&gt; {
            <span class="hljs-keyword">return</span> (m) =&gt; {
              <span class="hljs-keyword">if</span>(m % n === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            };
          };
          <span class="hljs-comment">/* #@range_begin(multiplyOf_is_transparent) */</span>
          expect(
            multiplyOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
          ).to.eql(
            multiplyOf(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>)
          );
          expect(
            multiplyOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
          ).to.eql(
            multiplyOf(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)
          );
          <span class="hljs-comment">/* #@range_end(multiplyOf_is_transparent) */</span>
          next();
        });
        it(<span class="hljs-string">'参照透過でないクロジャーの例'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(counter_is_not_transparent) */</span>
          <span class="hljs-keyword">var</span> counter = (init) =&gt; {
            <span class="hljs-keyword">var</span> _init = init;
            <span class="hljs-keyword">return</span> (_) =&gt; {
              _init = _init + <span class="hljs-number">1</span>;
              <span class="hljs-keyword">return</span> _init;
            };
          };
          <span class="hljs-keyword">var</span> counterFromZero = counter(<span class="hljs-number">0</span>);
          expect(
            counterFromZero()
          ).not.to.eql( <span class="hljs-comment">// notで一致しないことをテストしている</span>
            counterFromZero()
          );
          <span class="hljs-comment">/* #@range_end(counter_is_not_transparent) */</span>
          next();
        });
        it(<span class="hljs-string">'参照透過でないクロジャーの利用法'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>チャーチ数 church numeral</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> zero = (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> x;
            };
          };
          <span class="hljs-keyword">var</span> one = (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(x);
            };
          };
          <span class="hljs-keyword">var</span> two = (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(f(x));
            };
          };
          <span class="hljs-keyword">var</span> three = (f) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> f(f(f(x)));
            };
          };
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> (x) =&gt; {
                <span class="hljs-keyword">return</span> f(n(f)(x));
              };
            };
          };
          <span class="hljs-keyword">var</span> add = (m) =&gt; {
            <span class="hljs-keyword">return</span> (n) =&gt; {
              <span class="hljs-keyword">return</span> (f) =&gt; {
                <span class="hljs-keyword">return</span> (x) =&gt;{
                  <span class="hljs-keyword">return</span> m(f)(n(f)(x));
                };
              };
            };
          };
          <span class="hljs-keyword">var</span> counter = (init) =&gt; {
            <span class="hljs-keyword">var</span> _init = init;
            <span class="hljs-keyword">return</span> (_) =&gt; {
              _init = _init + <span class="hljs-number">1</span>;
              <span class="hljs-keyword">return</span> _init;
            };
          };
          <span class="hljs-comment">/* #@range_begin(closure_as_counter) */</span>
          expect(
            one(counter(<span class="hljs-number">0</span>))()
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            two(counter(<span class="hljs-number">0</span>))()
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          expect(
            add(one)(two)(counter(<span class="hljs-number">0</span>))()
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(closure_as_counter) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'不変なデータ型を作る'</span>, () =&gt; {
        it(<span class="hljs-string">'不変なオブジェクト型を作る'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>var objects = {
  empty: {
  },
  set: (key,value,obj) =&gt; {
    expect(obj).to.an(‘object’);
    obj[key] = value;
    return obj;
  },
  get: (key,obj) =&gt; {
    expect(obj).to.an(‘object’);
    return obj[key];
  },
  isEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for(var key in obj){
      if(hasOwnProperty.call(obj, key))
        return false;
    }
  },
  isNotEmpty: (obj) =&gt; {
    expect(obj).to.an(‘object’);
    return ! this.objects.isEmpty(obj);
  },
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(immutable_object_type) */</span>
          <span class="hljs-keyword">var</span> objects = {
            empty: (key) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            get: (key, obj) =&gt; {
              <span class="hljs-keyword">return</span> obj(key);
            },
            set: (key, value, obj) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">return</span> (key2) =&gt; {
                <span class="hljs-keyword">if</span>(key === key2) {
                  <span class="hljs-keyword">return</span> value;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> self.get(key2,obj)
                }
              }
            }
          };
          <span class="hljs-comment">/* #@range_end(immutable_object_type) */</span>
          <span class="hljs-comment">/* #@range_begin(immutable_object_type_test) */</span>
          expect(
            objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty)))
          ).to.eql(
            <span class="hljs-string">"Star Wars"</span>
          )
          expect(
            objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))
          ).to.eql(
            <span class="hljs-literal">undefined</span>
          )
          expect(
            objects.get(<span class="hljs-string">"HAL9000"</span>, objects.set.call(objects,<span class="hljs-string">"C3PO"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set.call(objects,<span class="hljs-string">"R2D2"</span>, <span class="hljs-string">"Star Wars"</span>, objects.set.call(objects,<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))))
          ).to.eql(
            <span class="hljs-string">"2001: a space odessay"</span>
          )
          <span class="hljs-comment">/* #@range_end(immutable_object_type_test) */</span>
          next();
        });
        it(<span class="hljs-string">'不変なオブジェクト型を作る(改良版)'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved) */</span>
          <span class="hljs-keyword">var</span> objects = {
            empty: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            get: (key, obj) =&gt; {
              <span class="hljs-keyword">return</span> obj(key);
            },
            set: (key, value, obj) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">return</span> (key2) =&gt; {
                <span class="hljs-keyword">if</span>(key === key2) {
                  <span class="hljs-keyword">return</span> value;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> self.get(key2,obj)
                }
              }
            },
            fromObject: (obj) =&gt; {
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
              <span class="hljs-keyword">var</span> keys = (o) =&gt; {
                <span class="hljs-keyword">var</span> result = [];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> o) {
                  <span class="hljs-keyword">if</span>(o.hasOwnProperty(prop))
                    result.push(prop);
                }
                <span class="hljs-keyword">return</span> result;
              };
              <span class="hljs-keyword">return</span> keys(obj).reduce((accumulator, key) =&gt; {
                <span class="hljs-keyword">return</span> self.set.call(self,key, obj[key], accumulator);
              }, self.empty)
            }
          };
          <span class="hljs-comment">/* #@range_end(immutable_object_type_improved) */</span>
          <span class="hljs-comment">/* #@range_begin(immutable_object_type_improved_test) */</span>
          expect(
            objects.get(<span class="hljs-string">"R2D2"</span>, objects.set(<span class="hljs-string">"HAL9000"</span>,<span class="hljs-string">"2001: a space odessay"</span>,objects.empty))
          ).to.eql(
            <span class="hljs-literal">undefined</span>
          );
          expect(
            objects.get(<span class="hljs-string">"HAL9000"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
          ).to.eql(
            <span class="hljs-string">"2001: a space odessay"</span>
          );
          expect(
            objects.get(<span class="hljs-string">"R2D2"</span>, objects.fromObject.call(objects,{<span class="hljs-string">"HAL9000"</span> : <span class="hljs-string">"2001: a space odessay"</span>, <span class="hljs-string">"R2D2"</span>: <span class="hljs-string">"Star Wars"</span>}))
          ).to.eql(
            <span class="hljs-string">"Star Wars"</span>
          );
          <span class="hljs-comment">/* #@range_end(immutable_object_type_improved_test) */</span>
          next();
        });
        it(<span class="hljs-string">'不変なリスト型'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(immutable_list) */</span>
          <span class="hljs-keyword">var</span> seq = {
            empty: (index) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            cons: (head,tail) =&gt; {
              <span class="hljs-keyword">return</span> (f) =&gt; {
                <span class="hljs-keyword">return</span> f(head,tail);
              };
            },
            head: (array) =&gt; {
              <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              });
            },
            tail: (array) =&gt; {
              <span class="hljs-keyword">return</span> array((head,tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              });
            },
            at: (index,array) =&gt; {
              <span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head(array);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.at(index -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.tail(array));
              }
            }
          };
          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.empty)));
          expect(
            seq.head(list)
          ).to.eql(
            <span class="hljs-number">1</span>
          )
          expect(
            seq.head(seq.tail(list))
          ).to.eql(
            <span class="hljs-number">2</span>
          )
          expect(
            seq.at(<span class="hljs-number">0</span>,list)
          ).to.eql(
            <span class="hljs-number">1</span>
          )
          expect(
            seq.at(<span class="hljs-number">1</span>,list)
          ).to.eql(
            <span class="hljs-number">2</span>
          )
          expect(
            seq.at(<span class="hljs-number">2</span>,list)
          ).to.eql(
            <span class="hljs-number">3</span>
          )
          <span class="hljs-comment">/* #@range_end(immutable_list) */</span>
          next();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>it(‘不変な配列型’, (next) =&gt; {
  var arrays = {
    empty: [],
    cons: (any,array) =&gt; {
      expect(array).to.an(‘array’);
      return [any].concat(array);
    },
    head: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return ary[0];
    },
    tail: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      expect(self.isNonEmpty(ary)).to.be.ok();
      return ary.slice(1,ary.length);
    },
    get: (index,ary) =&gt; {
      expect(index).to.be.a(‘number’);
      expect(ary).to.an(‘array’);
      return ary[index];
    },
    isEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.equal.call(self,ary.length)(0);
    },
    isNotEmpty: (ary) =&gt; {
      expect(ary).to.an(‘array’);
      return self.not.call(self,self.arrays.isEmpty(ary));
    }
  };
  expect(
    arrays.cons(1,arrays.empty)
  ).to.eql(
    [1]
  )
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        describe(<span class="hljs-string">'代数的ストリーム型'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(algebraic_stream) */</span>
          <span class="hljs-keyword">var</span> empty = (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              expect(pattern).to.an(<span class="hljs-string">'object'</span>);
              <span class="hljs-keyword">return</span> pattern.empty(_);
            };
          };
          <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
            expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              expect(pattern).to.an(<span class="hljs-string">'object'</span>);
              <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
            };
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (value, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> value;
              }
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> tailThunk();
              }
            });
          };
          <span class="hljs-keyword">var</span> isEmpty = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head1,tailThunk1) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });
          };
          <span class="hljs-keyword">var</span> concat = (xs) =&gt; {
            <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
              <span class="hljs-keyword">return</span> match(xs,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> ysThunk();
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> cons(head,(_) =&gt; {
                    <span class="hljs-keyword">return</span> concat(tailThunk())(ysThunk);
                  });
                }
              });
            };
          };
          <span class="hljs-comment">/* #@range_end(algebraic_stream) */</span>
          <span class="hljs-comment">/* #@range_begin(algebraic_stream_helpers) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> toArray = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> [];
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> match(tailThunk(),{
                  empty: (_) =&gt; {
                    <span class="hljs-keyword">return</span> [head];
                  },
                  cons: (head_,tailThunk_) =&gt; {
                    <span class="hljs-keyword">return</span> [head].concat(toArray(tailThunk()));
                  }
                });
              }
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <h3 id="stream-fromlist">stream#fromList</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> fromArray = (array) =&gt; {
            <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
              <span class="hljs-keyword">return</span> concat(accumulator)(cons(item, (_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              }));
            });
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h3 id="stream-take">stream#take</h3>
<p>take:: STREAM -&gt; NUMBER -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> take = (lazyList) =&gt; {
			<span class="hljs-keyword">return</span> (number) =&gt; {
			  expect(number).to.a(<span class="hljs-string">'number'</span>);
			  expect(number).to.be.greaterThan(-<span class="hljs-number">1</span>);
			  <span class="hljs-keyword">return</span> match(lazyList,{
				empty: (_) =&gt; {
				  <span class="hljs-keyword">return</span> empty();
				},
				cons: (head,tailThunk) =&gt; {
				  <span class="hljs-keyword">if</span>(number === <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">return</span> empty();
					} <span class="hljs-keyword">else</span> {
					  <span class="hljs-keyword">return</span> cons(head,(_) =&gt; {
						<span class="hljs-keyword">return</span> take(tailThunk())(number -<span class="hljs-number">1</span>);
					  });
					}
				}
			  });
			};
          };
          <span class="hljs-comment">/* #@range_end(algebraic_stream_helpers) */</span>
          it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              });
            });
            expect(
              head(stream)
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            next();
          });
          it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>stream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> stream = cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              });
            });
            expect(
              tail(stream)
            ).to.a(<span class="hljs-string">"function"</span>);
            expect(
              head(tail(stream))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            next();
          });
          it(<span class="hljs-string">"無限ストリーム"</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(infinite_stream) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>ones = [1,1,1,1,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> ones = cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> ones;
            });
            expect(
              head(ones)
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(
              head(tail(ones))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-comment">/* #@range_end(infinite_stream) */</span>
            <span class="hljs-comment">/* #@range_begin(infinite_integer) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>ones = [1,2,3,4,…]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> intgersFrom = (n) =&gt; {
			  <span class="hljs-keyword">return</span> cons(n, (_) =&gt; {
				<span class="hljs-keyword">return</span> intgersFrom(n + <span class="hljs-number">1</span>);
			  });
			};
            expect(
              head(intgersFrom(<span class="hljs-number">1</span>))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(
              head(tail(intgersFrom(<span class="hljs-number">1</span>)))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              toArray(take(intgersFrom(<span class="hljs-number">1</span>))(<span class="hljs-number">10</span>))
            ).to.eql(
              [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> ] 
            );
            <span class="hljs-comment">/* #@range_end(infinite_integer) */</span>
            next();
          });
          it(<span class="hljs-string">"代数的ストリーム型は不変ではない"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
              <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              });
            });
            expect(
              head(stream).key
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-keyword">var</span> object = head(stream);
            object.key = <span class="hljs-number">2</span>;
            expect(
              head(stream).key
            ).to.eql(
              <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
            );
            next();
          });
        });
        describe(<span class="hljs-string">'不変なストリーム型'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(immutable_stream) */</span>
          <span class="hljs-keyword">var</span> empty = (index) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          };
          <span class="hljs-keyword">var</span> cons = (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> (f) =&gt; {
              <span class="hljs-keyword">return</span> f(head,tailThunk);
            };
          };
          <span class="hljs-keyword">var</span> head = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> head;
            });
          };
          <span class="hljs-keyword">var</span> tail = (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> lazyList((head,tailThunk) =&gt; {
              <span class="hljs-keyword">return</span> tailThunk();
            });
          };
          <span class="hljs-comment">/* #@range_end(immutable_stream) */</span>
          it(<span class="hljs-string">"関数的ストリーム型は不変である"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> stream = cons({key: <span class="hljs-number">1</span>}, (_) =&gt; {
              <span class="hljs-keyword">return</span> cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> empty();
              });
            });
            expect(
              head(stream).key
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-keyword">var</span> object = head(stream);
            object.key = <span class="hljs-number">2</span>;
            expect(
              head(stream).key
            ).to.eql(
              <span class="hljs-number">2</span> <span class="hljs-comment">// 1が2に変更されている</span>
            );
            next();
          });
        });
      });
      describe(<span class="hljs-string">'クロージャーでジェネレーターを作る'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(generator_in_closure) */</span>
        <span class="hljs-keyword">var</span> generator = (seed) =&gt; {
          <span class="hljs-keyword">return</span> (current) =&gt; {
            <span class="hljs-keyword">return</span> (stepFunction) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(current(seed),
                                 (_) =&gt; { 
                                   <span class="hljs-keyword">return</span> generator(stepFunction(seed))(current)(stepFunction) 
                                 });
            };
          };
        };
        <span class="hljs-keyword">var</span> id = (any) =&gt; { <span class="hljs-keyword">return</span> any; };
        <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>; };
        <span class="hljs-keyword">var</span> integers = generator(<span class="hljs-number">0</span>)(id)(succ);
        expect(
          stream.head(integers)
        ).to.eql(
          <span class="hljs-number">0</span>
        );
        expect(
          stream.head(stream.tail(integers))
        ).to.eql(
          <span class="hljs-number">1</span>
        );
        expect(
          stream.head(stream.tail(stream.tail(integers)))
        ).to.eql(
          <span class="hljs-number">2</span>
        );
        <span class="hljs-comment">/* #@range_end(generator_in_closure) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>describe(‘streamとgenerator’, () =&gt; {
  var integers = generator(0)(id)(succ);
  var double = (n) =&gt; {
    return n * 2;
  };
  var doubles = stream.map.call(stream,
                                integers, double);
  expect(
    stream.head(integers)
  ).to.eql(
    0
  );</p>

            </div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      });
    }); <span class="hljs-comment">// クロージャーで状態をカプセル化する</span>
    describe(<span class="hljs-string">'関数を渡す'</span>, () =&gt; {
      describe(<span class="hljs-string">'コールバックを渡す'</span>, () =&gt; {
        it(<span class="hljs-string">'直接コールする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(direct_call) */</span>
          <span class="hljs-keyword">var</span> succ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> directCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> succ(n);
          };
          expect(
            directCall(<span class="hljs-number">2</span>)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
        <span class="hljs-comment">/* #@range_end(direct_call) */</span>
          next();
        });
        it(<span class="hljs-string">'コールバックを呼び出す'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(call_callback) */</span>
          <span class="hljs-keyword">var</span> succ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          <span class="hljs-keyword">var</span> call_callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, callback</span>)</span>{
            <span class="hljs-keyword">return</span> callback(n);
          };
          expect(
            call_callback(<span class="hljs-number">2</span>,succ)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(call_callback) */</span>
          next();
        });
        it(<span class="hljs-string">'イベント駆動'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> processEvent = (event) =&gt; {
            <span class="hljs-keyword">return</span> (callback) =&gt; {
              <span class="hljs-keyword">return</span> callback(event);
            };
          };
          <span class="hljs-keyword">var</span> anEvent = {<span class="hljs-string">"temperture"</span>: <span class="hljs-number">26.0</span>};
          expect(
            processEvent(anEvent)((theEvent) =&gt; {
              <span class="hljs-keyword">return</span> theEvent.temperture;
            })
          ).to.eql(
            <span class="hljs-number">26</span>
          );
          <span class="hljs-keyword">var</span> extract = (key) =&gt; {
            <span class="hljs-keyword">return</span> (object) =&gt; {
              <span class="hljs-keyword">return</span> object[key]
            };
          };
          <span class="hljs-keyword">var</span> extractTemperture = (event) =&gt; {
            <span class="hljs-keyword">return</span> processEvent(event)(extract(<span class="hljs-string">"temperture"</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>return processEvent(event)((theEvent) =&gt; {
  return theEvent.temperture;
})</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          };
          expect(
            extractTemperture(anEvent)
          ).to.eql(
            <span class="hljs-number">26</span>
          );
          next();
        });
      });
      describe(<span class="hljs-string">'畳み込み関数で反復処理を渡す'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> seq  = {
          match: (data, pattern) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> data(pattern);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>compose: (f,g) =&gt; {
   return (arg) =&gt; {
    return f(g(arg));
   };
},
flip: (fun) =&gt; {
   return  (f) =&gt; {
    return (g) =&gt; {
       return fun(g)(f);
    };
   };
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          },
          head: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              },
            });
          },
          tail: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          },
          isEmpty: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              },
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>// concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
concat: (xs) =&gt; {
   var self = this;
   return (ys) =&gt; {
     if(self.isEmpty(xs)){
       return ys;
     } else {
       return self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
     }
   };
},
// concat:: LIST[LIST[T]] -&gt; LIST[T]
join: (list_of_list) =&gt; {
   var self = this;
   if(self.isEmpty(list_of_list)){
     return self.empty();
   } else {
     return self.concat(seq.head(list_of_list))(self.join(seq.tail(list_of_list)));
   }
},</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(foldr_final_version) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          foldr: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (glue) =&gt; {
                expect(glue).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">if</span>(self.isEmpty(list)){
                  <span class="hljs-keyword">return</span> accumulator;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">var</span> item = self.head(list);
                  <span class="hljs-keyword">var</span> tail = self.tail(list);
                  <span class="hljs-keyword">return</span> glue(item)(self.foldr(tail)(accumulator)(glue));
                }
              };
            };
          },
          <span class="hljs-comment">/* #@range_end(foldr_final_version) */</span>
          <span class="hljs-comment">/* #@range_begin(foldr_toArray) */</span>
          toArray: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.foldr(list)([])(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> [item].concat(accumulator);
              };
            });
          }
          <span class="hljs-comment">/* #@range_end(foldr_toArray) */</span>
        };
        describe(<span class="hljs-string">'畳み込み関数foldr'</span>, () =&gt; {
          it(<span class="hljs-string">"foldrでsumを作る"</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(foldr_sum) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
            expect(
              seq.foldr(list)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
                <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                  <span class="hljs-keyword">return</span> accumulator + item;
                };
              })
            ).to.eql(
              <span class="hljs-number">10</span>
            )
            <span class="hljs-comment">/* #@range_end(foldr_sum) */</span>
            next();
          });
        });
      }); <span class="hljs-comment">// 畳み込み関数で反復処理を渡す</span>
      describe(<span class="hljs-string">'継続を渡す'</span>, () =&gt; {
        it(<span class="hljs-string">"継続による反復処理"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(loop_cps) */</span>
          <span class="hljs-keyword">var</span> loop = (predicate, accumulator) =&gt; {
            <span class="hljs-keyword">return</span> (continues) =&gt; {
              <span class="hljs-keyword">if</span>(predicate(accumulator)){
                <span class="hljs-keyword">return</span> loop(predicate, continues(accumulator))(continues);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> accumulator;
              }
            };
          };
          <span class="hljs-keyword">var</span> lessThan = (n) =&gt; {
            <span class="hljs-keyword">return</span> (x) =&gt; {
              <span class="hljs-keyword">return</span> x &lt; n;
            };
          };
          <span class="hljs-keyword">var</span> succ = (n) =&gt; {
            <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
          };
          expect(
            loop(lessThan(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>)(succ)
          ).to.eql(
            <span class="hljs-number">3</span>
          );
          <span class="hljs-comment">/* #@range_end(loop_cps) */</span>
          next();
        });
      });
    }); <span class="hljs-comment">// 関数を渡す</span>
    describe(<span class="hljs-string">'コンビネーター'</span>, () =&gt; {
      it(<span class="hljs-string">'パイプライン'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> pipe = (f, g) =&gt; {
          <span class="hljs-keyword">return</span> (input) =&gt; {
            <span class="hljs-keyword">return</span> compose(f,g)(input)
          };
        };
        <span class="hljs-keyword">var</span> pipelines = (combinators) =&gt; {
          <span class="hljs-keyword">return</span> (input) =&gt; {
            <span class="hljs-keyword">return</span> combinators.reduce((accumulator, combinator) =&gt; {
              <span class="hljs-keyword">return</span> compose(combinator,accumulator)
            });
          };
        };
        next();
      });
      it(<span class="hljs-string">'コンビネーター・ライブラリー'</span>, (next) =&gt; {
        <span class="hljs-comment">/* #@range_begin(combinator_library) */</span>
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-keyword">var</span> get = (key) =&gt; {
          <span class="hljs-keyword">return</span> (obj) =&gt; {
            <span class="hljs-keyword">return</span> obj[key];
          };
        };
        <span class="hljs-keyword">var</span> isEqual = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n2 === n1;
          };
        };
        <span class="hljs-keyword">var</span> isLessThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &gt; n2;
          };
        };
        <span class="hljs-keyword">var</span> isMoreThan = (n1) =&gt; {
          <span class="hljs-keyword">return</span> (n2) =&gt; {
            <span class="hljs-keyword">return</span> n1 &lt; n2;
          };
        };
        <span class="hljs-keyword">var</span> not = (predicate) =&gt; {
          <span class="hljs-keyword">return</span> (data) =&gt; {
            <span class="hljs-keyword">return</span> ! predicate(data);
          }
        };
        <span class="hljs-keyword">var</span> within = (lower) =&gt; {
          <span class="hljs-keyword">return</span> (upper) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">return</span> (extractor) =&gt; {
                <span class="hljs-keyword">return</span> and(extractor, isMoreThan(lower))(extractor, isLessThan(upper))(data);
              };
            };
          };
        };
        <span class="hljs-keyword">var</span> and = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(! firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-keyword">var</span> or = (firstExtractor, firstPredicate) =&gt; {
          <span class="hljs-keyword">return</span> (nextExtractor, nextPredicate) =&gt; {
            <span class="hljs-keyword">return</span> (data) =&gt; {
              <span class="hljs-keyword">var</span> firstResult = firstPredicate(firstExtractor(data))
              <span class="hljs-keyword">if</span>(firstResult) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> nextPredicate(nextExtractor(data));
              }
            }
          };
        };
        <span class="hljs-comment">/* #@range_end(combinator_library) */</span>
        <span class="hljs-comment">/* #@range_begin(combinator_library_test) */</span>
        <span class="hljs-keyword">var</span> data = {
          temp: <span class="hljs-number">24</span>,
          time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"2013/2/15 17:57:27"</span>)
        };
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> and(getTemp, isMoreThan(<span class="hljs-number">20</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        )
        expect(((_) =&gt; {
          <span class="hljs-keyword">var</span> getTemp = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data);
          };
          <span class="hljs-keyword">var</span> getHour = (data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'time'</span>)(data).getHours();
          };
          <span class="hljs-keyword">return</span> or(getTemp, isMoreThan(<span class="hljs-number">30</span>))(getHour, isEqual(<span class="hljs-number">17</span>))(data)
        })()).to.eql(
          <span class="hljs-literal">true</span>
        )
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(get(<span class="hljs-string">'temp'</span>)(data))(id)
        ).to.eql(
          <span class="hljs-literal">true</span>
        )
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)(get(<span class="hljs-string">'temp'</span>))
        ).to.eql(
          <span class="hljs-literal">true</span>
        )
        expect(
          within(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)(data)((data) =&gt; {
            <span class="hljs-keyword">return</span> get(<span class="hljs-string">'temp'</span>)(data)
          })
        ).to.eql(
          <span class="hljs-literal">true</span>
        )
        <span class="hljs-comment">/* #@range_end(combinator_library_test) */</span>
        next();
      });
    });
    describe(<span class="hljs-string">'モナドを作る'</span>, () =&gt; {
      describe(<span class="hljs-string">'恒等モナド'</span>, () =&gt; {
        <span class="hljs-comment">/* #@range_begin(identity_monad) */</span>
        <span class="hljs-keyword">var</span> identity = {</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <h2 id="identity-unit">identity#unit</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit: (value) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> value;
          },
          flatMap: (instance) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> transform(instance);
            };
          }
        };
        <span class="hljs-comment">/* #@range_end(identity_monad) */</span>
        it(<span class="hljs-string">"identity#flatMap"</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(identity_monad_test) */</span>
          <span class="hljs-keyword">var</span> instance = identity.unit(<span class="hljs-number">1</span>);
          expect(
            identity.flatMap(instance)((n) =&gt; {
              <span class="hljs-keyword">return</span> identity.unit(n * <span class="hljs-number">2</span>);
            })
          ).to.eql(
            identity.unit(<span class="hljs-number">2</span>)
          );
          expect(
            identity.flatMap(instance)((n) =&gt; {
              <span class="hljs-keyword">return</span> identity.flatMap(identity.unit(n * <span class="hljs-number">2</span>))((m) =&gt; {
                <span class="hljs-keyword">return</span> identity.unit(m * <span class="hljs-number">3</span>);
              });
            })
          ).to.eql(
            identity.unit(<span class="hljs-number">6</span>)
          );
          expect(
            identity.flatMap(instance)((n) =&gt; {
              <span class="hljs-keyword">return</span> identity.flatMap(identity.unit(n))((m) =&gt; {
                <span class="hljs-keyword">return</span> identity.unit(m * n);
              });
            })
          ).to.eql(
            identity.unit(<span class="hljs-number">1</span>)
          );
          <span class="hljs-comment">/* #@range_end(identity_monad_test) */</span>
          next();
        });
      });
      describe(<span class="hljs-string">'Maybeモナド'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> id = (any) =&gt; {
          <span class="hljs-keyword">return</span> any;
        };
        <span class="hljs-keyword">var</span> match = (exp, pattern) =&gt; {
          <span class="hljs-keyword">return</span> exp.call(pattern, pattern);
        };
        it(<span class="hljs-string">'代数的データ型を作る'</span>)
        describe(<span class="hljs-string">'Maybeモナドを作る'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(maybe_monad) */</span>
          <span class="hljs-keyword">var</span> just = (value) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.just(value);
            };
          };
          <span class="hljs-keyword">var</span> nothing = ((_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.nothing(_);
            };
          })(<span class="hljs-literal">null</span>);
          <span class="hljs-keyword">var</span> unit = (value) =&gt; {
            <span class="hljs-keyword">if</span>(value){
              <span class="hljs-keyword">return</span> just(value);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> nothing(<span class="hljs-literal">null</span>);
            }
          };
          <span class="hljs-keyword">var</span> isEqual = (maybeA) =&gt; {
            <span class="hljs-keyword">return</span> (maybeB) =&gt; {
              <span class="hljs-keyword">return</span> match(maybeA,{
                just: (valueA) =&gt; {
                  <span class="hljs-keyword">return</span> match(maybeB,{
                    just: (valueB) =&gt; {
                      <span class="hljs-keyword">return</span> (valueA === valueB);
                    },
                    nothing: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                  });
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> match(maybeB,{
                    just: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    },
                    nothing: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    }
                  });
                }
              });
            };
          };
          <span class="hljs-keyword">var</span> map = (maybe) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> match(maybe,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> unit(transform(value));
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> nothing;
                }
              });
            };
          };
          <span class="hljs-keyword">var</span> flatMap = (maybe) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> match(maybe,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> transform(value);
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> nothing;
                }
              });
            };
          };
          <span class="hljs-comment">/* #@range_end(maybe_monad) */</span>
          it(<span class="hljs-string">"map id == id"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{
            <span class="hljs-comment">/* #@range_begin(maybe_monad_test) */</span>
            <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
            expect(
              isEqual(map(justOne)(id))(id(justOne))
            ).to.be(
              <span class="hljs-literal">true</span>
            );
            expect(
              isEqual(map(nothing)(id))(id(nothing))
            ).to.be(
              <span class="hljs-literal">true</span>
            );
            <span class="hljs-comment">/* #@range_end(maybe_monad_test) */</span>
            next();
          });
          it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(maybe_monad_add_test) */</span>
            <span class="hljs-keyword">var</span> add = (maybeA) =&gt; {
              <span class="hljs-keyword">return</span> (maybeB) =&gt; {
                <span class="hljs-keyword">return</span> flatMap(maybeA)((a) =&gt; {
                  <span class="hljs-keyword">return</span> flatMap(maybeB)((b) =&gt; {
                    <span class="hljs-keyword">return</span> unit(a + b);
                  });
                });
              };
            };
            <span class="hljs-keyword">var</span> justOne = just(<span class="hljs-number">1</span>);
            <span class="hljs-keyword">var</span> justTwo = just(<span class="hljs-number">2</span>);
            <span class="hljs-keyword">var</span> justThree = just(<span class="hljs-number">3</span>);
            expect(
              isEqual(add(justOne)(justTwo))(justThree)
            ).to.eql(
              <span class="hljs-literal">true</span>
            );
            expect(
              isEqual(add(justOne)(nothing))(nothing)
            ).to.eql(
              <span class="hljs-literal">true</span>
            );
            <span class="hljs-comment">/* #@range_end(maybe_monad_add_test) */</span>
            next();
          });
        });
      });
      describe(<span class="hljs-string">'Listモナド'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> seq  = {
          match: (data, pattern) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> data(pattern);
          },
          compose: (f,g) =&gt; {
            <span class="hljs-keyword">return</span> (arg) =&gt; {
              <span class="hljs-keyword">return</span> f(g(arg));
            };
          },
          flip: (fun) =&gt; {
            <span class="hljs-keyword">return</span>  (f) =&gt; {
              <span class="hljs-keyword">return</span> (g) =&gt; {
                <span class="hljs-keyword">return</span> fun(g)(f);
              };
            };
          },
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (value, list) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.cons(value, list);
            };
          },
          head: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> head;
              },
            });
          },
          tail: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> tail;
              },
            });
          },
          isEmpty: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> seq.match(list, {
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head, tail) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              },
            });
          },
          toArray: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.foldr(list)([])(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> [item].concat(accumulator);</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>return accumulator.concat(item);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              };
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>concat:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          concat: (xs) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (ys) =&gt; {
              <span class="hljs-keyword">if</span>(self.isEmpty(xs)){
                <span class="hljs-keyword">return</span> ys;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.cons(self.head(xs),(self.concat(self.tail(xs))(ys)));
              }
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          join: (list_of_list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">if</span>(self.isEmpty(list_of_list)){
              <span class="hljs-keyword">return</span> self.empty();
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.concat(seq.head(list_of_list))(self.join(seq.tail(list_of_list)));
            }
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          foldr: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (accumulator) =&gt; {
              <span class="hljs-keyword">return</span> (glue) =&gt; {
                expect(glue).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">if</span>(self.isEmpty(list)){
                  <span class="hljs-keyword">return</span> accumulator;
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">var</span> item = self.head(list);
                  <span class="hljs-keyword">var</span> tail = self.tail(list);
                  <span class="hljs-keyword">return</span> glue(item)(self.foldr(tail)(accumulator)(glue));
                }
              };
            };
          },
          <span class="hljs-comment">/* #@range_begin(list_monad_map) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          map: (list) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> seq.match(list,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> self.empty;
                },
                cons: (x,xs) =&gt; {
                  <span class="hljs-keyword">return</span> self.cons(transform(x),self.map(xs)(transform));
                }
              });</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>return self.foldr(list)(self.empty())(function (item){
   return (accumulator) =&gt; {
     return seq.match(list,{
       empty: (_) =&gt; {
         return accumulator;
       },
       cons: (x,xs) =&gt; {
         return transform();
       }
     });
   };
});
var glue = self.compose(self.cons.bind(self),transform.bind(self));
return self.foldr(list)(self.empty())(glue);
var glue = self.compose(self.cons.bind(self),transform.bind(self));
return self.foldr(list)(self.empty())(glue);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            };
          },
          <span class="hljs-comment">/* #@range_end(list_monad_map) */</span>
          <span class="hljs-comment">/* #@range_begin(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h3 id="list-unit">list#unit</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit: (value) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> self.cons(value, seq.empty());
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h3 id="monad-list-flatmap">monad.list#flatMap</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatMap: (instance) =&gt; {
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> self.join(self.map(instance)(transform.bind(self)));
            };
          }
          <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span>
        }; <span class="hljs-comment">// end of seq</span>
        it(<span class="hljs-string">"'list#empty'"</span>, (next) =&gt; {
          seq.match(seq.empty,{
            empty: (_) =&gt; {
              expect(<span class="hljs-literal">true</span>).ok();
            },
            cons: (x,xs) =&gt; {
              expect().fail()
            }
          });
          next();
        })
        it(<span class="hljs-string">"'list#isEmpty'"</span>, (next) =&gt; {
          expect(
            seq.isEmpty(seq.empty())
          ).to.eql(
            <span class="hljs-literal">true</span>
          );
          expect(
            seq.isEmpty(seq.cons(<span class="hljs-number">1</span>,seq.empty()))
          ).to.eql(
            <span class="hljs-literal">false</span>
          );
          next();
        })
        it(<span class="hljs-string">"'list#cons'"</span>, (next) =&gt; {
          seq.match(seq.cons(<span class="hljs-number">1</span>,seq.empty()),{
            empty: (_) =&gt; {
              expect().fail()
            },
            cons: (x,xs) =&gt; {
              expect(x).to.eql(<span class="hljs-number">1</span>)
            }
          });
          next();
        })
        it(<span class="hljs-string">"'list#head'"</span>, (next) =&gt; {
          expect(
            seq.head(seq.cons(<span class="hljs-number">1</span>,seq.empty()))
          ).to.eql(
            <span class="hljs-number">1</span>
          )
          next();
        })
        it(<span class="hljs-string">"'list#tail'"</span>, (next) =&gt; {
          expect(
            seq.head(seq.tail(seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.empty()))))
          ).to.eql(
            <span class="hljs-number">2</span>
          )
          next();
        })
        it(<span class="hljs-string">"'list#concat'"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> list = seq.concat(seq.cons(<span class="hljs-number">1</span>,seq.empty()))(seq.cons(<span class="hljs-number">2</span>,seq.empty()));
          expect(
            seq.head(list)
          ).to.eql(
            <span class="hljs-number">1</span>
          )
          expect(
            seq.head(seq.tail(list))
          ).to.eql(
            <span class="hljs-number">2</span>
          )
          expect(
            seq.isEmpty(seq.tail(seq.tail(list)))
          ).to.eql(
            <span class="hljs-literal">true</span>
          )
          next();
        });
        it(<span class="hljs-string">"'list#join'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>list = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list_of_list = seq.cons(seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.empty())),
                                      seq.cons(seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty())),
                                               seq.empty));</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>joined_list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> joined_list = seq.join(list_of_list)
          expect(
            seq.head(joined_list)
          ).to.eql(
            <span class="hljs-number">1</span>
          )
          expect(
            seq.head(seq.tail(joined_list))
          ).to.eql(
            <span class="hljs-number">2</span>
          )
          expect(
            seq.isEmpty(seq.tail(seq.tail(joined_list)))
          ).to.eql(
            <span class="hljs-literal">false</span>
          )
          next();
        });
        it(<span class="hljs-string">"'list#foldr'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
          expect(
            seq.foldr(list)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
              <span class="hljs-keyword">return</span> (accumulator) =&gt; {
                <span class="hljs-keyword">return</span> accumulator + item;
              };
            })
          ).to.eql(
            <span class="hljs-number">10</span>
          )
          next();
        })
        it(<span class="hljs-string">"'list#toArray'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
          expect(
            seq.toArray(list)
          ).to.eql(
            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
          )
          next();
        })
        it(<span class="hljs-string">"'list#map'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.cons(<span class="hljs-number">1</span>,seq.cons(<span class="hljs-number">2</span>,seq.cons(<span class="hljs-number">3</span>,seq.cons(<span class="hljs-number">4</span>,seq.empty()),seq.empty)))
          expect(
            seq.toArray(seq.map(list)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
              <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
            }))
          ).to.eql(
            [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
          )
          next();
        })
        it(<span class="hljs-string">"'list#unit'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.unit(<span class="hljs-number">1</span>);
          expect(
            seq.toArray(list)
          ).to.eql(
            [<span class="hljs-number">1</span>]
          )
          next();
        })
        it(<span class="hljs-string">"'list#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> list = seq.concat(seq.unit(<span class="hljs-number">1</span>))(seq.concat(seq.unit(<span class="hljs-number">2</span>))(seq.unit(<span class="hljs-number">3</span>)))
          expect(
            seq.toArray(seq.flatMap(list)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
              <span class="hljs-keyword">return</span> seq.concat(seq.unit(item))(seq.unit(- item));
            }))
          ).to.eql(
            [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
          );
          next();
        });
      });
      describe(<span class="hljs-string">'Streamモナド'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> match = (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data(pattern);
        };
        <span class="hljs-keyword">var</span> maybe = {
          just: (value) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.just(value);
            };
          },
          nothing: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              <span class="hljs-keyword">return</span> pattern.nothing(_);
            };
          },
          unit: (value) =&gt; {
            <span class="hljs-keyword">if</span>(value){
              <span class="hljs-keyword">return</span> self.maybe.just(value);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.maybe.nothing(<span class="hljs-literal">undefined</span>);
            }
          },
          get: (maybe) =&gt; {
            <span class="hljs-keyword">return</span> match(maybe,{
              just: (value) =&gt; {
                <span class="hljs-keyword">return</span> value;
              },
              nothing: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
              }
            });
          },
          isEqual: (maybeA) =&gt; {
            <span class="hljs-keyword">return</span> (maybeB) =&gt; {
              <span class="hljs-keyword">return</span> match(maybeA,{
                just: (valueA) =&gt; {
                  <span class="hljs-keyword">return</span> match(maybeB,{
                    just: (valueB) =&gt; {
                      <span class="hljs-keyword">return</span> (valueA === valueB);
                    },
                    nothing: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                  });
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> match(maybeB,{
                    just: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    },
                    nothing: (_) =&gt; {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    }
                  });
                }
              });
            };
          },
          map: (maybe) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> match(maybe,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> unit(transform(value));
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> nothing();
                }
              });
            };
          },
          flatMap: (maybe) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              expect(transform).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> match(maybe,{
                just: (value) =&gt; {
                  <span class="hljs-keyword">return</span> transform(value);
                },
                nothing: (_) =&gt; {
                  <span class="hljs-keyword">return</span> nothing();
                }
              });
            };
          }
        }; <span class="hljs-comment">// end of maybe</span>
        <span class="hljs-comment">/* #@range_begin(stream_monad_definition) */</span>
        <span class="hljs-keyword">var</span> stream = {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              expect(pattern).to.an(<span class="hljs-string">'object'</span>);
              <span class="hljs-keyword">return</span> pattern.empty();
            };
          },
          cons: (head,tailThunk) =&gt; {
            expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
            <span class="hljs-keyword">return</span> (pattern) =&gt; {
              expect(pattern).to.an(<span class="hljs-string">'object'</span>);
              <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>head:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          head: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> maybe.nothing();
              },
              cons: (value, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> maybe.just(value);
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>tail:: STREAM -&gt; MAYBE[STREAM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tail: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> maybe.nothing();
              },
              cons: (head, tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> maybe.just(tailThunk());
              }
            });
          },
          isEmpty: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          toArray: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> [];
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">if</span>(stream.isEmpty(tailThunk())){
                  <span class="hljs-keyword">return</span> [head];
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
                }
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h3 id="stream-unit">stream#unit</h3>
<p>unit:: ANY -&gt; STREAM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          unit: (value) =&gt; {
            <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
              <span class="hljs-keyword">return</span> stream.cons(value, (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              });
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> stream.empty();
            }
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <h3 id="stream-map">stream#map</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>          map: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              <span class="hljs-keyword">return</span> match(lazyList,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.empty();
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
                    <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform)});
                }
              });
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h2 id="stream-append">stream#append</h2>
<p>append: (stream1, stream2) =&gt; {
  // var self = this;
  return match(stream1,{
    empty: (<em>) =&gt; {
      return stream2;
    },
    cons: (head1,tailThunk1) =&gt; {
      return match(stream2,{
        empty: (</em>) =&gt; {
          return stream1;
        },
        cons: (head2,tailThunk2) =&gt; {
          return stream.cons(head1,() =&gt; {
            return stream.append(tailThunk1(),stream2)});
        }
      });
    }
  });
},</p>
<h2 id="stream-concat">stream#concat</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>          concat: (xs) =&gt; {
            <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
              <span class="hljs-keyword">return</span> match(xs,{
                empty: (_) =&gt; {
                  <span class="hljs-keyword">return</span> ysThunk();
                },
                cons: (head,tailThunk) =&gt; {
                  <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
                    <span class="hljs-keyword">return</span> stream.concat(tailThunk())(ysThunk);
                  });
                }
              });
            };
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>
<p>flatten :: STREAM[STREAM[T]] =&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatten: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> match(lazyList,{
              empty: (_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              },
              cons: (head,tailThunk) =&gt; {
                <span class="hljs-keyword">return</span> stream.concat(head)((_) =&gt; {
                  <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
                });
              }
            });
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h3 id="stream-flatmap">stream#flatMap</h3>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>
<p>flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          flatMap: (lazyList) =&gt; {
            <span class="hljs-keyword">return</span> (transform) =&gt; {
              <span class="hljs-keyword">return</span> stream.flatten(stream.map(lazyList)(transform));
            };
          }
        };
        <span class="hljs-comment">/* #@range_end(stream_monad_definition) */</span>
        it(<span class="hljs-string">"stream#unit"</span>, (next) =&gt; {
          match(maybe.nothing(<span class="hljs-literal">null</span>),{
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> expect(
                _
              ).to.eql(
                <span class="hljs-literal">null</span>
              )
            },
            just: (value) =&gt; {
              <span class="hljs-keyword">return</span> expect().fail()
            }
          });
          <span class="hljs-keyword">var</span> lazyList = stream.unit(<span class="hljs-number">1</span>);
          expect(
            maybe.get(stream.head(lazyList))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(stream.unit(<span class="hljs-number">1</span>)))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(stream.unit(<span class="hljs-number">0</span>)))
          ).to.eql(
            <span class="hljs-number">0</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          expect(
            maybe.get(stream.head(lazyList))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });
          expect(
            stream.tail(lazyList)
          ).to.a(<span class="hljs-string">"function"</span>);

          match(stream.tail(lazyList),{
            nothing: (_) =&gt; {
              expect().fail();
            },
            just: (tail) =&gt; {
              match(tail,{
                empty: (_) =&gt; {
                  expect().fail();
                },
                cons: (head, tailThunk) =&gt; {
                  expect(head).to.eql(<span class="hljs-number">2</span>);
                }
              });
            }
          });
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(lazyList))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#toArray"</span>, (next) =&gt; {
          expect(
            stream.toArray(stream.empty())
          ).to.eql(
            []
          );
          expect(
            stream.toArray(stream.unit(<span class="hljs-number">1</span>))
          ).to.eql(
            [<span class="hljs-number">1</span>]
          );
          next();
        });
        it(<span class="hljs-string">"stream#concat"</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> xs = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.empty();
          });
          <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          };
          <span class="hljs-keyword">var</span> concatenatedStream = stream.concat(xs)(ysThunk);
          expect(
            maybe.get(stream.head(concatenatedStream))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(concatenatedStream))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        it(<span class="hljs-string">"stream#flatten"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>innerStream = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> innerStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
            <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
              <span class="hljs-keyword">return</span> stream.empty();
            });
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>outerStream = [[1,2]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> outerStream = stream.unit(innerStream);
          <span class="hljs-keyword">var</span> flattenedStream = stream.flatten(outerStream);
          match(flattenedStream,{
            empty: (_) =&gt; {
              expect().fail()
            },
            cons: (head,tailThunk) =&gt; {
              expect(head).to.eql(<span class="hljs-number">1</span>)
            }
          });
          expect(
            maybe.get(stream.head(flattenedStream))
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          expect(
            maybe.get(stream.head(maybe.get(stream.tail(flattenedStream))))
          ).to.eql(
            <span class="hljs-number">2</span>
          );
          next();
        });
        describe(<span class="hljs-string">"stream#map"</span>, () =&gt; {
          it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>lazyList = [1,2]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              });
            });
            <span class="hljs-keyword">var</span> doubledLazyList = stream.map(lazyList)((item) =&gt; {
              <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
            });
            expect(
              maybe.get(stream.head(doubledLazyList))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(doubledLazyList))))
            ).to.eql(
              <span class="hljs-number">4</span>
            );
            expect(
              stream.toArray(doubledLazyList)
            ).to.eql(
              [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
            );
            next();
          });
          it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(ones_infinite_sequence) */</span>
            <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> ones;
            });
            expect(
              maybe.get(stream.head(ones))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(ones))))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-comment">/* #@range_end(ones_infinite_sequence) */</span>
            <span class="hljs-keyword">var</span> twoes = stream.map(ones)((item) =&gt; {
              <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
            });
            expect(
              maybe.get(stream.head(twoes))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(twoes))))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(maybe.get(stream.tail(twoes))))))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            next();
          });
          it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
                <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
              });
            };
            expect(
              maybe.get(stream.head(integersFrom(<span class="hljs-number">0</span>)))
            ).to.eql(
              <span class="hljs-number">0</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
            ).to.eql(
              <span class="hljs-number">1</span>
            );
            <span class="hljs-keyword">var</span> doubledIntergerMapped = stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
              <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
            });
            expect(
              maybe.get(stream.head(doubledIntergerMapped))
            ).to.eql(
              <span class="hljs-number">0</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(doubledIntergerMapped))))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            <span class="hljs-keyword">var</span> doubledInterger = stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
              <span class="hljs-keyword">return</span> stream.unit(integer * <span class="hljs-number">2</span>);
            });
            expect(
              maybe.get(stream.head(doubledInterger))
            ).to.eql(
              <span class="hljs-number">0</span>
            );
            expect(
              maybe.get(stream.head(maybe.get(stream.tail(doubledInterger))))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            next();
          });
          it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> ones;
            });
            <span class="hljs-keyword">var</span> twoes = stream.flatMap(ones)((one) =&gt; {
              expect(one).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">return</span> stream.unit(one * <span class="hljs-number">2</span>);
            });
            expect(
              maybe.get(stream.head(twoes))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            next();
          });
          it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {
            <span class="hljs-comment">/*
              scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))
              scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))
              res0: List[Int] = List(2, 4, 6, 8)
            */</span>
            <span class="hljs-keyword">var</span> innerStream12 = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              });
            });
            <span class="hljs-keyword">var</span> innerStream34 = stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              });
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>nestedStream = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> nestedStream = stream.cons(innerStream12, (_) =&gt; {
              <span class="hljs-keyword">return</span> stream.cons(innerStream34,(_) =&gt; {
                <span class="hljs-keyword">return</span> stream.empty();
              });
            });
            <span class="hljs-keyword">var</span> flattenedStream = stream.flatMap(nestedStream)((innerStream) =&gt; {
              <span class="hljs-keyword">return</span> stream.flatMap(innerStream)((n) =&gt; {
                expect(n).to.a(<span class="hljs-string">'number'</span>);
                <span class="hljs-keyword">return</span> stream.unit(n * <span class="hljs-number">2</span>);
              });
            });
            expect(
              maybe.get(stream.head(flattenedStream))
            ).to.eql(
              <span class="hljs-number">2</span>
            );
            expect(
              stream.toArray(flattenedStream)
            ).to.eql(
              [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
            );
            next();
          });

        });
      }); <span class="hljs-comment">// streamモナド</span>
    }); <span class="hljs-comment">// モナド</span>
  });
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
