<!DOCTYPE html>

<html>
<head>
  <title>chap08.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chap08.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);
<span class="hljs-keyword">var</span> sys = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sys'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);


<span class="hljs-keyword">var</span> pair = {
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(pair, pattern);
  },
  cons: (left, right) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(left, right);
    };
  },
  right: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> pair.match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> right;
      }
    });
  },
  left: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> pair.match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> left;
      }
    });
  }
};

<span class="hljs-keyword">var</span> list  = {
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(list, pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head, tail) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(head, tail);
    };
  },
  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> list.cons(value, list.empty());
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> list.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(head, list.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>list#concat</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xss) =&gt; {
    <span class="hljs-keyword">return</span> list.match(xss,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> list.empty();
      },
      cons: (xs,xss) =&gt; {
        <span class="hljs-keyword">return</span> list.append(xs,xss);
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>join:: LIST[LIST[T]] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  join: (list_of_list) =&gt; {
    <span class="hljs-keyword">return</span> list.concat(list_of_list);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUNC[T -&gt; T] -&gt; LIST[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> list.match(alist,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> list.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(transform(head),list.map(tail)(transform));
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUNC[T -&gt; LIST] -&gt; T</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (alist) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> list.match(alist,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));
          }
        });
      };
    };
  },
  toArray: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.foldr(alist)([])((item) =&gt; {
      <span class="hljs-keyword">return</span> (accumulator) =&gt; {
        <span class="hljs-keyword">return</span> [item].concat(accumulator); 
      };
    });
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h1 id="-">関数型言語を作る</h1>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'関数型言語を作る'</span>, () =&gt; {
  describe(<span class="hljs-string">'環境を作る'</span>, () =&gt; {
    <span class="hljs-comment">/* #@range_begin(environment) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>空の環境</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> emptyEnv = (variable) =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    };
    <span class="hljs-comment">/* 変数名に対応する値を環境から取りだす */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>lookupEnv:: (STRING, ENV) =&gt; M[VALUE]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> lookupEnv = (identifier, env) =&gt; {
      <span class="hljs-keyword">return</span> env(identifier);
    };
    <span class="hljs-comment">/* 環境を拡張する */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>extendEnv:: (STRING, VALUE, ENV) =&gt; ENV </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> extendEnv = (identifier, value, env) =&gt; {
      expect(identifier).to.a(<span class="hljs-string">'string'</span>);
      <span class="hljs-keyword">return</span> (queryIdentifier) =&gt; {
        expect(queryIdentifier).to.a(<span class="hljs-string">'string'</span>);
        <span class="hljs-keyword">if</span>(identifier === queryIdentifier) {
          <span class="hljs-keyword">return</span> value;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> lookupEnv(queryIdentifier,env);
        }
      };
    };
    <span class="hljs-comment">/* #@range_end(environment) */</span>
    describe(<span class="hljs-string">'環境をテストする'</span>, () =&gt; {
      it(<span class="hljs-string">'extendEnvで環境を作り、 lookupEnv で環境を探る'</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> newEnv = extendEnv(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>, emptyEnv);
        expect(
          lookupEnv(<span class="hljs-string">"a"</span>, newEnv)
        ).to.be(
          <span class="hljs-number">1</span>
        );
        next();
      });
    });
    describe(<span class="hljs-string">'プログラムの構成要素(式と値)を作る'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2 id="-">値の代数的データ構造</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(value_algaraic_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>var value = {
  number : (numberValue) =&gt; {
    expect(numberValue).to.a(‘number’);
    return () =&gt; {
      return numberValue;
    };
  },
  closure: (lambdaExpression) =&gt; {
    expect(lambdaExpression).to.a(‘function’);
    return () =&gt; {
      return lambdaExpression;
    };
  },
  // 補助関数
  match : (data, pattern) =&gt; {
    return data.call(value, pattern);
  }
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_end(value_algaraic_datatype) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="-">式の代数的データ構造</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(expression_algaraic_datatype) */</span>
      <span class="hljs-keyword">var</span> exp = {
        match : (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data.call(exp, pattern);
        },
        num: (value) =&gt; {
          expect(value).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.num(value);
          };
        },
        variable : (name) =&gt; {
          expect(name).to.a(<span class="hljs-string">'string'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.variable(name);
          };
        },
        lambda : (variable, body) =&gt; {
          expect(variable).to.a(<span class="hljs-string">'function'</span>);
          expect(body).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.lambda(variable, body);
          };
        },
        app : (variable, arg) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.app(variable, arg);
          };
        },
        plus : (exp1,exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.plus(exp1, exp2);
          };
        },
        mul : (exp1,exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.mul(exp1, exp2);
          };
        },
        div : (exp1,exp2) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.div(exp1, exp2);
          };
        }
      };
      describe(<span class="hljs-string">'式をテストする'</span>, () =&gt; {
        it(<span class="hljs-string">"\\x.\\y.x"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>λx.λy.x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          exp.match(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),exp.variable(<span class="hljs-string">"x"</span>))),{
            lambda: (variable, arg) =&gt; {
              expect(
                variable
              ).to.a(<span class="hljs-string">'function'</span>);
            }
          });
          next();
        });
      });
      <span class="hljs-comment">/* #@range_end(expression_algaraic_datatype) */</span>
      describe(<span class="hljs-string">'モナド的評価器を作る'</span>, () =&gt; {
        describe(<span class="hljs-string">'恒等モナド的評価器を作る'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">eval</span> :: <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Exp</span> -&gt; m <span class="hljs-type">Int</span>
<span class="hljs-title">eval</span> (<span class="hljs-type">Const</span> x) = return x
<span class="hljs-title">eval</span> (<span class="hljs-type">Div</span> t u) = <span class="hljs-keyword">do</span> { x &lt;- eval t
                      y &lt;- eval u
                      return (x div y)}
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/* #@range_begin(identity_monad) */</span>
          <span class="hljs-keyword">var</span> ID = {
            unit: (value) =&gt; {
              <span class="hljs-keyword">return</span> value;
            },
            flatMap: (instance) =&gt; {
              <span class="hljs-keyword">return</span> (transform) =&gt; {
                expect(transform).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">return</span> transform(instance);
              };
            }
          };
          <span class="hljs-comment">/* #@range_end(identity_monad) */</span>
          <span class="hljs-comment">/* #@range_begin(identity_monad_evaluator) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>evaluate:: (EXP, ENV) =&gt; ID[VALUE]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> evaluate = (anExp, env) =&gt; {
            <span class="hljs-keyword">return</span> exp.match(anExp,{
              <span class="hljs-comment">/* 数値の評価 */</span>
              num: (numericValue) =&gt; {
                <span class="hljs-keyword">return</span> ID.unit(numericValue);
              },
              <span class="hljs-comment">/* 変数の評価 */</span>
              variable: (name) =&gt; {
                <span class="hljs-keyword">return</span> lookupEnv(name, env);
              },
              <span class="hljs-comment">/* λ式の評価 */</span>
              lambda: (argument, body) =&gt; {
                <span class="hljs-comment">/* クロージャーを返す */</span>
                <span class="hljs-keyword">return</span> exp.match(argument,{
                  variable: (name) =&gt; {
                    <span class="hljs-keyword">return</span> ID.unit((arg) =&gt; {
                      <span class="hljs-keyword">return</span> evaluate(body, extendEnv(name, arg, env));
                    });
                  }
                });
              },
              <span class="hljs-comment">/* 関数適用の評価 */</span>
              app: (func, arg) =&gt; {
                <span class="hljs-keyword">return</span> ID.flatMap(evaluate(func, env))((closure) =&gt; {
                  <span class="hljs-keyword">return</span> ID.flatMap(evaluate(arg, env))((actualArg) =&gt; {
                    <span class="hljs-keyword">return</span> ID.unit(closure(actualArg)); 
                  });
                });
              },
              plus: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> ID.unit(valueL + valueR); 
                  });
                });
              },
              mul: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> ID.unit(valueL * valueR); 
                  });
                });
              },
              div: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> ID.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> ID.unit(valueL / valueR); 
                  });
                });
              }
            });
          };
          <span class="hljs-comment">/* #@range_end(identity_monad_evaluator) */</span>
          it(<span class="hljs-string">'ID評価器で数値を評価する'</span>, (next) =&gt; {
            expect(
              evaluate(exp.num(<span class="hljs-number">2</span>), emptyEnv)
            ).to.be(
              ID.unit(<span class="hljs-number">2</span>)
            );
            next();
          });
          it(<span class="hljs-string">'ID評価器で演算を評価する'</span>, (next) =&gt; {
            expect(
              evaluate(exp.plus(exp.num(<span class="hljs-number">1</span>),exp.num(<span class="hljs-number">2</span>)), emptyEnv)
            ).to.be(
              ID.unit(<span class="hljs-number">3</span>)
            );
            expect(
              evaluate(exp.mul(exp.num(<span class="hljs-number">2</span>),exp.num(<span class="hljs-number">3</span>)), emptyEnv)
            ).to.be(
              ID.unit(<span class="hljs-number">6</span>)
            );
            next();
          });
          it(<span class="hljs-string">'ID評価器で変数を評価する'</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> env = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">1</span>, emptyEnv);
            expect(
              evaluate(exp.variable(<span class="hljs-string">"x"</span>), env)
            ).to.be(
              ID.unit(<span class="hljs-number">1</span>)
            );
            expect(
              evaluate(exp.variable(<span class="hljs-string">"y"</span>), env)
            ).to.be(
              ID.unit(<span class="hljs-literal">undefined</span>)
            );
            next();
          });
          it(<span class="hljs-string">'ID評価器で関数を評価する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>\x.x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> expression = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                                        exp.variable(<span class="hljs-string">"x"</span>));
            expect(
              evaluate(expression, emptyEnv)(<span class="hljs-number">1</span>)
            ).to.be(
              <span class="hljs-number">1</span>
            );
            next();
          });
          it(<span class="hljs-string">'ID評価器で関数適用を評価する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>\x.plus(x,x)(2)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> expression = exp.app(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                                        exp.plus(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"x"</span>))),
                                             exp.num(<span class="hljs-number">2</span>));
            expect(
              evaluate(expression, emptyEnv)
            ).to.be(
              <span class="hljs-number">4</span>
            );
            next();
          });
          it(<span class="hljs-string">'ID評価器で高階関数を評価する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>(\x.
   \y.
      x*y)(2)(3)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> expression = exp.app(
              exp.app(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                         exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                                    exp.mul(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"y"</span>)))),
                              exp.num(<span class="hljs-number">2</span>)),
              exp.num(<span class="hljs-number">3</span>));
            expect(
              evaluate(expression, emptyEnv)
            ).to.be(
              <span class="hljs-number">6</span>
            );
            next();
          });
        });
        describe(<span class="hljs-string">'ログ出力用評価器を作る'</span>, () =&gt; {
          <span class="hljs-comment">/* #@range_begin(expression_logger_interpreter) */</span>
          <span class="hljs-keyword">var</span> exp = {
            log: (anExp) =&gt; { <span class="hljs-comment">// ログ出力用の式</span>
              expect(anExp).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.log(anExp);
              };
            },
            <span class="hljs-comment">/* #@range_end(expression_logger_interpreter) */</span>
            match : (data, pattern) =&gt; {
              <span class="hljs-keyword">return</span> data.call(exp, pattern);
            },
            number : (value) =&gt; {
              expect(value).to.a(<span class="hljs-string">'number'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.number(value);
              };
            },
            closure: (lambdaExpssion) =&gt; {
              expect(lambdaExpssion).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.closure(lambdaExpssion);
              };
            },
            variable : (name) =&gt; {
              expect(name).to.a(<span class="hljs-string">'string'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.variable(name);
              };
            },
            lambda : (variable, body) =&gt; {
              expect(variable).to.a(<span class="hljs-string">'function'</span>);
              expect(body).to.a(<span class="hljs-string">'function'</span>);
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.lambda(variable, body);
              };
            },
            app : (variable, arg) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.app(variable, arg);
              };
            },
            plus : (exp1,exp2) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.plus(exp1, exp2);
              };
            },
            mul : (exp1,exp2) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.mul(exp1, exp2);
              };
            },
            div : (exp1,exp2) =&gt; {
              <span class="hljs-keyword">return</span> (pattern) =&gt; {
                <span class="hljs-keyword">return</span> pattern.div(exp1, exp2);
              };
            }
          };
          <span class="hljs-comment">/* #@range_begin(logger_monad) */</span>
          <span class="hljs-keyword">var</span> LOG = {
            unit: (value) =&gt; {
              <span class="hljs-keyword">return</span> pair.cons(list.empty(),value);
            },
            flatMap: (instance) =&gt; {
              <span class="hljs-keyword">return</span> (transform) =&gt; {
                expect(transform).to.a(<span class="hljs-string">'function'</span>);
                <span class="hljs-keyword">return</span> pair.match(instance,{
                  cons: (message, value) =&gt; {
                    <span class="hljs-keyword">var</span> newInstance = transform(value);
                    <span class="hljs-keyword">return</span> pair.cons(
                      list.append(message)(pair.left(newInstance)),
                      pair.right(newInstance));
                  }
                });
              };
            },
            output: (value) =&gt; {
              <span class="hljs-keyword">return</span> pair.cons(list.unit(<span class="hljs-built_in">String</span>(value)), <span class="hljs-literal">null</span>);
            }
          };
          <span class="hljs-comment">/* #@range_end(logger_monad) */</span>
          <span class="hljs-comment">/* #@range_begin(logger_monad_evaluator) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>evaluate:: (EXP, ENV) =&gt; ID[NUM]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> evaluate = (anExp, env) =&gt; {
            <span class="hljs-keyword">return</span> exp.match(anExp,{
              log: (anExp) =&gt; {
                <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(anExp, env))((value) =&gt; {
                  <span class="hljs-keyword">return</span> LOG.flatMap(LOG.output(value))((_) =&gt; {
                    <span class="hljs-keyword">return</span> LOG.unit(value); 
                  });
                });
              },
          <span class="hljs-comment">/* #@range_end(logger_monad_evaluator) */</span>
              <span class="hljs-comment">/* 数値の評価 */</span>
              number: (value) =&gt; {
                <span class="hljs-keyword">return</span> LOG.unit(value);
              },
              <span class="hljs-comment">/* 変数の評価 */</span>
              variable: (name) =&gt; {
                <span class="hljs-keyword">return</span> LOG.unit(lookupEnv(name, env));
              },
              <span class="hljs-comment">/* λ式の評価 */</span>
              lambda: (variable, bodyExp) =&gt; {
                <span class="hljs-comment">/* クロージャーを返す */</span>
                <span class="hljs-keyword">return</span> LOG.unit(exp.closure((arg) =&gt; { <span class="hljs-comment">/* クロージャーを返す */</span>
                  <span class="hljs-keyword">return</span> exp.match(variable,{ 
                    variable: (name) =&gt; {
                      <span class="hljs-keyword">return</span> evaluate(bodyExp, extendEnv(name, arg ,env));
                    }
                  });
                }));
              },
              <span class="hljs-comment">/* 関数適用の評価 */</span>
              app: (func, arg) =&gt; {
                <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(func, env))((closure) =&gt; {
                  <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(arg, env))((actualArg) =&gt; {
                    <span class="hljs-keyword">return</span> exp.match(closure,{ 
                      closure: (lambdaExpssion) =&gt; {
                        <span class="hljs-keyword">return</span> lambdaExpssion(actualArg);
                      }
                    });
                  });
                });
              },
              plus: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> LOG.unit(valueL + valueR); 
                  });
                });
              },
              mul: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> LOG.unit(valueL * valueR); 
                  });
                });
              },
              div: (expL, expR) =&gt; {
                <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expL, env))((valueR) =&gt; {
                  <span class="hljs-keyword">return</span> LOG.flatMap(evaluate(expR, env))((valueL) =&gt; {
                    <span class="hljs-keyword">return</span> LOG.unit(valueL / valueR); 
                  });
                });
              }
            });
          };
          it(<span class="hljs-string">'LOG評価器で数値を評価する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(log_interpreter_number) */</span>
            pair.match(evaluate(exp.log(exp.number(<span class="hljs-number">2</span>)), emptyEnv),{
              cons: (log, value) =&gt; {
                expect( <span class="hljs-comment">// 結果の値をテストする</span>
                  value
                ).to.be(
                  <span class="hljs-number">2</span>
                );
                expect( <span class="hljs-comment">// 保存されたログを見る</span>
                  list.toArray(log)
                ).to.eql(
                  [<span class="hljs-number">2</span>]
                );
              }
            });
            <span class="hljs-comment">/* #@range_end(log_interpreter_number) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>expect(
  pair.right(evaluate(
    exp.log(exp.number(2)), 
    emptyEnv))
).to.be(
  2
);
expect(
  list.toArray(pair.left(evaluate(exp.log(exp.number(2)), emptyEnv)))
).to.eql(
  [2]
);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            next();
          });
          it(<span class="hljs-string">'LOG評価器で演算を評価する'</span>, (next) =&gt; {
            <span class="hljs-comment">/* #@range_begin(log_interpreter_evaluation_strategy) */</span>
            pair.match(evaluate(exp.log(exp.plus(exp.number(<span class="hljs-number">1</span>),exp.number(<span class="hljs-number">2</span>))), emptyEnv),{
              cons: (log, value) =&gt; {
                expect(
                  value
                ).to.be(
                  <span class="hljs-number">3</span>
                );
                expect(
                  list.toArray(log)
                ).to.eql(
                  [<span class="hljs-number">3</span>]
                );
              }
            });
            pair.match(evaluate(exp.log(exp.plus(exp.log(exp.number(<span class="hljs-number">1</span>)),exp.log(exp.number(<span class="hljs-number">2</span>)))), emptyEnv),{
              cons: (log, value) =&gt; {
                expect(
                  value
                ).to.be(
                  <span class="hljs-number">3</span>
                );
                expect(
                  list.toArray(log)
                ).to.eql(
                  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
                );
              }
            });
            <span class="hljs-comment">/* #@range_end(log_interpreter_evaluation_strategy) */</span>
            next();
          });
          it(<span class="hljs-string">'LOG評価器で変数を評価する'</span>, (next) =&gt; {
            <span class="hljs-keyword">var</span> env = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">1</span>, emptyEnv);
            expect(
              pair.right(evaluate(exp.variable(<span class="hljs-string">"x"</span>), env))
            ).to.be(
              <span class="hljs-number">1</span>
            );
            expect(
              pair.right(evaluate(exp.variable(<span class="hljs-string">"y"</span>), env))
            ).to.be(
              <span class="hljs-literal">undefined</span>
            );
            next();
          });
          it(<span class="hljs-string">'LOG評価器で関数適用を評価する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>\x.plus(x,x)(2)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> expression = exp.app(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                                        exp.plus(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"x"</span>))),
                                             exp.number(<span class="hljs-number">2</span>));
            expect(
              pair.right(evaluate(expression, emptyEnv))
            ).to.be(
              <span class="hljs-number">4</span>
            );
            next();
          });
          it(<span class="hljs-string">'LOG評価器でlogを評価する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>(\x.
   \y.
      x*y)(2)(3)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> expression = exp.app(
              exp.app(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                         exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                                    exp.mul(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"y"</span>)))),
                              exp.number(<span class="hljs-number">2</span>)),
              exp.number(<span class="hljs-number">3</span>));
            expect(
              pair.right(evaluate(expression, emptyEnv))
            ).to.be(
              <span class="hljs-number">6</span>
            );
            next();
          });
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <pre><code>it(<span class="hljs-string">'ブール型を評価する'</span>, (next) =&gt; {
  <span class="hljs-comment">/* λx.λy.x */</span>
  <span class="hljs-keyword">var</span> trueFun = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),exp.variable(<span class="hljs-string">"x"</span>)));
  <span class="hljs-comment">/* λx.λy.y */</span>
  <span class="hljs-keyword">var</span> falseFun = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),exp.variable(<span class="hljs-string">"y"</span>)));
  <span class="hljs-keyword">var</span> not = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                   exp.app(
                     exp.app(
                       exp.variable(<span class="hljs-string">"x"</span>),falseFun),
                     trueFun));
  <span class="hljs-keyword">var</span> and = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                   exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                          exp.app(
                            exp.app(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"y"</span>)),
                            falseFun)));
  <span class="hljs-keyword">var</span> or = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                  exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                         exp.app(
                           exp.app(exp.variable(<span class="hljs-string">"x"</span>),trueFun),
                           exp.variable(<span class="hljs-string">"y"</span>))));
  <span class="hljs-keyword">var</span> cond = exp.lambda(exp.variable(<span class="hljs-string">"pred"</span>),
                    exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                           exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                  exp.app(
                                    exp.app(exp.variable(<span class="hljs-string">"pred"</span>),exp.variable(<span class="hljs-string">"x"</span>)),exp.variable(<span class="hljs-string">"y"</span>)))));
  expect(
    evaluate(
      exp.app(
        exp.app(trueFun,exp.number(<span class="hljs-number">1</span>)),
        exp.number(<span class="hljs-number">0</span>)),
      emptyEnv)
  ).to.eql(
    <span class="hljs-number">1</span>
  );
  expect(
    evaluate(
      exp.app(
        exp.app(
          exp.app(not, trueFun), exp.number(<span class="hljs-number">1</span>)), exp.number(<span class="hljs-number">0</span>)),emptyEnv)
  ).to.eql(
    <span class="hljs-number">0</span>
  );
  expect(
    evaluate(
      exp.app(
        exp.app(
          exp.app(
            exp.app(and,
                        trueFun),
            trueFun),
          exp.number(<span class="hljs-number">1</span>)),
        exp.number(<span class="hljs-number">0</span>)),emptyEnv)
  ).to.be(
    <span class="hljs-number">1</span>
  );
  expect(
    evaluate(
      exp.app(
        exp.app(
          exp.app(
            exp.app(
              exp.app(cond, trueFun),
              falseFun),
            trueFun),
          exp.number(<span class="hljs-number">1</span>)),
        exp.number(<span class="hljs-number">0</span>)),
      emptyEnv)
  ).to.eql(
    <span class="hljs-number">0</span>
  );
  next();
});
</code></pre><p>  });
  describe(‘プリティプリンタを作る’, () =&gt; {
    var prettyPrint = (anExp) =&gt; {
      return exp.match(anExp,{
        /<em> 数値 </em>/
        number: (value) =&gt; {
          return {
            number: value
          };
        },
        /<em> 変数 </em>/
        variable: (name) =&gt; {
          return {
            variable: name
          };
        },
        /<em> λ式 </em>/
        lambda: (variable, bodyExp) =&gt; {
          return {
            lambda: {
              variable: variable,
              bodyExp: prettyPrint(bodyExp)
            }
          };
        },
        /<em> 関数適用評価 </em>/
        app: (variable, arg) =&gt; {
          return {
            app: {
              variable: variable,
              arg: prettyPrint(arg)
            }
          };
        }
      });
    };
    it(‘prettyPrintをテストする’, (next) =&gt; {
      expect(
        prettyPrint(exp.number(2))
      ).to.eql(
        {“number” : 2}
      );
      next();
    });
    describe(‘ローダーを作る’, () =&gt; {
      var load = (object) =&gt; {
        //            return (callback) =&gt; {
        for (var key in object) {
          switch (key){
          case “number”:
            return exp.number(parseInt(object[key],10));
            break;
          default:
            throw new Error();
            break;
          }
        }
        //            };
      };
      it(‘ローダーをテストする’, (next) =&gt; {
        expect(
          evaluate(load({“number” : 2}, emptyEnv))
        ).to.eql(
          2
        );
        next();
      });
  // describe(‘ファイル操作’, () =&gt; {
  //   it(‘数値を評価する’, (next) =&gt; {
  //     fs.writeFileSync(‘/tmp/nodejs-labo-test.json’,  JSON.stringify(number(2), null, ‘    ‘));
  //     expect(
  //       JSON.parse(fs.readFileSync(‘/tmp/nodejs-labo-test.json’, ‘utf8’))
  //     ).to.eql(
  //       2
  //     );
  //     next();
  //   });
  // });
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }); <span class="hljs-comment">// </span>
    describe(<span class="hljs-string">'例外捕捉評価器'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h2 id="-">式の代数的データ構造</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(continuation_passing_interpreter_expression) */</span>
      <span class="hljs-keyword">var</span> exp = {
        match : (data, pattern) =&gt; {
          <span class="hljs-keyword">return</span> data.call(exp, pattern);
        },
        exception: (message) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.exception(message);
          };
        },
        raise: (exception) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.raise(exception);
          };
        },
        tryWith: (anExp, exception, raisedExp) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.tryWith(anExp, exception, raisedExp);
          };
        },
        <span class="hljs-comment">/* #@range_end(continuation_passing_interpreter_expression) */</span>
        number: (value) =&gt; {
          expect(value).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.number(value);
          };
        },
        variable: (name) =&gt; {
          expect(name).to.a(<span class="hljs-string">'string'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.variable(name);
          };
        },
        lambda: (variable, body) =&gt; {
          expect(variable).to.a(<span class="hljs-string">'function'</span>);
          expect(body).to.a(<span class="hljs-string">'function'</span>);
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.lambda(variable, body);
          };
        },
        app: (variable, arg) =&gt; {
          <span class="hljs-keyword">return</span> (pattern) =&gt; {
            <span class="hljs-keyword">return</span> pattern.app(variable, arg);
          };
        }
      }; <span class="hljs-comment">// exp</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2 id="-">式の評価関数</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_begin(continuation_passing_interpreter_evaluate) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>evaluateCPS: (EXP, ENV, FUNC[VALUE -&gt; VALUE]) -&gt; VALUE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> evaluateCPS = (anExp, env, continues, continuesInFailure) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>c.f. Programming Language Concepts, p.208</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> exp.match(anExp,{
          <span class="hljs-comment">/* 例外の評価 */</span>
          raise: (exception) =&gt; {
            <span class="hljs-keyword">return</span> continuesInFailure(exception);
          },
          tryWith: (anExp, caughtException, failSafeExp) =&gt; {
            <span class="hljs-keyword">var</span> newContinuesInFailure = (thrownException) =&gt; {
              <span class="hljs-keyword">if</span> (thrownException.message === caughtException.message) {
                <span class="hljs-keyword">return</span> evaluateCPS(failSafeExp, env, continues, continuesInFailure);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> continuesInFailure(thrownException);
              }
            };
            <span class="hljs-keyword">return</span> evaluateCPS(anExp, env, continues, newContinuesInFailure);
          },
          <span class="hljs-comment">/* 数値の評価 */</span>
          number: (answer) =&gt; {
            <span class="hljs-keyword">return</span> continues(answer);
          },
          <span class="hljs-comment">/* 変数の評価 */</span>
          variable: (name) =&gt; {
            <span class="hljs-keyword">var</span> found = lookupEnv(name, env);
            <span class="hljs-keyword">if</span>(found === <span class="hljs-literal">undefined</span>){
              <span class="hljs-keyword">return</span> continuesInFailure(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(name + <span class="hljs-string">" not found"</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>return new Error(name + “ not found”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> continues(found);
            }
          },
          <span class="hljs-comment">/* λ式の評価 */</span>
          lambda: (anExp, bodyExp) =&gt; {
            <span class="hljs-comment">/* クロージャーを返す */</span>
            <span class="hljs-keyword">return</span> (actualArg) =&gt; {
              <span class="hljs-keyword">return</span> exp.match(anExp,{
                variable: (name) =&gt; {
                  <span class="hljs-keyword">return</span> continues(evaluateCPS(bodyExp, extendEnv(name, actualArg ,env), continues));
                },
                number: (value) =&gt; {
                  <span class="hljs-keyword">return</span> continuesInFailure(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"lambdaの引数が数値になっています"</span>));
                },
                lambda: ($$,$$$) =&gt; {
                  <span class="hljs-keyword">return</span> continuesInFailure(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"lambdaの引数がlambbaになっています"</span>));
                }
              });
            };
          },
          <span class="hljs-comment">/* 関数適用の評価 */</span>
          app: (anExp, arg) =&gt; {
            <span class="hljs-keyword">var</span> rator = evaluateCPS(anExp, env, continues, continuesInFailure);
            <span class="hljs-keyword">var</span> rand = evaluateCPS(arg, env, continues, continuesInFailure);
            <span class="hljs-keyword">return</span> continues(rator(rand));
          }
        });
        <span class="hljs-comment">/* #@range_end(continuation_passing_interpreter_evaluate) */</span>
      };
      describe(<span class="hljs-string">'例外捕捉評価器をテストする'</span>, () =&gt; {
        <span class="hljs-keyword">var</span> continuesNormally = (result) =&gt; {
          <span class="hljs-keyword">return</span> result;
        };
        <span class="hljs-keyword">var</span> continuesAbnormally = (exception) =&gt; {
          <span class="hljs-keyword">return</span> exception;
        };
        it(<span class="hljs-string">'数値を評価する'</span>, (next) =&gt; {
          expect(
            evaluateCPS(exp.number(<span class="hljs-number">2</span>), emptyEnv, continuesNormally, continuesAbnormally)
          ).to.eql(<span class="hljs-number">2</span>);
          next();
        });
        it(<span class="hljs-string">'変数を評価する'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> env = extendEnv(<span class="hljs-string">"x"</span>,<span class="hljs-number">1</span>, emptyEnv, continuesNormally, continuesAbnormally);
          expect(
            evaluateCPS(exp.variable(<span class="hljs-string">"x"</span>), env, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>自由変数の場合は、 例外が返る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            evaluateCPS(exp.variable(<span class="hljs-string">"y"</span>), env, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"y not found"</span>)
          );
          next();
        });
        it(<span class="hljs-string">'constant関数'</span>, (next) =&gt; {
          <span class="hljs-keyword">var</span> constant = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.number(<span class="hljs-number">1</span>));
          expect(
            evaluateCPS(constant, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.a(
            <span class="hljs-string">'function'</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>(λx.1)(2)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> applied = exp.app(constant, exp.number(<span class="hljs-number">2</span>));
          expect(
            evaluateCPS(applied, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">'identity関数をテストする'</span>, (next) =&gt; {
          <span class="hljs-comment">/* λx.x */</span>
          <span class="hljs-keyword">var</span> identity = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"x"</span>));
          expect(
            evaluateCPS(identity, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.a(
            <span class="hljs-string">'function'</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>(λx.x)(1) = 1 */</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> appliedExpression = exp.app(identity, exp.number(<span class="hljs-number">1</span>));
          expect(
            evaluateCPS(appliedExpression, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          next();
        });
        it(<span class="hljs-string">'ブール型を評価する'</span>, (next) =&gt; {
          <span class="hljs-keyword">this</span>.timeout(<span class="hljs-number">1000</span>);
          <span class="hljs-comment">/* λx.λy.x */</span>
          <span class="hljs-keyword">var</span> trueFun = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),exp.variable(<span class="hljs-string">"x"</span>)));
          <span class="hljs-comment">/* λx.λy.y */</span>
          <span class="hljs-keyword">var</span> falseFun = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),exp.variable(<span class="hljs-string">"y"</span>)));
          <span class="hljs-keyword">var</span> not = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                               exp.app(
                                 exp.app(
                                   exp.variable(<span class="hljs-string">"x"</span>),falseFun),
                                 trueFun));
          <span class="hljs-keyword">var</span> and = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                               exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                          exp.app(
                                            exp.app(exp.variable(<span class="hljs-string">"x"</span>),exp.variable(<span class="hljs-string">"y"</span>)),
                                            falseFun)));
          <span class="hljs-keyword">var</span> or = exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                              exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                         exp.app(
                                           exp.app(exp.variable(<span class="hljs-string">"x"</span>),trueFun),
                                           exp.variable(<span class="hljs-string">"y"</span>))));
          <span class="hljs-keyword">var</span> cond = exp.lambda(exp.variable(<span class="hljs-string">"pred"</span>),
                                exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                           exp.lambda(exp.variable(<span class="hljs-string">"y"</span>),
                                                      exp.app(
                                                        exp.app(exp.variable(<span class="hljs-string">"pred"</span>),exp.variable(<span class="hljs-string">"x"</span>)),exp.variable(<span class="hljs-string">"y"</span>)))));</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>(λx.λy.x)(1)(0) = 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            evaluateCPS(
              exp.app(
                exp.app(trueFun,exp.number(<span class="hljs-number">1</span>)),
                exp.number(<span class="hljs-number">0</span>)),
              emptyEnv,
              continuesNormally,
              continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>(λx.λy.x)(1)(z) = 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            evaluateCPS(
              exp.app(
                exp.app(trueFun,exp.number(<span class="hljs-number">1</span>)),
                exp.variable(<span class="hljs-string">"z"</span>)),
              emptyEnv,
              continuesNormally,
              continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>(λx.λy.x)(z)(0) = error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expect(
            evaluateCPS(
              exp.app(
                exp.app(trueFun,exp.variable(<span class="hljs-string">"z"</span>)),
                exp.number(<span class="hljs-number">0</span>)),
              emptyEnv,
              continuesNormally, 
              continuesAbnormally)
          ).to.eql(
            <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"z not found"</span>)
          );
          next();
        });
        it(<span class="hljs-string">'投げられた例外を捕捉する'</span>, (next) =&gt; {
          <span class="hljs-comment">/* #@range_begin(continuation_passing_interpreter_trycatch) */</span>
          <span class="hljs-keyword">var</span> tryExpression = exp.tryWith(
            exp.raise(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"exception"</span>)), <span class="hljs-comment">// exp</span>
            <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"exception"</span>), <span class="hljs-comment">// caughtException</span>
            exp.number(<span class="hljs-number">1</span>) <span class="hljs-comment">// failSafeExp</span>
          );
          expect(
            evaluateCPS(tryExpression, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>(λx.tryWith(raise, exception , 1))(0) = 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> catchException = exp.app(exp.lambda(exp.variable(<span class="hljs-string">"x"</span>),
                                                          exp.tryWith(
                                                            exp.raise(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"exception"</span>)),
                                                            <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"exception"</span>),
                                                            exp.number(<span class="hljs-number">1</span>)
                                                          )),
                                               exp.number(<span class="hljs-number">0</span>));
          expect(
            evaluateCPS(catchException, emptyEnv, continuesNormally, continuesAbnormally)
          ).to.eql(
            <span class="hljs-number">1</span>
          );
          <span class="hljs-comment">/* #@range_end(continuation_passing_interpreter_trycatch) */</span>
          next();
        });
      });
    });
  });
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
