<!DOCTYPE html>

<html>
<head>
  <title>monad.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <!-- <script type="text/x-mathjax-config"> -->
  <!--   MathJax.Hub.Config({ -->
  <!--   tex2jax: { -->
  <!--       inlineMath: [ ['$','$'], ['\\(','\\)'] ], -->
  <!--       displayMath: [ ['$$','$$'], ["\\[","\\]"] ], -->
  <!--       processEscapes: true -->
  <!--   } -->
  <!--   }); -->
  <!-- </script> -->
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>monad.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-">モナド</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> pair = {
  match : (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(data,pattern);
  },
  cons: (left, right) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(left, right);
    };
  },
  right: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> pair.match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> right;
      }
    });
  },
  left: (tuple) =&gt; {
    <span class="hljs-keyword">return</span> pair.match(tuple, {
      cons: (left, right) =&gt; {
        <span class="hljs-keyword">return</span> left;
      }
    });
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="id-">IDモナド</h2>
<h3 id="id-">IDモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ID = {
  <span class="hljs-comment">/* unit:: T =&gt; ID[T] */</span>
  unit: (value) =&gt; {  <span class="hljs-comment">// 単なる identity関数と同じ</span>
    <span class="hljs-keyword">return</span> value;
  },
  <span class="hljs-comment">/* flatMap:: ID[T] =&gt; FUN[T =&gt; ID[T]] =&gt; ID[T] */</span>
  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> transform(instanceM); <span class="hljs-comment">// 単なる関数適用と同じ</span>
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3 id="id-">IDモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"IDモナドをテストする"</span>,() =&gt; {
  it(<span class="hljs-string">"ID#unit"</span>, (next) =&gt; {
    expect(
      ID.unit(<span class="hljs-number">1</span>)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="maybe-">Maybeモナド</h2>
<h3 id="maybe-">Maybeモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>
  <span class="hljs-type">Nothing</span>  &gt;&gt;= _ = <span class="hljs-type">Nothing</span>
  (<span class="hljs-type">Just</span> x) &gt;&gt;= f = f x
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Maybe = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data(pattern);
  },
  just : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.just(value);
    };
  },
  nothing : (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.nothing(_);
    };
  },
  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.just(value);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>
   fmap _ <span class="hljs-type">Nothing</span> = <span class="hljs-type">Nothing</span>
   fmap f (<span class="hljs-type">Just</span> x) = <span class="hljs-type">Just</span> (f x)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        },
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.just(transform(value));
        }
      });
    };
  },
  flatMap : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        }
      });
    };
  },
  get: (maybe) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.getOrElse(maybe)(<span class="hljs-literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>return Maybe.match(maybe,{
  just: (value) =&gt; {
    return value;
  },
  nothing: (_) =&gt; {
    return null;
  }
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },
  getOrElse: (instance) =&gt; {
    <span class="hljs-keyword">return</span> (alternate) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.match(instance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> value;
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> alternate;
        }
      });
    };
  },
  isEqual : (maybeA) =&gt; {
    <span class="hljs-keyword">return</span> (maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.match(maybeA,{
        just: (valueA) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (valueB) =&gt; {
              <span class="hljs-keyword">return</span> (valueA === valueB);
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });
        }
      });
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3 id="maybe-">Maybeモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Maybeモナドをテストする"</span>,() =&gt; {
  it(<span class="hljs-string">"Maybe#map"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <pre><code class="lang-haskell">&gt; fmap (+<span class="hljs-number">1</span>) nothing
<span class="hljs-type">Nothing</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(
      Maybe.isEqual(
        Maybe.map(Maybe.nothing())(succ)
      )(
        Maybe.nothing()
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      Maybe.isEqual(
        Maybe.map(Maybe.just(<span class="hljs-number">1</span>))(succ)
      )(
        Maybe.just(<span class="hljs-number">2</span>)
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
  it(<span class="hljs-string">"Maybe#flatMap"</span>, (next) =&gt; {
    Maybe.match(Maybe.flatMap(Maybe.just(<span class="hljs-number">1</span>))((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      },
      nothing: (_) =&gt; {
       expect().fail();
      }
    });
    Maybe.match(Maybe.flatMap(Maybe.nothing())((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
       expect().fail();
      },
      nothing: (_) =&gt; {
       expect(<span class="hljs-literal">true</span>).to.be.ok();
      }
    });
    next();
  });
  it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeA)((a) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.flatMap(maybeB)((b) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.unit(a + b);
        });
      });
    };
    <span class="hljs-keyword">var</span> justOne = Maybe.just(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> justTwo = Maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justThree = Maybe.just(<span class="hljs-number">3</span>);
    expect(
      Maybe.isEqual(
        add(justOne,justTwo)
      )(
        justThree
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      Maybe.isEqual(
        add(justOne,Maybe.nothing())
      )(
        Maybe.nothing()
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2 id="list-">Listモナド</h2>
<h3 id="list-">Listモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> [] <span class="hljs-keyword">where</span></span>
  xs &gt;&gt;= f = concat (map f xs)
  return x = [x]
  fail s   = []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> List  = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(List,pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]</p>
<pre><code class="lang-haskell"><span class="hljs-title">append</span> [] ys = ys
<span class="hljs-title">append</span> (x:xs) ys = x : (xs ++ ys)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> List.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(head,List.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]</p>
<pre><code class="lang-haskell"><span class="hljs-title">concat</span> [] = []
<span class="hljs-title">concat</span> (xs:xss) = xs ++ concat xss
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (xss) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(xss)(List.empty())(List.append);
  },
  join: (xss) =&gt; {
    <span class="hljs-keyword">return</span> List.concat(xss);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">flatten</span> :: [[a]] -&gt; [a]
<span class="hljs-title">flatten</span> =  foldr (++) []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (instanceMM) =&gt; {
    <span class="hljs-keyword">return</span> List.concat(instanceMM);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUN[T-&gt;U] -&gt; LIST[U]</p>
<pre><code class="lang-haskell"><span class="hljs-title">map</span> [] _ = []
<span class="hljs-title">map</span> (x:xs) f = f x : map xs f
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> List.match(instanceM,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> List.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(transform(head),
                           List.map(tail)(transform));
        }
      });
    };
  },
  unit: (value) =&gt; {
    <span class="hljs-keyword">return</span> List.cons(value, List.empty());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">xs</span> &gt;&gt;= f = concat (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; { <span class="hljs-comment">// FUN[T-&gt;LIST[T]]</span>
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> List.join(List.map(instanceM)(transform));</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>return List.concat(List.map(instanceM)(transform));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
  },
  <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>1段階のリストしか配列に変更できない</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(alist)([])((item) =&gt; {
      <span class="hljs-keyword">return</span> (accumulator) =&gt; {
        <span class="hljs-keyword">return</span> [item].concat(accumulator);
      };
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUN[T -&gt; U -&gt; U] -&gt; T</p>
<pre><code class="lang-haskell"><span class="hljs-title">foldr</span> []     z _ = z
<span class="hljs-title">foldr</span> (x:xs) z f = f x (foldr xs z f)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (alist) =&gt; {         <span class="hljs-comment">// alist:: LIST[T]</span>
    <span class="hljs-keyword">return</span> (accumulator) =&gt; { <span class="hljs-comment">// accumulator:: T</span>
      <span class="hljs-keyword">return</span> (glue) =&gt; {      <span class="hljs-comment">// glue:: FUN[T -&gt; U -&gt; U] </span>
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> List.match(alist, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(List.foldr(tail)(accumulator)(glue));;
          }
        });
      };
    };
  }
}; <span class="hljs-comment">// end of list monad</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h3 id="list-">Listモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Listモナドのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">"'List#empty'"</span>, (next) =&gt; {
    List.match(List.empty,{
      empty: (_) =&gt; {
        expect(<span class="hljs-literal">true</span>).ok();
      },
      cons: (x,xs) =&gt; {
        expect().fail();
      }
    });
    next();
  });
  it(<span class="hljs-string">"'List#isEmpty'"</span>, (next) =&gt; {
    expect(
      List.isEmpty(List.empty())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      List.isEmpty(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#cons'"</span>, (next) =&gt; {
    List.match(List.cons(<span class="hljs-number">1</span>,List.empty()),{
      empty: (_) =&gt; {
        expect().fail();
      },
      cons: (x,xs) =&gt; {
        expect(x).to.eql(<span class="hljs-number">1</span>);
      }
    });
    next();
  });
  it(<span class="hljs-string">"'List#head'"</span>, (next) =&gt; {
    expect(
      List.head(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#tail'"</span>, (next) =&gt; {
    expect(
      List.head(List.tail(List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#append'"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.append(List.cons(<span class="hljs-number">1</span>,List.empty()))(List.cons(<span class="hljs-number">2</span>,List.empty()));
    expect(
      List.head(theList)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(theList))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(theList)))
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#concat'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [[1,2],[3,4]] */</span>
    <span class="hljs-keyword">var</span> one_two = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
    <span class="hljs-keyword">var</span> three_four = List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()));

    <span class="hljs-keyword">var</span> list_of_list = List.cons(one_two,
                                 List.cons(three_four, List.empty()));
    <span class="hljs-comment">/* concated_list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> concated_list = List.concat(list_of_list);
    expect(
      List.toArray(concated_list)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    expect(
      List.head(concated_list)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(concated_list))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(concated_list)))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#foldr'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.foldr(theList)(<span class="hljs-number">0</span>)((item) =&gt; {
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> accumulator + item;
        };
      })
    ).to.eql(
      <span class="hljs-number">10</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#map'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.toArray(List.map(theList)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      }))
    ).to.eql(
      [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
    );
    next();
  });
  it(<span class="hljs-string">"'List#unit'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1] */</span>
    expect(
      List.toArray(List.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    expect(
      List.toArray(List.unit(<span class="hljs-literal">null</span>))
    ).to.eql(
      [<span class="hljs-literal">null</span>]
    );
    next();
  });
  describe(<span class="hljs-string">"List#flatMap"</span>, () =&gt; {
    it(<span class="hljs-string">"[1]の要素の2倍は、[2]"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-type">Prelude</span>&gt; [<span class="hljs-number">1</span>] &gt;&gt;= \x -&gt; [x * <span class="hljs-number">2</span>]
[<span class="hljs-number">2</span>]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>, List.empty());
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>]
      );
      next();
    });
    it(<span class="hljs-string">"[]の要素の2倍は、[]"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-type">Prelude</span>&gt; [] &gt;&gt;= \x -&gt; [x * <span class="hljs-number">2</span>]
[]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> emptyList = List.empty();
      expect(
        List.toArray(List.flatMap(emptyList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        []
      );
      next();
    });
    it(<span class="hljs-string">"[1,2]と[1,2]のそれぞれの要素を足して3になる組み合わせを求める"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> list1 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                         List.empty()));
      <span class="hljs-keyword">var</span> list2 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                         List.empty()));
      expect(
        List.toArray(List.flatMap(list1)((item1) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(list2)((item2) =&gt; {
            <span class="hljs-keyword">if</span>(item1 + item2 === <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">return</span> List.unit([item1, item2]);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> List.empty();
            }
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]
      );
      next();
    });
    it(<span class="hljs-string">"'List#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>, List.cons(<span class="hljs-number">3</span>, List.empty())));
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.append(List.unit(item))(List.unit(- item));
        }))
      ).to.eql(
        [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
      );
      next();
    });
    it(<span class="hljs-string">"素数を求める"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> enumFromTo = (x,y) =&gt; {
        <span class="hljs-keyword">if</span>(x &gt; y) {
          <span class="hljs-keyword">return</span> List.empty();
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> List.cons(x, enumFromTo(x+<span class="hljs-number">1</span>,y));
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">factors</span> :: <span class="hljs-type">Int</span> -&gt; [<span class="hljs-type">Int</span>]
<span class="hljs-title">factors</span> n = [x | x &lt;- [<span class="hljs-number">1.</span>.n], n `mod` x == <span class="hljs-number">0</span>]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> factors = (n) =&gt; {
        <span class="hljs-keyword">return</span> List.flatMap(enumFromTo(<span class="hljs-number">1</span>,n))((x) =&gt; {
          <span class="hljs-keyword">if</span>((n % x) === <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> List.unit(x);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> List.empty(); 
          }
        });
      };
      expect(
        List.toArray(factors(<span class="hljs-number">15</span>))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>]
      );
      expect(
        List.toArray(factors(<span class="hljs-number">7</span>))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">7</span>]
      );</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">isPrime</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">isPrime</span> n = factors n == [<span class="hljs-number">1</span>,n]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> isPrime = (n) =&gt; {
        <span class="hljs-keyword">return</span> List.toArray(factors(n)) === List.toArray(enumFromTo(<span class="hljs-number">1</span>,n));
      };
      expect(
        isPrime(<span class="hljs-number">15</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      expect(
        isPrime(<span class="hljs-number">13</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
  });
  it(<span class="hljs-string">"'List#toArray'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.toArray(theList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    next();
  });
  describe(<span class="hljs-string">"'List#toArray'"</span>, () =&gt; {
    it(<span class="hljs-string">"1段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
      expect(
        List.toArray(theList)
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>list = [[1],[2]] </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> nestedList = List.cons(List.cons(<span class="hljs-number">1</span>,List.empty()),
                                 List.cons(List.cons(<span class="hljs-number">2</span>,List.empty()),
                                           List.empty()));
      expect(
        List.toArray(List.flatMap(nestedList)((alist) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(alist)((item) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(item);
          });
        }))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
      );
      next();
    });
  });
  describe(<span class="hljs-string">"Listモナドを活用する"</span>,() =&gt; {
    it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()))));
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">if</span>(even(item)) {
            <span class="hljs-keyword">return</span> List.unit(item);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> List.empty();
          }
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> theNumberList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
      <span class="hljs-keyword">var</span> theStringList = List.cons(<span class="hljs-string">"one"</span>,List.cons(<span class="hljs-string">"two"</span>,List.empty()));
      expect(
        List.toArray(List.flatMap(theNumberList)((n) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(theStringList)((s) =&gt; {
            <span class="hljs-keyword">return</span> List.unit([n,s]);
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
      );
      next();
    });
    <span class="hljs-comment">/* #@range_begin(list_maybe) */</span>
    describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
      it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.empty());
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        next();
      });
      it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(null),
                          list.empty());
  var justList = list.flatMap(theList)((listItem) =&gt; {
    return maybe.flatMap(listItem)((value) =&gt; {
      return list.unit(value);
      // return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h2 id="stream-">Streamモナド</h2>
<h3 id="stream-">Streamモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Stream = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(Stream,pattern);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Stream#unit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* unit:: ANY -&gt; STREAM */</span>
  unit: (value) =&gt; {
    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
      <span class="hljs-keyword">return</span> Stream.cons(value, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> Stream.empty();
    }
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },
  <span class="hljs-comment">/* head:: STREAM -&gt; MAYBE[STREAM] */</span>
  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(value);
      }
    });
  },
  <span class="hljs-comment">/* tail:: STREAM -&gt; MAYBE[STREAM] */</span>
  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(tailThunk());
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Stream#toArray</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> [];
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">if</span>(Stream.isEmpty(tailThunk())){
          <span class="hljs-keyword">return</span> [head];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> [head].concat(Stream.toArray(tailThunk()));
        }
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Stream#map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> Stream.match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> Stream.cons(transform(head),(_) =&gt; {
            <span class="hljs-keyword">return</span> Stream.map(tailThunk())(transform)});
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Stream#append</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
      <span class="hljs-keyword">return</span> Stream.match(xs,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ysThunk();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> Stream.cons(head,(_) =&gt; {
            <span class="hljs-keyword">return</span> Stream.append(tailThunk())(ysThunk);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Stream#concat</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* concat:: STREAM[STREAM[T]] -&gt; STREAM[T] */</span>
  concat: (astream) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(astream,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Stream.append(head,tailThunk());
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Stream#flatten</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* flatten :: STREAM[STREAM[T]] =&gt; STREAM[T] */</span>
  flatten: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Stream.append(head)((_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.flatten(tailThunk());
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Stream#flatMap
flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T]</p>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> Stream.flatten(Stream.map(lazyList)(transform));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>monad.stream#foldr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> Stream.match(instanceM,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(Stream.foldr(tailThunk())(accumulator)(glue));
          }
        });
      };
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3 id="stream-">Streamモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Streamモナドのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">"Stream#unit"</span>, (next) =&gt; {
    Stream.match(Maybe.nothing(<span class="hljs-literal">null</span>),{
      nothing: (_) =&gt; {
        <span class="hljs-keyword">return</span> expect(
          _
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
      },
      just: (value) =&gt; {
        <span class="hljs-keyword">return</span> expect().fail();
      }
    });
    <span class="hljs-keyword">var</span> lazyList = Stream.unit(<span class="hljs-number">1</span>);
    expect(
      Maybe.get(Stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Stream.unit(<span class="hljs-number">1</span>)))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Stream.unit(<span class="hljs-number">0</span>)))
    ).to.eql(
      <span class="hljs-number">0</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#cons"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    expect(
      Maybe.get(Stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#tail"</span>, (next) =&gt; {
    <span class="hljs-comment">/* lazyList = [1,2] */</span>
    <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    expect(
      Stream.tail(lazyList)
    ).to.a(<span class="hljs-string">"function"</span>);

    Stream.match(Stream.tail(lazyList),{
      nothing: (_) =&gt; {
        expect().fail();
      },
      just: (tail) =&gt; {
        Stream.match(tail,{
          empty: (_) =&gt; {
            expect().fail();
          },
          cons: (head, tailThunk) =&gt; {
            expect(head).to.eql(<span class="hljs-number">2</span>);
          }
        });
      }
    });
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(lazyList))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#toArray"</span>, (next) =&gt; {
    expect(
      Stream.toArray(Stream.empty())
    ).to.eql(
      []
    );
    expect(
      Stream.toArray(Stream.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });
  it(<span class="hljs-string">"Stream#append"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> xs = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.empty();
    });
    <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    };
    <span class="hljs-keyword">var</span> theStream = Stream.append(xs)(ysThunk);
    expect(
      Maybe.get(Stream.head(theStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(theStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#flatten"</span>, (next) =&gt; {
    <span class="hljs-comment">/* innerStream = [1,2] */</span>
    <span class="hljs-keyword">var</span> innerStream = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    <span class="hljs-comment">/* outerStream = [[1,2]] */</span>
    <span class="hljs-keyword">var</span> outerStream = Stream.unit(innerStream);
    <span class="hljs-keyword">var</span> flattenedStream = Stream.flatten(outerStream);
    Stream.match(flattenedStream,{
      empty: (_) =&gt; {
        expect().fail()
      },
      cons: (head,tailThunk) =&gt; {
        expect(head).to.eql(<span class="hljs-number">1</span>)
      }
    });
    expect(
      Maybe.get(Stream.head(flattenedStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(flattenedStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  describe(<span class="hljs-string">"Stream#map"</span>, () =&gt; {
    it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {
      <span class="hljs-comment">/* lazyList = [1,2] */</span>
      <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> doubledLazyList = Stream.map(lazyList)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(doubledLazyList))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledLazyList))))
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      expect(
        Stream.toArray(doubledLazyList)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(ones_infinite_sequence) */</span>
      <span class="hljs-keyword">var</span> ones = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      expect(
        Maybe.get(Stream.head(ones))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(ones))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(ones_infinite_sequence) */</span>
      <span class="hljs-keyword">var</span> twoes = Stream.map(ones)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(twoes))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(Maybe.get(Stream.tail(twoes))))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(from, (_) =&gt; {
          <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
        });
      };
      expect(
        Maybe.get(Stream.head(integersFrom(<span class="hljs-number">0</span>)))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-keyword">var</span> doubledIntergerMapped = Stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(doubledIntergerMapped))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledIntergerMapped))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-keyword">var</span> doubledInterger = Stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> Stream.unit(integer * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(Stream.head(doubledInterger))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledInterger))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> ones = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      <span class="hljs-keyword">var</span> twoes = Stream.flatMap(ones)((one) =&gt; {
        expect(one).to.a(<span class="hljs-string">'number'</span>);
        <span class="hljs-keyword">return</span> Stream.unit(one * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(Stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> nestedNumbers = <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-type">List</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * <span class="hljs-number">2</span>))
res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> innerStream12 = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> innerStream34 = Stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-comment">/* nestedStream = [[1,2],[3,4]] */</span>
      <span class="hljs-keyword">var</span> nestedStream = Stream.cons(innerStream12, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(innerStream34,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> flattenedStream = Stream.flatMap(nestedStream)((innerStream) =&gt; {
        <span class="hljs-keyword">return</span> Stream.flatMap(innerStream)((n) =&gt; {
          expect(n).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> Stream.unit(n * <span class="hljs-number">2</span>);
        });
      });
      expect(
        Maybe.get(Stream.head(flattenedStream))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Stream.toArray(flattenedStream)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
      );
      next();
    });

  });
}); <span class="hljs-comment">// Streamモナド</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h2 id="reader-">Readerモナド</h2>
<h3 id="reader-">Readerモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Reader</span> e a = <span class="hljs-type">Reader</span> <span class="hljs-container">{ <span class="hljs-title">runReader</span> :: <span class="hljs-title">e</span> -&gt; <span class="hljs-title">a</span> }</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Reader</span> <span class="hljs-title">env</span>)</span> <span class="hljs-keyword">where</span></span>
    return a = <span class="hljs-type">Reader</span> $ \_ -&gt; a
    m &gt;&gt;= f  = <span class="hljs-type">Reader</span> $ \env -&gt; runReader (f (runReader m env)) env
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Reader = {
  unit: (x) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; {
        <span class="hljs-keyword">return</span> x;
      }
    };
  },
  flatMap: (reader) =&gt; {
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// transform:: a -&gt; a</span>
      <span class="hljs-keyword">return</span> {
        run: (env) =&gt; {
          <span class="hljs-keyword">return</span> f(reader.run(env)).run(env);
        }
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>runReader :: Reader r a -&gt; r -&gt; a
run: (reader) =&gt; {
  return reader.run();
},
ask = Reader id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ask: (x) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (env) =&gt; {
        <span class="hljs-keyword">return</span> env;
      }
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h3 id="reader-">Readerモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Readerモナドをテストする"</span>,() =&gt; {
  it(<span class="hljs-string">"add10"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">add10</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
<span class="hljs-title">add10</span> = <span class="hljs-keyword">do</span>
  x &lt;- ask                          <span class="hljs-comment">-- 環境変数(x=1)を得る</span>
  y &lt;- local (+<span class="hljs-number">1</span>) add10             <span class="hljs-comment">-- localの使用例, y=12</span>
  s &lt;- reader . length . show $ x   <span class="hljs-comment">-- 返り値は自由である例</span>
 return (x+<span class="hljs-number">10</span>)    
<span class="hljs-title">main</span> = print $ runReader add10 <span class="hljs-number">1</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> add10 = Reader.flatMap(Reader.ask())((x) =&gt; {
      <span class="hljs-keyword">return</span> Reader.unit(x + <span class="hljs-number">10</span>);
    });
    expect(
      add10.run(<span class="hljs-number">1</span>)
    ).to.eql(
      <span class="hljs-number">11</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h2 id="writer-">Writerモナド</h2>
<h3 id="writer-">Writerモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Writer</span> w a = <span class="hljs-type">Writer</span> <span class="hljs-container">{ <span class="hljs-title">run</span> :: (<span class="hljs-title">a</span>,<span class="hljs-title">w</span>) }</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-container">(<span class="hljs-type">Monoid</span> <span class="hljs-title">w</span>)</span> =&gt; <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>)</span> <span class="hljs-keyword">where</span></span>
    return a = <span class="hljs-type">Writer</span> (a, empty)
    (<span class="hljs-type">Writer</span> (a, v)) &gt;&gt;= f  = <span class="hljs-keyword">let</span> (<span class="hljs-type">Writer</span> (b, v')) = f a
                             <span class="hljs-keyword">in</span> <span class="hljs-type">Writer</span> (b, v `append`v')
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Writer = {
  unit: (a) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; {
        <span class="hljs-keyword">return</span> pair.cons(List.empty(),a);
      }
    };
  },
  flatMap: (writer) =&gt; {
    <span class="hljs-keyword">var</span> writerPair = writer.run();
    <span class="hljs-keyword">var</span> v = pair.left(writerPair);
    <span class="hljs-keyword">var</span> a = pair.right(writerPair);
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// transform:: a -&gt; a</span>
      <span class="hljs-keyword">var</span> newPair = f(a).run();
      <span class="hljs-keyword">var</span> v_ = pair.left(newPair);
      <span class="hljs-keyword">var</span> b = pair.right(newPair);
      <span class="hljs-keyword">return</span> {
        run: () =&gt; {
          <span class="hljs-keyword">return</span> pair.cons(List.append(v)(v_),b);
        }
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">tell</span> :: <span class="hljs-type">Monoid</span> w =&gt; w -&gt; <span class="hljs-type">Writer</span> w ()  <span class="hljs-comment">-- tell関数は、値wをもとにログを作成する</span>
<span class="hljs-title">tell</span> s = <span class="hljs-type">Writer</span> ((), s)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  tell: (s) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; {
        <span class="hljs-keyword">return</span> pair.cons(s, List.empty());
      }
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h3 id="writer-">Writerモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Writerモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">factW</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Writer</span> [<span class="hljs-type">Int</span>] <span class="hljs-type">Int</span>
<span class="hljs-title">factW</span> <span class="hljs-number">0</span> = tell [<span class="hljs-number">0</span>] &gt;&gt; return <span class="hljs-number">1</span>
<span class="hljs-title">factW</span> n = <span class="hljs-keyword">do</span>
  tell [n]
  n1 &lt;- factW (pred n)
  return $ n * n1
</code></pre>
<p>実行する場合はrunWriter</p>
<pre><code class="lang-haskell">*<span class="hljs-type">Main</span>&gt; runWriter $ factW <span class="hljs-number">5</span>
(<span class="hljs-number">120</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"factorial"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> pred = (n) =&gt; {
      <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
    };
    <span class="hljs-keyword">var</span> factorial = (n) =&gt; {
      <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> Writer.flatMap(Writer.tell(List.unit(<span class="hljs-number">0</span>)))((_) =&gt; {
          <span class="hljs-keyword">return</span> Writer.unit(<span class="hljs-number">1</span>);
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> Writer.flatMap(Writer.tell(List.unit(n)))((_) =&gt; {
          <span class="hljs-keyword">return</span> Writer.flatMap(factorial(pred(n)))((n1) =&gt; {
            <span class="hljs-keyword">return</span> Writer.unit(n * n1);
          });
        });
      }
    };
    pair.match(factorial(<span class="hljs-number">0</span>).run(),{
      cons: (left, right) =&gt; {
        expect(
          List.toArray(left)
        ).to.eql(
          [<span class="hljs-number">0</span>]
        );
        expect(
          right
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      }
    });
    pair.match(factorial(<span class="hljs-number">5</span>).run(),{
      cons: (left, right) =&gt; {
        expect(
          List.toArray(left)
        ).to.eql(
          [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]
        );
        expect(
          right
        ).to.eql(
          <span class="hljs-number">120</span>
        );
      }
    });
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h2 id="io-">IOモナド</h2>
<h3 id="io-">IOモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> IO = {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>unit:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit : (any) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界は明示する必要はありません</span>
      <span class="hljs-keyword">return</span> any;
    };
  },
  <span class="hljs-comment">/* flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U] */</span>
  flatMap : (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
      <span class="hljs-keyword">return</span> IO.unit(IO.run(actionAB(IO.run(instanceA))));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>IO.done関数</p>
<blockquote>
<p>IOアクションを何も実行しない</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
  done : (any) =&gt; {
    <span class="hljs-keyword">return</span> IO.unit();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>IO.run関数</p>
<blockquote>
<p>IOアクションを実行する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* run:: IO[A] =&gt; A */</span>
  run : (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> instanceM();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>readFile:: STRING =&gt; IO[STRING]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  readFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
      <span class="hljs-keyword">return</span> IO.unit(content)(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>println:: STRING =&gt; IO[null]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  println : (message) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-built_in">console</span>.log(message);
      <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
    };
  },
  writeFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (content) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        fs.writeFileSync(path,content);
        <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  seq: (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (instanceB) =&gt; {
      <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
        <span class="hljs-keyword">return</span> instanceB;
      });
    };
  },
  seqs: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(alist)(List.empty())(IO.done());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>IO.putc:: CHAR =&gt; IO[]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  putc: (character) =&gt; {
    <span class="hljs-keyword">return</span> (io) =&gt; {
      process.stdout.write(character);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>IO.puts:: LIST[CHAR] =&gt; IO[]</p>
<pre><code class="lang-haskell"><span class="hljs-title">puts</span> list = seqs (map putc list)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  puts: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: () =&gt; {
        <span class="hljs-keyword">return</span> IO.done();
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>IO.getc :: IO[CHAR]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getc: () =&gt; {
    <span class="hljs-keyword">var</span> continuation = () =&gt; {
      <span class="hljs-keyword">var</span> chunk = process.stdin.read();
      <span class="hljs-keyword">return</span> chunk;
    }; 
    process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
  }
};

describe(<span class="hljs-string">"IOモナドをテストする"</span>,() =&gt; {
});



describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
  it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
    );
    next();
  });
  it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.empty());
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(1),
                          list.empty());
  // var justList = list.map(theList)(maybe.unit);
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
});</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h2 id="st-">STモナド</h2>
<h3 id="st-">STモナドの定義</h3>
<p>Programming in Haskell(2版),p.168..p.172 を参照。</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">ST</span> a = <span class="hljs-type">S</span><span class="hljs-container">(<span class="hljs-type">State</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-type">State</span>)</span>)</span>

<span class="hljs-title">app</span> :: <span class="hljs-type">ST</span> a -&gt; <span class="hljs-type">State</span> -&gt; (a,<span class="hljs-type">State</span>)
<span class="hljs-title">app</span> (<span class="hljs-type">S</span> st) x = st x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">ST</span> <span class="hljs-keyword">where</span></span>
  <span class="hljs-comment">-- (&gt;&gt;=) :: ST a -&gt; (a -&gt; ST b) -&gt; ST b</span>
  st &gt;&gt;= f = <span class="hljs-type">S</span>(\state -&gt; 
                  <span class="hljs-keyword">let</span> (x, state') = app st state 
                  <span class="hljs-keyword">in</span> app (f x) state'
              )
  unit :: a -&gt; <span class="hljs-type">ST</span> a
  unit x = <span class="hljs-type">S</span>(\s -&gt; (x,s))
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ST = {
  unit: (value) =&gt; { 
    <span class="hljs-keyword">return</span> (state) =&gt; { 
      <span class="hljs-keyword">return</span> pair.cons(value,state);
    };
  },
  app: (st) =&gt; {
    <span class="hljs-keyword">return</span> (state) =&gt; {
      <span class="hljs-keyword">return</span> st(state);
    };
  },
  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// f:: ST a</span>
      expect(f).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> (state) =&gt; {
        <span class="hljs-keyword">var</span> newState = ST.app(instanceM)(state);
        <span class="hljs-keyword">return</span> pair.match(newState,{
          cons:(x, state_) =&gt; {
            <span class="hljs-keyword">return</span> ST.app(f(x))(state_);
          }
        });
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <pre><code class="lang-haskell">(&lt;*&gt;) :: <span class="hljs-type">ST</span>(a -&gt; b) -&gt; <span class="hljs-type">ST</span> a -&gt; <span class="hljs-type">ST</span> b
<span class="hljs-title">stf</span> &lt;*&gt; stx = <span class="hljs-type">S</span>(\s -&gt;
  <span class="hljs-keyword">let</span> (f,s') = app stf s
      (x,s'') = app stx s' 
  <span class="hljs-keyword">in</span> (f x, s'')
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  fresh: (state) =&gt; {
    <span class="hljs-keyword">return</span> pair.cons(state, state + <span class="hljs-number">1</span>);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h3 id="st-">STモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"STモナドをテストする"</span>,() =&gt; {
  describe(<span class="hljs-string">"Treeの例"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Node</span> <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span></span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> Tree = {
      match: (data, pattern) =&gt; {
       <span class="hljs-keyword">return</span> data.call(data, pattern);
      },
      leaf: (value) =&gt; {
         <span class="hljs-keyword">return</span> (pattern) =&gt; {
           <span class="hljs-keyword">return</span> pattern.leaf(value);
         };
      },
      node: (left, right) =&gt; {
         <span class="hljs-keyword">return</span> (pattern) =&gt; {
           <span class="hljs-keyword">return</span> pattern.node(left, right);
         };
      },
      toArray: (tree) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(value) =&gt; {
            <span class="hljs-keyword">return</span> value;
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">return</span> [Tree.toArray(left), Tree.toArray(right)];
          }
        });
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">fmap</span> f (<span class="hljs-type">Leaf</span> x) = <span class="hljs-type">Leaf</span> (f x)
<span class="hljs-title">fmap</span> f (<span class="hljs-type">Node</span> left right) = <span class="hljs-type">Node</span> (fmap f left) (fmap f right)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      map: (f) =&gt; {
        <span class="hljs-keyword">return</span> (tree) =&gt; {
          <span class="hljs-keyword">return</span> Tree.match(tree,{
            leaf:(value) =&gt; {
              <span class="hljs-keyword">return</span> Tree.leaf(f(value));
            },
            node:(left, right) =&gt; {
              <span class="hljs-keyword">return</span> Tree.node(Tree.map(f)(left),Tree.map(f)(right) );
            }
          });
        };
      },
      fresh: (state) =&gt; {
        <span class="hljs-keyword">return</span> pair.cons(state, state + <span class="hljs-number">1</span>);
      }
    };
    it(<span class="hljs-string">'Tree.toArray'</span>, (next) =&gt; {
      expect(
        Tree.toArray(Tree.leaf(<span class="hljs-number">1</span>))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        Tree.toArray(Tree.node(Tree.leaf(<span class="hljs-number">1</span>),Tree.leaf(<span class="hljs-number">2</span>)))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
      );
      expect(
        Tree.toArray(Tree.node(Tree.leaf(<span class="hljs-number">1</span>),
                               Tree.node(Tree.leaf(<span class="hljs-number">2</span>),Tree.leaf(<span class="hljs-number">3</span>))))
      ).to.eql(
        [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
      );
      next();
    });
    it(<span class="hljs-string">'rlabel'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">rlabel</span> :: (<span class="hljs-type">TREE</span>, <span class="hljs-type">STATE</span>) -&gt; (<span class="hljs-type">TREE</span>,<span class="hljs-type">STATE</span>)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> rlabel = (tree, state) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(value) =&gt; {
            <span class="hljs-keyword">return</span> pair.cons(Tree.leaf(state), state + <span class="hljs-number">1</span>);
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">var</span> leftNode = rlabel(left, state);
            <span class="hljs-keyword">var</span> rightNode = rlabel(right, pair.right(leftNode));
            <span class="hljs-keyword">return</span> pair.cons(Tree.node(pair.left(leftNode), 
                                       pair.left(rightNode)), 
                             pair.right(rightNode));
          }
        });
      };
      expect(
        Tree.toArray(pair.left(rlabel(Tree.leaf(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>)))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Tree.toArray(pair.left(rlabel(Tree.node(Tree.leaf(<span class="hljs-string">"a"</span>),Tree.leaf(<span class="hljs-string">"b"</span>)),<span class="hljs-number">0</span>)))
      ).to.eql(
        [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
      );
      next();
    });
    it(<span class="hljs-string">'mlabel'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> fresh = (state) =&gt; {
        <span class="hljs-keyword">return</span> pair.cons(state, state + <span class="hljs-number">1</span>);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">mlabel</span> :: <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">ST</span>(<span class="hljs-type">Tree</span> <span class="hljs-type">Int</span>)
<span class="hljs-title">mlabel</span> (<span class="hljs-type">Leaf</span> _) = <span class="hljs-keyword">do</span> n &lt;- fresh
                     return (<span class="hljs-type">Leaf</span> n)
<span class="hljs-title">mlabel</span> (<span class="hljs-type">Node</span> left right) = <span class="hljs-keyword">do</span> left' &lt;- mlabel left
                              right' &lt;- mlabel right
                              return (<span class="hljs-type">Node</span> left' right')
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> mlabel = (tree) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(_) =&gt; {
            <span class="hljs-keyword">return</span> ST.flatMap(fresh)((n) =&gt; {
              <span class="hljs-keyword">return</span> ST.unit(Tree.leaf(n));
            });
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">return</span> ST.flatMap(mlabel(left))((left_) =&gt; {
              <span class="hljs-keyword">return</span> ST.flatMap(mlabel(right))((right_) =&gt; {
                <span class="hljs-keyword">return</span> ST.unit(Tree.node(left_, right_));
              });
            });
          }
        });
      }; 
      expect(
        Tree.toArray(
          pair.left(ST.app(mlabel(Tree.leaf(<span class="hljs-number">1</span>)))(<span class="hljs-number">0</span>))
        )
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Tree.toArray(
          pair.left(ST.app(mlabel(Tree.node(Tree.leaf(<span class="hljs-string">"a"</span>),Tree.leaf(<span class="hljs-string">"b"</span>))))(<span class="hljs-number">0</span>))
        )
      ).to.eql(
        [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
      );
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p><a href="index.html">目次に戻る</a> </p>

            </div>
            
        </li>
        
    </ul>
  <!-- <div id="footer">  目次に戻る。 </div> -->
  <!-- </div> -->
</body>
</html>
