<!DOCTYPE html>

<html>
<head>
  <title>monad.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <!-- <script type="text/x-mathjax-config"> -->
  <!--   MathJax.Hub.Config({ -->
  <!--   tex2jax: { -->
  <!--       inlineMath: [ ['$','$'], ['\\(','\\)'] ], -->
  <!--       displayMath: [ ['$$','$$'], ["\\[","\\]"] ], -->
  <!--       processEscapes: true -->
  <!--   } -->
  <!--   }); -->
  <!-- </script> -->
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>monad.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-">さまざまなモナド</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>ここでは、本書で紹介できなかったさまざまなモナドを紹介します。
参考までに、Haskellでの定義も随時併記しています。</p>
<p>なお、本ページのコードは、書籍で採用された node.js 0.12版では動作しません。
できるだけ新しいバージョンのnode.jsで実行してください。
当方の環境では、v8.11.1でテストが成功することを確認しています。</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="-">小目次</h2>
<div class="toc">
<ul class="toc">
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#id_monad"> 恒等モナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#maybe_monad"> Maybeモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#either_monad"> Eitherモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#list_monad"> Listモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#stream_monad"> Streamモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#reader_monad"> Readerモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#writer_monad"> Writerモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#io_monad"> IOモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#st_monad"> STモナド</a></li>
  <li><a href="http://akimichi.github.io/functionaljs/monad.spec.html#cont_monad"> Contモナド</a></li>
</ul>
</div>

            </div>
            
            <div class="content"><div class='highlight'><pre>

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Pair型の読込</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Pair = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/pair.js'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>String型の読込</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> <span class="hljs-built_in">String</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/string.js'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="-section-id-id_monad-section-"><section id='id_monad'>恒等モナド</section></h2>
<h3 id="-">恒等モナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ID = {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><strong>ID#unit</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* unit:: T =&gt; ID[T] */</span>
  unit: (value) =&gt; {  <span class="hljs-comment">// 単なる identity関数と同じ</span>
    <span class="hljs-keyword">return</span> value;
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><strong>ID#flatMap</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* flatMap:: ID[T] =&gt; FUN[T =&gt; ID[T]] =&gt; ID[T] */</span>
  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> transform(instanceM); <span class="hljs-comment">// 単なる関数適用と同じ</span>
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3 id="-">恒等モナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"恒等モナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><strong>ID#unit</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"ID#unitをテストする"</span>, (next) =&gt; {
    expect(
      ID.unit(<span class="hljs-number">1</span>)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2 id="-section-id-maybe_monad-maybe-section-"><section id='maybe_monad'>Maybeモナド</section></h2>
<h3 id="maybe-">Maybeモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>
  <span class="hljs-type">Nothing</span>  &gt;&gt;= _ = <span class="hljs-type">Nothing</span>
  (<span class="hljs-type">Just</span> x) &gt;&gt;= f = f x
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Maybe = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data(pattern);
  },
  just : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.just(value);
    };
  },
  nothing : (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.nothing(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><strong>Maybe#unit</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.just(value);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><strong>Maybe#flatMap</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><strong>Maybe#map</strong></p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>
   fmap _ <span class="hljs-type">Nothing</span> = <span class="hljs-type">Nothing</span>
   fmap f (<span class="hljs-type">Just</span> x) = <span class="hljs-type">Just</span> (f x)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        },
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.just(transform(value));
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-comment">-- | Promote a function to a monad.</span>
<span class="hljs-title">liftM</span> :: (<span class="hljs-type">Monad</span> m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
<span class="hljs-title">liftM</span> f m  = <span class="hljs-keyword">do</span> { x &lt;- m1; return (f x) }
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  liftM: (f) =&gt; {
    <span class="hljs-keyword">return</span> (ma) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(ma)((x) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.unit(f(x));
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <pre><code class="lang-haskell">(&lt;*&gt;) :: (<span class="hljs-type">Monad</span> m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  apply: (mf) =&gt; {
    <span class="hljs-keyword">return</span> (ma) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(mf)((f) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.flatMap(ma)((a) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.unit(f(a));
        });
      });
    }; 
  },
  get: (maybe) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.getOrElse(maybe)(<span class="hljs-literal">null</span>);
  },
  getOrElse: (instance) =&gt; {
    <span class="hljs-keyword">return</span> (alternate) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.match(instance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> value;
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> alternate;
        }
      });
    };
  },
  isEqual : (maybeA) =&gt; {
    <span class="hljs-keyword">return</span> (maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.match(maybeA,{
        just: (valueA) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (valueB) =&gt; {
              <span class="hljs-keyword">return</span> (valueA === valueB);
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });
        }
      });
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h3 id="maybe-">Maybeモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Maybeモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><strong>Maybe#flatMap</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"Maybe#flatMapをテストする"</span>, (next) =&gt; {
    Maybe.match(Maybe.flatMap(Maybe.just(<span class="hljs-number">1</span>))((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      },
      nothing: (_) =&gt; {
       expect().fail();
      }
    });
    Maybe.match(Maybe.flatMap(Maybe.nothing())((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
       expect().fail();
      },
      nothing: (_) =&gt; {
       expect(<span class="hljs-literal">true</span>).to.be.ok();
      }
    });
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><strong>Maybe#map</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"Maybe#mapをテストする"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> succ = (n) =&gt; { <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;};</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <pre><code class="lang-haskell">&gt; fmap (+<span class="hljs-number">1</span>) nothing
<span class="hljs-type">Nothing</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(
      Maybe.isEqual(
        Maybe.map(Maybe.nothing())(succ)
      )(
        Maybe.nothing()
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <pre><code class="lang-haskell">&gt; fmap (succ) (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>)
<span class="hljs-type">Just</span> <span class="hljs-number">2</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(
      Maybe.isEqual(
        Maybe.map(Maybe.just(<span class="hljs-number">1</span>))(succ)
      )(
        Maybe.just(<span class="hljs-number">2</span>)
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><strong>Maybe#liftM</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"Maybe#liftMをテストする"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <pre><code class="lang-haskell">&gt; liftM (+<span class="hljs-number">3</span>) (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>)
<span class="hljs-type">Just</span> <span class="hljs-number">5</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> add3 = (n) =&gt; {
      <span class="hljs-keyword">return</span> n + <span class="hljs-number">3</span>;
    };
    <span class="hljs-keyword">var</span> justTwo = Maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justFive = Maybe.just(<span class="hljs-number">5</span>);
    expect(
      Maybe.isEqual(
        Maybe.liftM(add3)(Maybe.unit(<span class="hljs-number">2</span>)) 
      )(
        justFive
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><strong>Maybe#apply</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"Maybe#applyをテストする"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <pre><code class="lang-haskell">&gt; <span class="hljs-type">Just</span> (+<span class="hljs-number">3</span>) &lt;*&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>)
<span class="hljs-type">Just</span> <span class="hljs-number">5</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> add3 = (n) =&gt; {
      <span class="hljs-keyword">return</span> n + <span class="hljs-number">3</span>;
    };
    <span class="hljs-keyword">var</span> justTwo = Maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justFive = Maybe.just(<span class="hljs-number">5</span>);
    expect(
      Maybe.isEqual(
        Maybe.apply(Maybe.just(add3))(Maybe.unit(<span class="hljs-number">2</span>)) 
      )(
        justFive
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>add関数でMaybeインスンスを足しあわせる</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"add関数でMaybeインスンスを足しあわせる"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeA)((a) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.flatMap(maybeB)((b) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.unit(a + b);
        });
      });
    };
    <span class="hljs-keyword">var</span> justOne = Maybe.just(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> justTwo = Maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justThree = Maybe.just(<span class="hljs-number">3</span>);
    expect(
      Maybe.isEqual(
        add(justOne,justTwo)
      )(
        justThree
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      Maybe.isEqual(
        add(justOne,Maybe.nothing())
      )(
        Maybe.nothing()
      )
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h2 id="-section-id-either_monad-either-section-"><section id='either_monad'>Eitherモナド</section></h2>
<h3 id="either-">Eitherモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Either  = {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span>  <span class="hljs-type">Either</span> a b  =  <span class="hljs-type">Left</span> a | <span class="hljs-type">Right</span> b</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(data,pattern);
  },
  left : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.left(value);
    };
  },
  right : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.right(value);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Either</span> <span class="hljs-title">a</span> <span class="hljs-title">b</span>)</span> <span class="hljs-keyword">where</span></span>
  return x = <span class="hljs-type">Right</span> x
  <span class="hljs-type">Right</span> x &gt;&gt;= f = f x
  <span class="hljs-type">Left</span> x &gt;&gt;= <span class="hljs-type">Left</span> x
</code></pre>
<p><strong>Either#unit</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> Either.right(value);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><strong>Either#flatMap</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap : (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Either.match(instanceM,{
        right: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        left: (value) =&gt; {
          <span class="hljs-keyword">return</span> Either.left(value);
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong>Either#map</strong></p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-container">(<span class="hljs-type">Either</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Right</span> x) = <span class="hljs-type">Right</span> (f x)
  fmap f (<span class="hljs-type">Left</span> x) = <span class="hljs-type">Left</span> x
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> Either.match(instanceM,{
        right: (value) =&gt; {
          <span class="hljs-keyword">return</span> Either.right(transform(value));
        },
        left: (value) =&gt; {
          <span class="hljs-keyword">return</span> Either.left(value);
        }
      });
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3 id="either-">Eitherモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Eitherモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>数値のときだけ計算が成功するテスト</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"数値のときだけ計算が成功するテスト"</span>, (next) =&gt; {
    Either.match(Either.flatMap(Either.left(<span class="hljs-string">"wrong"</span>))((n) =&gt; {
      <span class="hljs-keyword">return</span> Either.unit(n + <span class="hljs-number">1</span>);
    }),{
      right: (value) =&gt; {
        expect().fail();
      },
      left: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-string">"wrong"</span>
        );
      }
    });
    Either.match(Either.flatMap(Either.unit(<span class="hljs-number">2</span>))((n) =&gt; {
      <span class="hljs-keyword">return</span> Either.unit(n + <span class="hljs-number">1</span>);
    }),{
      right: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-number">3</span>
        );
      },
      left: (value) =&gt; {
        expect().fail();
      }
    });
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h2 id="-section-id-list_monad-list-section-"><section id='list_monad'>Listモナド</section></h2>
<h3 id="list-">Listモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> [] <span class="hljs-keyword">where</span></span>
  xs &gt;&gt;= f = concat (map f xs)
  return x = [x]
  fail s   = []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> List  = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(List,pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><strong>List#append</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">append</span> [] ys = ys
<span class="hljs-title">append</span> (x:xs) ys = x : (xs ++ ys)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T] */</span>
  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> List.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(head,List.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><strong>List#concat</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">concat</span> [] = []
<span class="hljs-title">concat</span> (xs:xss) = xs ++ concat xss
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* concat:: LIST[LIST[T]] -&gt; LIST[T] */</span>
  concat: (xss) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(xss)(List.empty())(List.append);
  },
  join: (xss) =&gt; {
    <span class="hljs-keyword">return</span> List.concat(xss);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p><strong>List#flatten</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">flatten</span> :: [[a]] -&gt; [a]
<span class="hljs-title">flatten</span> =  foldr (++) []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (instanceMM) =&gt; {
    <span class="hljs-keyword">return</span> List.concat(instanceMM);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p><strong>List#map</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">map</span> [] _ = []
<span class="hljs-title">map</span> (x:xs) f = f x : map xs f
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* map:: LIST[T] -&gt; FUN[T-&gt;U] -&gt; LIST[U] */</span>
  map: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> List.match(instanceM,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> List.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(transform(head),
                           List.map(tail)(transform));
        }
      });
    };
  },
  unit: (value) =&gt; {
    <span class="hljs-keyword">return</span> List.cons(value, List.empty());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><strong>List#flatMap</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">xs</span> &gt;&gt;= f = concat (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; { <span class="hljs-comment">// FUN[T-&gt;LIST[T]]</span>
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> List.join(List.map(instanceM)(transform));
    };
  },
  <span class="hljs-comment">/* 1段階のリストしか配列に変更できない */</span>
  toArray: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(alist)([])((item) =&gt; {
      <span class="hljs-keyword">return</span> (accumulator) =&gt; {
        <span class="hljs-keyword">return</span> [item].concat(accumulator);
      };
    });
  },
  fromArray: (array) =&gt; {
    <span class="hljs-keyword">return</span> array.reduce((accumulator, item) =&gt; {
      <span class="hljs-keyword">return</span> List.append(accumulator)(List.cons(item, List.empty()));
    }, List.empty());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><strong>List#foldr</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">foldr</span> []     z _ = z
<span class="hljs-title">foldr</span> (x:xs) z f = f x (foldr xs z f)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* foldr:: LIST[T] -&gt; T -&gt; FUN[T -&gt; U -&gt; U] -&gt; T */</span>
  foldr: (alist) =&gt; {         <span class="hljs-comment">// alist:: LIST[T]</span>
    <span class="hljs-keyword">return</span> (accumulator) =&gt; { <span class="hljs-comment">// accumulator:: T</span>
      <span class="hljs-keyword">return</span> (glue) =&gt; {      <span class="hljs-comment">// glue:: FUN[T -&gt; U -&gt; U] </span>
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> List.match(alist, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(List.foldr(tail)(accumulator)(glue));;
          }
        });
      };
    };
  }
}; <span class="hljs-comment">// end of list monad</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h3 id="list-">Listモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Listモナドのテスト'</span>, () =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p><strong>List#match</strong>でリストをパターンマッチする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'List.matchでリストをパターンマッチする'</span>, () =&gt; {
    it(<span class="hljs-string">"matchでList#emptyをマッチさせる"</span>, (next) =&gt; {
      List.match(List.empty,{
        empty: (_) =&gt; {
          expect(<span class="hljs-literal">true</span>).ok();
        },
        cons: (x,xs) =&gt; {
          expect().fail();
        }
      });
      next();
    });
    it(<span class="hljs-string">"matchでList#consをマッチさせる"</span>, (next) =&gt; {
      List.match(List.cons(<span class="hljs-number">1</span>,List.empty()),{
        empty: (_) =&gt; {
          expect().fail();
        },
        cons: (x,xs) =&gt; {
          expect(x).to.eql(<span class="hljs-number">1</span>);
        }
      });
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p><strong>List#isEmpty</strong>は、リストが空かどうかを判定する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"List#isEmptyは、リストが空かどうかを判定する"</span>, (next) =&gt; {
    expect(
      List.isEmpty(List.empty())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      List.isEmpty(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#head'"</span>, (next) =&gt; {
    expect(
      List.head(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#tail'"</span>, (next) =&gt; {
    expect(
      List.head(List.tail(List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#append'"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.append(List.cons(<span class="hljs-number">1</span>,List.empty()))(List.cons(<span class="hljs-number">2</span>,List.empty()));
    expect(
      List.head(theList)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(theList))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(theList)))
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p><strong>List#concat</strong>で２つのリストを連結する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"List#concatで２つのリストを連結する"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> one_two = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
    <span class="hljs-keyword">var</span> three_four = List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()));

    <span class="hljs-comment">/* list_of_list = [[1,2],[3,4]] */</span>
    <span class="hljs-keyword">var</span> list_of_list = List.cons(one_two,
                                 List.cons(three_four, List.empty()));
    <span class="hljs-comment">/* concated_list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> concated_list = List.concat(list_of_list);
    expect(
      List.toArray(concated_list)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    expect(
      List.head(concated_list)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(concated_list))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(concated_list)))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><strong>List#foldr</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"List#foldrをテストする"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.foldr(theList)(<span class="hljs-number">0</span>)((item) =&gt; {
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> accumulator + item;
        };
      })
    ).to.eql(
      <span class="hljs-number">10</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p><strong>List#map</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"List#mapをテストする"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.toArray(List.map(theList)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      }))
    ).to.eql(
      [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
    );
    next();
  });
  it(<span class="hljs-string">"List#unit"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1] */</span>
    expect(
      List.toArray(List.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    expect(
      List.toArray(List.unit(<span class="hljs-literal">null</span>))
    ).to.eql(
      [<span class="hljs-literal">null</span>]
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p><strong>List#flatMap</strong>をテストする</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">"List#flatMapをテストする"</span>, () =&gt; {
    it(<span class="hljs-string">"'List#flatMap'"</span>, (next) =&gt; {
      <span class="hljs-comment">/* theList = [1,2,3] */</span>
      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>, List.cons(<span class="hljs-number">3</span>, List.empty())));
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.append(List.unit(item))(List.unit(- item));
        }))
      ).to.eql(
        [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
      );
      next();
    });
    it(<span class="hljs-string">"[1]の要素の2倍は、[2]"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-type">Prelude</span>&gt; [<span class="hljs-number">1</span>] &gt;&gt;= \x -&gt; [x * <span class="hljs-number">2</span>]
[<span class="hljs-number">2</span>]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>, List.empty());
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>]
      );
      next();
    });
    it(<span class="hljs-string">"[]の要素の2倍は、[]"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-type">Prelude</span>&gt; [] &gt;&gt;= \x -&gt; [x * <span class="hljs-number">2</span>]
[]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> emptyList = List.empty();
      expect(
        List.toArray(List.flatMap(emptyList)((item) =&gt; {
          <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        []
      );
      next();
    });
    it(<span class="hljs-string">"[1,2]と[1,2]のそれぞれの要素を足して3になる組み合わせを求める"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> list1 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                         List.empty()));
      <span class="hljs-keyword">var</span> list2 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                         List.empty()));
      expect(
        List.toArray(List.flatMap(list1)((item1) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(list2)((item2) =&gt; {
            <span class="hljs-keyword">if</span>(item1 + item2 === <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">return</span> List.unit([item1, item2]);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> List.empty();
            }
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]
      );
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p><strong>List#toArray</strong>でリストを配列に変換する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">"List#toArrayでリストを配列に変換する"</span>, () =&gt; {
    it(<span class="hljs-string">"1段階のリストを配列に変換する"</span>, (next) =&gt; {
      <span class="hljs-comment">/* theList = [1,2,3,4] */</span>
      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
      expect(
        List.toArray(theList)
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のリストを配列に変換する"</span>, (next) =&gt; {
      <span class="hljs-comment">/* nestedList = [[1],[2]] */</span>
      <span class="hljs-keyword">var</span> nestedList = List.cons(List.cons(<span class="hljs-number">1</span>,List.empty()),
                                 List.cons(List.cons(<span class="hljs-number">2</span>,List.empty()),
                                           List.empty()));
      expect(
        List.toArray(List.flatMap(nestedList)((alist) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(alist)((item) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(item);
          });
        }))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
      );
      next();
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p><strong>List#fromArray</strong>で配列をリストに変換する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">"List#toArrayで配列をリストに変換する"</span>, () =&gt; {
    it(<span class="hljs-string">"1段階のリストを配列に変換する"</span>, (next) =&gt; {
      expect(
        List.toArray(
          List.fromArray([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
        )
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
      );
      next();
    });
  });
  describe(<span class="hljs-string">"Listモナドを活用する"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>素数を判定するisPrimeを定義する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"素数を判定するisPrimeを定義する"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> enumFromTo = (x,y) =&gt; {
        <span class="hljs-keyword">if</span>(x &gt; y) {
          <span class="hljs-keyword">return</span> List.empty();
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> List.cons(x, enumFromTo(x+<span class="hljs-number">1</span>,y));
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">factors</span> :: <span class="hljs-type">Int</span> -&gt; [<span class="hljs-type">Int</span>]
<span class="hljs-title">factors</span> n = [x | x &lt;- [<span class="hljs-number">1.</span>.n], n `mod` x == <span class="hljs-number">0</span>]
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> factors = (n) =&gt; {
        <span class="hljs-keyword">return</span> List.flatMap(enumFromTo(<span class="hljs-number">1</span>,n))((x) =&gt; {
          <span class="hljs-keyword">if</span>((n % x) === <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> List.unit(x);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> List.empty(); 
          }
        });
      };
      expect(
        List.toArray(factors(<span class="hljs-number">15</span>))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>]
      );
      expect(
        List.toArray(factors(<span class="hljs-number">7</span>))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">7</span>]
      );</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>isPrime関数</p>
<blockquote>
<p>isPrime(n) で n が素数かどうかを判定します。</p>
<pre><code class="lang-haskell"><span class="hljs-title">isPrime</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">isPrime</span> n = factors n == [<span class="hljs-number">1</span>,n]
</code></pre>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> isPrime = (n) =&gt; {
        <span class="hljs-keyword">return</span> List.toArray(factors(n)) === List.toArray(enumFromTo(<span class="hljs-number">1</span>,n));
      };
      expect(
        isPrime(<span class="hljs-number">15</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      expect(
        isPrime(<span class="hljs-number">13</span>)
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()))));
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">if</span>(even(item)) {
            <span class="hljs-keyword">return</span> List.unit(item);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> List.empty();
          }
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> theNumberList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
      <span class="hljs-keyword">var</span> theStringList = List.cons(<span class="hljs-string">"one"</span>,List.cons(<span class="hljs-string">"two"</span>,List.empty()));
      expect(
        List.toArray(List.flatMap(theNumberList)((n) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(theStringList)((s) =&gt; {
            <span class="hljs-keyword">return</span> List.unit([n,s]);
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
      );
      next();
    });
    describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
      it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.empty());
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        next();
      });
      it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        );
        next();
      });
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <h2 id="-section-id-stream_monad-stream-section-"><section id='stream_monad'>Streamモナド</section></h2>
<h3 id="stream-">Streamモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Stream = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(Stream,pattern);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p><strong>Stream#unit</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* unit:: ANY -&gt; STREAM */</span>
  unit: (value) =&gt; {
    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
      <span class="hljs-keyword">return</span> Stream.cons(value, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> Stream.empty();
    }
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },
  <span class="hljs-comment">/* head:: STREAM -&gt; MAYBE[STREAM] */</span>
  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(value);
      }
    });
  },
  <span class="hljs-comment">/* tail:: STREAM -&gt; MAYBE[STREAM] */</span>
  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(tailThunk());
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p><strong>Stream#toArray</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> [];
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">if</span>(Stream.isEmpty(tailThunk())){
          <span class="hljs-keyword">return</span> [head];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> [head].concat(Stream.toArray(tailThunk()));
        }
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p><strong>Stream#map</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> Stream.match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> Stream.cons(transform(head),(_) =&gt; {
            <span class="hljs-keyword">return</span> Stream.map(tailThunk())(transform)});
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p><strong>Stream#append</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
      <span class="hljs-keyword">return</span> Stream.match(xs,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ysThunk();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> Stream.cons(head,(_) =&gt; {
            <span class="hljs-keyword">return</span> Stream.append(tailThunk())(ysThunk);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p><strong>Stream#concat</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* concat:: STREAM[STREAM[T]] -&gt; STREAM[T] */</span>
  concat: (astream) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(astream,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Stream.append(head,tailThunk());
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p><strong>Stream#flatten</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* flatten :: STREAM[STREAM[T]] =&gt; STREAM[T] */</span>
  flatten: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> Stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Stream.append(head)((_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.flatten(tailThunk());
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p><strong>Stream#flatMap</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T] */</span>
  flatMap: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> Stream.flatten(Stream.map(lazyList)(transform));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p><strong>Stream#foldr</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (accumulator) =&gt; {
      <span class="hljs-keyword">return</span> (glue) =&gt; {
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> Stream.match(instanceM,{
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head,tailThunk) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(Stream.foldr(tailThunk())(accumulator)(glue));
          }
        });
      };
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h3 id="stream-">Streamモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Streamモナドのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">"Stream#unit"</span>, (next) =&gt; {
    Stream.match(Maybe.nothing(<span class="hljs-literal">null</span>),{
      nothing: (_) =&gt; {
        <span class="hljs-keyword">return</span> expect(
          _
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
      },
      just: (value) =&gt; {
        <span class="hljs-keyword">return</span> expect().fail();
      }
    });
    <span class="hljs-keyword">var</span> lazyList = Stream.unit(<span class="hljs-number">1</span>);
    expect(
      Maybe.get(Stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Stream.unit(<span class="hljs-number">1</span>)))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Stream.unit(<span class="hljs-number">0</span>)))
    ).to.eql(
      <span class="hljs-number">0</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#cons"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    expect(
      Maybe.get(Stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#tail"</span>, (next) =&gt; {
    <span class="hljs-comment">/* lazyList = [1,2] */</span>
    <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    expect(
      Stream.tail(lazyList)
    ).to.a(<span class="hljs-string">"function"</span>);

    Stream.match(Stream.tail(lazyList),{
      nothing: (_) =&gt; {
        expect().fail();
      },
      just: (tail) =&gt; {
        Stream.match(tail,{
          empty: (_) =&gt; {
            expect().fail();
          },
          cons: (head, tailThunk) =&gt; {
            expect(head).to.eql(<span class="hljs-number">2</span>);
          }
        });
      }
    });
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(lazyList))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#toArray"</span>, (next) =&gt; {
    expect(
      Stream.toArray(Stream.empty())
    ).to.eql(
      []
    );
    expect(
      Stream.toArray(Stream.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });
  it(<span class="hljs-string">"Stream#append"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> xs = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.empty();
    });
    <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    };
    <span class="hljs-keyword">var</span> theStream = Stream.append(xs)(ysThunk);
    expect(
      Maybe.get(Stream.head(theStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(theStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"Stream#flatten"</span>, (next) =&gt; {
    <span class="hljs-comment">/* innerStream = [1,2] */</span>
    <span class="hljs-keyword">var</span> innerStream = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.empty();
      });
    });
    <span class="hljs-comment">/* outerStream = [[1,2]] */</span>
    <span class="hljs-keyword">var</span> outerStream = Stream.unit(innerStream);
    <span class="hljs-keyword">var</span> flattenedStream = Stream.flatten(outerStream);
    Stream.match(flattenedStream,{
      empty: (_) =&gt; {
        expect().fail()
      },
      cons: (head,tailThunk) =&gt; {
        expect(head).to.eql(<span class="hljs-number">1</span>)
      }
    });
    expect(
      Maybe.get(Stream.head(flattenedStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(Stream.head(Maybe.get(Stream.tail(flattenedStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  describe(<span class="hljs-string">"Stream#map"</span>, () =&gt; {
    it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {
      <span class="hljs-comment">/* lazyList = [1,2] */</span>
      <span class="hljs-keyword">var</span> lazyList = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> doubledLazyList = Stream.map(lazyList)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(doubledLazyList))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledLazyList))))
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      expect(
        Stream.toArray(doubledLazyList)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Streamモナドで無限の整数列を作る</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> ones = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      expect(
        Maybe.get(Stream.head(ones))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(ones))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-keyword">var</span> twoes = Stream.map(ones)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(twoes))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(Maybe.get(Stream.tail(twoes))))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(from, (_) =&gt; {
          <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
        });
      };
      expect(
        Maybe.get(Stream.head(integersFrom(<span class="hljs-number">0</span>)))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-keyword">var</span> doubledIntergerMapped = Stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(Stream.head(doubledIntergerMapped))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledIntergerMapped))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-keyword">var</span> doubledInterger = Stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> Stream.unit(integer * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(Stream.head(doubledInterger))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(Stream.head(Maybe.get(Stream.tail(doubledInterger))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> ones = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      <span class="hljs-keyword">var</span> twoes = Stream.flatMap(ones)((one) =&gt; {
        expect(one).to.a(<span class="hljs-string">'number'</span>);
        <span class="hljs-keyword">return</span> Stream.unit(one * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(Stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <pre><code class="lang-scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">nestedNumbers</span> =</span> <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-type">List</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * <span class="hljs-number">2</span>))
res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> innerStream12 = Stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> innerStream34 = Stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-comment">/* nestedStream = [[1,2],[3,4]] */</span>
      <span class="hljs-keyword">var</span> nestedStream = Stream.cons(innerStream12, (_) =&gt; {
        <span class="hljs-keyword">return</span> Stream.cons(innerStream34,(_) =&gt; {
          <span class="hljs-keyword">return</span> Stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> flattenedStream = Stream.flatMap(nestedStream)((innerStream) =&gt; {
        <span class="hljs-keyword">return</span> Stream.flatMap(innerStream)((n) =&gt; {
          expect(n).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> Stream.unit(n * <span class="hljs-number">2</span>);
        });
      });
      expect(
        Maybe.get(Stream.head(flattenedStream))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Stream.toArray(flattenedStream)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
      );
      next();
    });

  });
}); <span class="hljs-comment">// Streamモナド</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h2 id="-section-id-reader_monad-reader-section-"><section id='reader_monad'>Readerモナド</section></h2>
<p>  c.f. <a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20090303/325807/?rt=nocnt">グローバル変数の代わりに使えるReaderモナドとWriterモナド</a></p>
<h3 id="reader-">Readerモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Reader</span> e a = <span class="hljs-type">Reader</span> <span class="hljs-container">{ <span class="hljs-title">runReader</span> :: <span class="hljs-title">e</span> -&gt; <span class="hljs-title">a</span> }</span></span>
<span class="hljs-class">
<span class="hljs-keyword">class</span> <span class="hljs-type">MonadReader</span> e m | m -&gt; e <span class="hljs-keyword">where</span></span> 
    ask   :: m e
    local :: (e -&gt; e) -&gt; m a -&gt; m a 
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">MonadReader</span> <span class="hljs-container">(<span class="hljs-type">Reader</span> <span class="hljs-title">e</span>)</span> <span class="hljs-keyword">where</span></span> 
    ask       = <span class="hljs-type">Reader</span> id 
    local f c = <span class="hljs-type">Reader</span> $ \e -&gt; runReader c (f e) 
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Reader</span> <span class="hljs-title">env</span>)</span> <span class="hljs-keyword">where</span></span>
    return a = <span class="hljs-type">Reader</span> $ \_ -&gt; a
    m &gt;&gt;= f  = <span class="hljs-type">Reader</span> $ \env -&gt; runReader (f (runReader m env)) env
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Reader = {
  unit: (a) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; { <span class="hljs-comment">// runReader :: Reader r a -&gt; r -&gt; a</span>
        <span class="hljs-keyword">return</span> a;
      }
    };
  },
  flatMap: (reader) =&gt; {
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// transform:: a -&gt; a</span>
      <span class="hljs-keyword">return</span> {
        run: (env) =&gt; {
          <span class="hljs-keyword">return</span> f(reader.run(env)).run(env);
        }
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p><strong>Reader#ask</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">ask</span> :: <span class="hljs-type">Reader</span> r r
<span class="hljs-title">ask</span> = <span class="hljs-type">Reader</span> id
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ask: {
    run: (env) =&gt; {
      <span class="hljs-keyword">return</span> env;
    }
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p><strong>Reader#local</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">local</span> f c = <span class="hljs-type">Reader</span> $ \e -&gt; runReader c (f e)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  local: (f) =&gt; {
    <span class="hljs-keyword">return</span> (reader) =&gt; {
      <span class="hljs-keyword">return</span> {
        run: (env) =&gt; {
          <span class="hljs-keyword">return</span> reader.run(f(env));
        }
      };
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h3 id="reader-">Readerモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Readerモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>localのテスト
c.f. “Real World Haskell”,p.432</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"localのテスト"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> myName = (step) =&gt; {
      <span class="hljs-keyword">return</span> Reader.flatMap(Reader.ask)((name) =&gt; {
        <span class="hljs-keyword">return</span> Reader.unit(step + <span class="hljs-string">", I am "</span> + name);
      });
    };
    <span class="hljs-keyword">var</span> localExample = Reader.flatMap(myName(<span class="hljs-string">"First"</span>))((a) =&gt; {
      <span class="hljs-keyword">var</span> appendDy = (env) =&gt; {
        <span class="hljs-keyword">return</span> env + <span class="hljs-string">"dy"</span>;
      };
      <span class="hljs-keyword">return</span> Reader.flatMap(Reader.local(appendDy)(myName(<span class="hljs-string">"Second"</span>)))((b) =&gt; {
        <span class="hljs-keyword">return</span> Reader.flatMap(myName(<span class="hljs-string">"Third"</span>))((c) =&gt; {
          <span class="hljs-keyword">return</span> Reader.unit(a + <span class="hljs-string">", "</span> + b + <span class="hljs-string">", "</span> + c);
        });
      });
    });
    expect(
      localExample.run(<span class="hljs-string">"Fred"</span>)
    ).to.eql(
      <span class="hljs-string">"First, I am Fred, Second, I am Freddy, Third, I am Fred"</span>
    );
    next();
  });
  it(<span class="hljs-string">"データベースのコネクションを模倣する"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> config = {
      host: <span class="hljs-string">"127.0.0.1"</span>,
      port: <span class="hljs-string">"27017"</span>
    }; 
    <span class="hljs-keyword">var</span> connect = Reader.flatMap(Reader.ask)((config) =&gt; {
      <span class="hljs-keyword">return</span> Reader.unit(config.host + <span class="hljs-string">":"</span> + config.port);
    });
    expect(
      connect.run(config)
    ).to.eql(
      <span class="hljs-string">"127.0.0.1:27017"</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h2 id="-section-id-writer_monad-writer-section-"><section id='writer_monad'>Writerモナド</section></h2>
<p>c.f. <a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20090303/325807/?P=3&amp;rt=nocnt">グローバル変数の代わりに使えるReaderモナドとWriterモナド（3/4）</a></p>
<h3 id="writer-">Writerモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Writer</span> w a = <span class="hljs-type">Writer</span> <span class="hljs-container">{ <span class="hljs-title">run</span> :: (<span class="hljs-title">a</span>,<span class="hljs-title">w</span>) }</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-container">(<span class="hljs-type">Monoid</span> <span class="hljs-title">w</span>)</span> =&gt; <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>)</span> <span class="hljs-keyword">where</span></span>
    return a = <span class="hljs-type">Writer</span> (a, empty)
    (<span class="hljs-type">Writer</span> (a, v)) &gt;&gt;= f  = <span class="hljs-keyword">let</span> (<span class="hljs-type">Writer</span> (b, v')) = f a
                             <span class="hljs-keyword">in</span> <span class="hljs-type">Writer</span> (b, v `append`v')
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Writer = {
  unit: (a) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; {
        <span class="hljs-keyword">return</span> Pair.cons(List.empty(),a);
      }
    };
  },
  flatMap: (writer) =&gt; {
    <span class="hljs-keyword">var</span> writerPair = writer.run();
    <span class="hljs-keyword">var</span> v = Pair.left(writerPair);
    <span class="hljs-keyword">var</span> a = Pair.right(writerPair);
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// transform:: a -&gt; a</span>
      <span class="hljs-keyword">var</span> newPair = f(a).run();
      <span class="hljs-keyword">var</span> v_ = Pair.left(newPair);
      <span class="hljs-keyword">var</span> b = Pair.right(newPair);
      <span class="hljs-keyword">return</span> {
        run: () =&gt; {
          <span class="hljs-keyword">return</span> Pair.cons(List.append(v)(v_),b);
        }
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">tell</span> :: <span class="hljs-type">Monoid</span> w =&gt; w -&gt; <span class="hljs-type">Writer</span> w ()  <span class="hljs-comment">-- tell関数は、値wをもとにログを作成する</span>
<span class="hljs-title">tell</span> s = <span class="hljs-type">Writer</span> ((), s)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  tell: (s) =&gt; {
    <span class="hljs-keyword">return</span> {
      run: (_) =&gt; {
        <span class="hljs-keyword">return</span> Pair.cons(s, List.empty());
      }
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <h3 id="writer-">Writerモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Writerモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Writerモナドを用いたfactorialの例</p>
<pre><code class="lang-haskell"><span class="hljs-title">factW</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Writer</span> [<span class="hljs-type">Int</span>] <span class="hljs-type">Int</span>
<span class="hljs-title">factW</span> <span class="hljs-number">0</span> = tell [<span class="hljs-number">0</span>] &gt;&gt; return <span class="hljs-number">1</span>
<span class="hljs-title">factW</span> n = <span class="hljs-keyword">do</span>
  tell [n]
  n1 &lt;- factW (pred n)
  return $ n * n1
</code></pre>
<p>実行する場合はrunWriter</p>
<pre><code class="lang-haskell">*<span class="hljs-type">Main</span>&gt; runWriter $ factW <span class="hljs-number">5</span>
(<span class="hljs-number">120</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">"Writerモナドを用いたfactorialの例"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> pred = (n) =&gt; {
      <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;
    };
    <span class="hljs-keyword">var</span> factorial = (n) =&gt; {
      <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> Writer.flatMap(Writer.tell(List.unit(<span class="hljs-number">0</span>)))((_) =&gt; {
          <span class="hljs-keyword">return</span> Writer.unit(<span class="hljs-number">1</span>);
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> Writer.flatMap(Writer.tell(List.unit(n)))((_) =&gt; {
          <span class="hljs-keyword">return</span> Writer.flatMap(factorial(pred(n)))((n1) =&gt; {
            <span class="hljs-keyword">return</span> Writer.unit(n * n1);
          });
        });
      }
    };
    factorial(<span class="hljs-number">0</span>).run().match({
      cons: (left, right) =&gt; {
        expect(
          List.toArray(left)
        ).to.eql(
          [<span class="hljs-number">0</span>]
        );
        expect(
          right
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      }
    });
    factorial(<span class="hljs-number">5</span>).run().match({
      cons: (left, right) =&gt; {
        expect(
          List.toArray(left)
        ).to.eql(
          [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]
        );
        expect(
          right
        ).to.eql(
          <span class="hljs-number">120</span>
        );
      }
    });
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <h2 id="-section-id-io_monad-io-section-"><section id='io_monad'>IOモナド</section></h2>
<h3 id="io-">IOモナドの定義</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> IO = {
  <span class="hljs-comment">/* unit:: T =&gt; IO[T] */</span>
  unit : (any) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界は明示する必要はありません</span>
      <span class="hljs-keyword">return</span> any;
    };
  },
  <span class="hljs-comment">/* flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U] */</span>
  flatMap : (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
      <span class="hljs-keyword">return</span> IO.unit(IO.run(actionAB(IO.run(instanceA))));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p><strong>IO#done</strong>関数</p>
<blockquote>
<p>IOアクションを何も実行しない</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
  done : (any) =&gt; {
    <span class="hljs-keyword">return</span> IO.unit();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p><strong>IO#run</strong>関数</p>
<blockquote>
<p>IOアクションを実行する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* run:: IO[A] =&gt; A */</span>
  run : (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> instanceM();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><strong>IO#readFile</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* readFile:: STRING =&gt; IO[STRING] */</span>
  readFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
      <span class="hljs-keyword">return</span> IO.unit(content)(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p><strong>IO#println</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* println:: STRING =&gt; IO[null] */</span>
  println : (message) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-built_in">console</span>.log(message);
      <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p><strong>IO#writeFile</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  writeFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (content) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        fs.writeFileSync(path,content);
        <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p><strong>IO#seq</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b] */</span>
  seq: (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (instanceB) =&gt; {
      <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
        <span class="hljs-keyword">return</span> instanceB;
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">sequence_</span>        :: [<span class="hljs-type">IO</span> ()] -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">sequence_</span> []     =  return ()
<span class="hljs-title">sequence_</span> (a:<span class="hljs-keyword">as</span>) =  <span class="hljs-keyword">do</span> a
                       sequence <span class="hljs-keyword">as</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  seqs: (alist) =&gt; {
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> alist.match({
      empty: () =&gt; {
        <span class="hljs-keyword">return</span> self.done();
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> self.flatMap(head)((_) =&gt; {
          <span class="hljs-keyword">return</span> self.seqs(tail); 
        }); 
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p><strong>IO#putc</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* IO.putc:: CHAR =&gt; IO[] */</span>
  putc: (character) =&gt; {
    <span class="hljs-keyword">return</span> (io) =&gt; {
      process.stdout.write(character);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p><strong>IO#puts</strong></p>
<pre><code class="lang-haskell"><span class="hljs-title">puts</span> list = seqs (map putc list)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* IO.puts:: LIST[CHAR] =&gt; IO[] */</span>
  puts: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: () =&gt; {
        <span class="hljs-keyword">return</span> IO.done();
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p><strong>IO#getc</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* IO.getc :: IO[CHAR] */</span>
  getc: () =&gt; {
    <span class="hljs-keyword">var</span> continuation = () =&gt; {
      <span class="hljs-keyword">var</span> chunk = process.stdin.read();
      <span class="hljs-keyword">return</span> chunk;
    }; 
    process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h3 id="io-">IOモナドをテストする</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"IOモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>IOモナドで参照透過性を確保する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'IOモナドで参照透過性を確保する'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>本文では割愛しましたが、IOモナドが入出力に対して参照透過性を確保していることを単体テストで示します。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(
      IO.flatMap(IO.readFile(<span class="hljs-string">"./test/resources/file.txt"</span>))((content) =&gt; {
        <span class="hljs-keyword">return</span> IO.flatMap(IO.println(content))((_) =&gt; {
          <span class="hljs-keyword">return</span> IO.done(_);
        });
      })()
    ).to.eql(
      IO.flatMap(IO.readFile(<span class="hljs-string">"./test/resources/file.txt"</span>))((content) =&gt; {
        <span class="hljs-keyword">return</span> IO.flatMap(IO.println(content))((_) =&gt; {
          <span class="hljs-keyword">return</span> IO.done(_);
        });
      })()
    );
    next();
  });
});



describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
  it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
    );
    next();
  });
  it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.empty());
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h2 id="-section-id-st_monad-st-section-"><section id='st_monad'>STモナド</section></h2>
<p>STモナドとは、状態の変化を取りこんだモナドのこと。</p>
<h3 id="st-">STモナドの定義</h3>
<p><a href="https://www.amazon.co.jp/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=pd_sim_14_26?_encoding=UTF8&amp;psc=1&amp;refRID=ZT8DRRF420JN97H9H4DW">Programming in Haskell(2版)</a>,p.168〜p.172 を参照してください。</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">ST</span> a = <span class="hljs-type">S</span><span class="hljs-container">(<span class="hljs-type">State</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-type">State</span>)</span>)</span>

<span class="hljs-title">app</span> :: <span class="hljs-type">ST</span> a -&gt; <span class="hljs-type">State</span> -&gt; (a,<span class="hljs-type">State</span>)
<span class="hljs-title">app</span> (<span class="hljs-type">S</span> st) x = st x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">ST</span> <span class="hljs-keyword">where</span></span>
  <span class="hljs-comment">-- (&gt;&gt;=) :: ST a -&gt; (a -&gt; ST b) -&gt; ST b</span>
  st &gt;&gt;= f = <span class="hljs-type">S</span>(\state -&gt; 
                  <span class="hljs-keyword">let</span> (x, state') = app st state 
                  <span class="hljs-keyword">in</span> app (f x) state'
              )
  unit :: a -&gt; <span class="hljs-type">ST</span> a
  unit x = <span class="hljs-type">S</span>(\s -&gt; (x,s))

  get = <span class="hljs-type">S</span>(\s -&gt; (s,s))
  put newState = <span class="hljs-type">S</span>(\s -&gt; ((), newState))
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ST = {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p><strong>ST#unit</strong></p>
<blockquote>
<p>第1引数valueの値に第2引数stateという状態を付加する。</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit: (value) =&gt; { 
    <span class="hljs-keyword">return</span> (state) =&gt; { 
      <span class="hljs-keyword">return</span> Pair.cons(value,state);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p><strong>ST#flatMap</strong></p>
<blockquote>
<p>第1引数instanceMを実行して、新しい状態state<em>と計算結果xを得る。
計算結果xに関数fを適用すると、f(x)というSTモナドインスタンスが得られる。
最後に、そのf(x)に新しい状態state</em>を適用して、最終結果を得る。</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (instanceM) =&gt; { <span class="hljs-comment">// instanceM:: ST a</span>
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// f:: a -&gt; ST b</span>
      expect(f).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> (state) =&gt; {
        <span class="hljs-keyword">var</span> newState = ST.app(instanceM)(state); <span class="hljs-comment">// instanceM(state)</span>
        <span class="hljs-keyword">return</span> newState.match({
          cons:(x, state_) =&gt; {
            <span class="hljs-keyword">return</span> ST.app(f(x))(state_);
          }
        });
      };
    };
  },
  app: (st) =&gt; {
    <span class="hljs-keyword">return</span> (state) =&gt; {
      <span class="hljs-keyword">return</span> st(state);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p><strong>ST#get</strong></p>
<blockquote>
<p>現在の状態を取ってきて、それを結果として提示する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  get: (_) =&gt; {
    <span class="hljs-keyword">return</span> (state) =&gt; {
      <span class="hljs-keyword">return</span> Pair.cons(state,state);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p><strong>ST#put</strong></p>
<blockquote>
<p>現在の状態stateを新しい状態newStateに更新する</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>  put: (newState) =&gt; { 
    <span class="hljs-keyword">return</span> (state) =&gt; { 
      <span class="hljs-keyword">return</span> Pair.cons(Pair.empty(),newState);
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <h3 id="st-">STモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"STモナドをテストする"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h4 id="-">スタック操作を実現する</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">"Stackを作る"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p><strong>pop関数</strong>の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* pop:: State Stack Int */</span>
    <span class="hljs-keyword">var</span> pop = (_) =&gt; {
      <span class="hljs-keyword">return</span> ST.flatMap(ST.get())((alist) =&gt; {
        <span class="hljs-keyword">return</span> List.match(alist,{
          cons: (x,xs) =&gt; {
            <span class="hljs-keyword">return</span> ST.flatMap(ST.put(xs))((_) =&gt; {
              <span class="hljs-keyword">return</span> ST.unit(x);
            });
          }
        });
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p><strong>push関数</strong>の定義</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* push:: Int -&gt; State Stack () */</span>
    <span class="hljs-keyword">var</span> push = (x) =&gt; {
      <span class="hljs-keyword">return</span> ST.flatMap(ST.get())((xs) =&gt; {
        <span class="hljs-keyword">return</span> ST.put(List.cons(x,xs));
      }); 
    };
    it(<span class="hljs-string">'スタックを操作する'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> stackManip = ST.flatMap(push(<span class="hljs-number">3</span>))((_) =&gt; {
        <span class="hljs-keyword">return</span> ST.flatMap(pop())((a) =&gt; {
          <span class="hljs-keyword">return</span> pop();
        });
      });
      expect(
          Pair.left(
              ST.app(
                  stackManip
                  )(
                      List.fromArray([<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])
                   )
              )
          ).to.eql(
              <span class="hljs-number">5</span>
          );
    expect(
        List.toArray(Pair.right(
                ST.app(
                    stackManip
                    )(
                        List.fromArray([<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])
                     )
                )
            )).to.eql(
               [<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
            );
      next();
    });
  });
  describe(<span class="hljs-string">"Treeの例"</span>,() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Node</span> <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span></span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> Tree = {
      match: (data, pattern) =&gt; {
       <span class="hljs-keyword">return</span> data.call(data, pattern);
      },
      leaf: (value) =&gt; {
         <span class="hljs-keyword">return</span> (pattern) =&gt; {
           <span class="hljs-keyword">return</span> pattern.leaf(value);
         };
      },
      node: (left, right) =&gt; {
         <span class="hljs-keyword">return</span> (pattern) =&gt; {
           <span class="hljs-keyword">return</span> pattern.node(left, right);
         };
      },
      toArray: (tree) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(value) =&gt; {
            <span class="hljs-keyword">return</span> value;
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">return</span> [Tree.toArray(left), Tree.toArray(right)];
          }
        });
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">fmap</span> f (<span class="hljs-type">Leaf</span> x) = <span class="hljs-type">Leaf</span> (f x)
<span class="hljs-title">fmap</span> f (<span class="hljs-type">Node</span> left right) = <span class="hljs-type">Node</span> (fmap f left) (fmap f right)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      map: (f) =&gt; {
        <span class="hljs-keyword">return</span> (tree) =&gt; {
          <span class="hljs-keyword">return</span> Tree.match(tree,{
            leaf:(value) =&gt; {
              <span class="hljs-keyword">return</span> Tree.leaf(f(value));
            },
            node:(left, right) =&gt; {
              <span class="hljs-keyword">return</span> Tree.node(Tree.map(f)(left),Tree.map(f)(right) );
            }
          });
        };
      }
    };
    it(<span class="hljs-string">'Tree.toArray'</span>, (next) =&gt; {
      expect(
        Tree.toArray(Tree.leaf(<span class="hljs-number">1</span>))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        Tree.toArray(Tree.node(Tree.leaf(<span class="hljs-number">1</span>),Tree.leaf(<span class="hljs-number">2</span>)))
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
      );
      expect(
        Tree.toArray(Tree.node(Tree.leaf(<span class="hljs-number">1</span>),
                               Tree.node(Tree.leaf(<span class="hljs-number">2</span>),Tree.leaf(<span class="hljs-number">3</span>))))
      ).to.eql(
        [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
      );
      next();
    });
    it(<span class="hljs-string">'rlabel'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">rlabel</span> :: (<span class="hljs-type">TREE</span>, <span class="hljs-type">STATE</span>) -&gt; (<span class="hljs-type">TREE</span>,<span class="hljs-type">STATE</span>)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> rlabel = (tree, state) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(value) =&gt; {
            <span class="hljs-keyword">return</span> Pair.cons(Tree.leaf(state), state + <span class="hljs-number">1</span>);
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">var</span> leftNode = rlabel(left, state);
            <span class="hljs-keyword">var</span> rightNode = rlabel(right, Pair.right(leftNode));
            <span class="hljs-keyword">return</span> Pair.cons(Tree.node(Pair.left(leftNode), 
                                       Pair.left(rightNode)), 
                             Pair.right(rightNode));
          }
        });
      };
      expect(
        Tree.toArray(Pair.left(rlabel(Tree.leaf(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>)))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Tree.toArray(Pair.left(rlabel(Tree.node(Tree.leaf(<span class="hljs-string">"a"</span>),Tree.leaf(<span class="hljs-string">"b"</span>)),<span class="hljs-number">0</span>)))
      ).to.eql(
        [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
      );
      next();
    });
    it(<span class="hljs-string">'mlabel'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> fresh = (state) =&gt; {
        <span class="hljs-keyword">return</span> Pair.cons(state, state + <span class="hljs-number">1</span>);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">mlabel</span> :: <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">ST</span>(<span class="hljs-type">Tree</span> <span class="hljs-type">Int</span>)
<span class="hljs-title">mlabel</span> (<span class="hljs-type">Leaf</span> _) = <span class="hljs-keyword">do</span> n &lt;- fresh
                     return (<span class="hljs-type">Leaf</span> n)
<span class="hljs-title">mlabel</span> (<span class="hljs-type">Node</span> left right) = <span class="hljs-keyword">do</span> left' &lt;- mlabel left
                              right' &lt;- mlabel right
                              return (<span class="hljs-type">Node</span> left' right')
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> mlabel = (tree) =&gt; {
        <span class="hljs-keyword">return</span> Tree.match(tree,{
          leaf:(_) =&gt; {
            <span class="hljs-keyword">return</span> ST.flatMap(fresh)((n) =&gt; {
              <span class="hljs-keyword">return</span> ST.unit(Tree.leaf(n));
            });
          },
          node:(left, right) =&gt; {
            <span class="hljs-keyword">return</span> ST.flatMap(mlabel(left))((left_) =&gt; {
              <span class="hljs-keyword">return</span> ST.flatMap(mlabel(right))((right_) =&gt; {
                <span class="hljs-keyword">return</span> ST.unit(Tree.node(left_, right_));
              });
            });
          }
        });
      }; 
      expect(
        Tree.toArray(
          Pair.left(
              ST.app(
                    mlabel(Tree.leaf(<span class="hljs-number">1</span>))
                  )(<span class="hljs-number">0</span>))
          )
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Tree.toArray(
          Pair.left(ST.app(mlabel(Tree.node(Tree.leaf(<span class="hljs-string">"a"</span>),Tree.leaf(<span class="hljs-string">"b"</span>))))(<span class="hljs-number">0</span>))
        )
      ).to.eql(
        [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
      );
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <h2 id="-section-id-cont_monad-cont-section-"><section id='cont_monad'>Contモナド</section></h2>
<p>Contモナド(継続モナド)は、中断や再開が可能な計算をモデル化します。</p>
<h3 id="cont-">Contモナドの定義</h3>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Cont</span> r a = <span class="hljs-type">Cont</span> <span class="hljs-container">{ <span class="hljs-title">runCont</span> :: ((<span class="hljs-title">a</span> -&gt; <span class="hljs-title">r</span>) -&gt; <span class="hljs-title">r</span>) }</span> <span class="hljs-comment">-- r は計算全体の最終の型</span></span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-container">(<span class="hljs-type">Cont</span> <span class="hljs-title">r</span>)</span> <span class="hljs-keyword">where</span></span> 
    return a       = <span class="hljs-type">Cont</span> $ \k -&gt; k a                       
    <span class="hljs-comment">-- i.e. return a = \k -&gt; k a </span>
    (<span class="hljs-type">Cont</span> c) &gt;&gt;= f = <span class="hljs-type">Cont</span> $ \k -&gt; c (\a -&gt; runCont (f a) k) 
    <span class="hljs-comment">-- i.e. m &gt;&gt;= f = \k -&gt; m (\a -&gt; f a k)</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> Cont = {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">return</span> a       = <span class="hljs-type">Cont</span> $ \k -&gt; k a
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit: (a) =&gt; {
    <span class="hljs-keyword">return</span> (k) =&gt; {
      <span class="hljs-keyword">return</span> k(a);
    };
  },
  flatMap: (m) =&gt; {
    <span class="hljs-keyword">return</span> (f) =&gt; { <span class="hljs-comment">// f:: a -&gt; Cont r a</span>
      expect(f).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> (k) =&gt; {
        <span class="hljs-keyword">return</span> m((a) =&gt; {
          <span class="hljs-keyword">return</span> f(a)(k);
        });
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadCont</span> m <span class="hljs-keyword">where</span></span>
  callCC :: ((a -&gt; m a) -&gt; m a) -&gt; m a
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">MonadCont</span> <span class="hljs-container">(<span class="hljs-type">Cont</span> <span class="hljs-title">r</span>)</span> <span class="hljs-keyword">where</span></span>
  callCC f = <span class="hljs-type">Cont</span> $ \k -&gt; runCont (f (\a -&gt; <span class="hljs-type">Cont</span> $ \_ -&gt; k a)) k
  <span class="hljs-comment">-- i.e.  callCC f = \k -&gt; ((f (\a -&gt; \_ -&gt; k a)) k)</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  callCC: (f) =&gt; {
    <span class="hljs-keyword">return</span> (k) =&gt;{ 
      <span class="hljs-keyword">return</span> f((a) =&gt; {
        <span class="hljs-keyword">return</span> (_) =&gt; {
          <span class="hljs-keyword">return</span> k(a);
        }; 
      })(k);
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h3 id="cont-">Contモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Contモナドをテストする"</span>,() =&gt; {
  <span class="hljs-keyword">var</span> identity = (x) =&gt; {
    <span class="hljs-keyword">return</span> x;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <pre><code class="lang-haskell">*<span class="hljs-type">Main</span>&gt; <span class="hljs-keyword">let</span> s3 = <span class="hljs-type">Cont</span> (square <span class="hljs-number">3</span>)
*<span class="hljs-type">Main</span>&gt; print =: runCont s3
<span class="hljs-number">9</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'square'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">square</span> :: <span class="hljs-type">Int</span> -&gt; ((<span class="hljs-type">Int</span> -&gt; r) -&gt; r)
<span class="hljs-title">square</span> x = \k -&gt; k (x * x)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> square = (n) =&gt; {
      <span class="hljs-keyword">return</span> n * n;
    };
    <span class="hljs-keyword">var</span> square3 = Cont.unit(square(<span class="hljs-number">3</span>)); 
    expect(
      square3(identity)
    ).to.eql(
      <span class="hljs-number">9</span>
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p><strong>Cont.flatMap</strong>で算術演算を組み合わせる例</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'Cont.flatMapで算術演算を組み合わせる例'</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> addCPS = (n,m) =&gt; {
      <span class="hljs-keyword">var</span> add = (n,m) =&gt; {
        <span class="hljs-keyword">return</span> n + m;
      };
      <span class="hljs-keyword">return</span> Cont.unit(add(n,m)); 
    };
    expect(
      addCPS(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)(identity)
    ).to.eql(
      <span class="hljs-number">5</span>
    );
    <span class="hljs-keyword">var</span> multiplyCPS = (n,m) =&gt; {
      <span class="hljs-keyword">var</span> multiply = (n,m) =&gt; {
        <span class="hljs-keyword">return</span> n * m;
      };
      <span class="hljs-keyword">return</span> Cont.unit(multiply(n,m)); 
    };
    <span class="hljs-keyword">var</span> subtractCPS = (n,m) =&gt; {
      <span class="hljs-keyword">var</span> subtract = (n,m) =&gt; {
        <span class="hljs-keyword">return</span> n - m;
      };
      <span class="hljs-keyword">return</span> Cont.unit(subtract(n,m)); 
    };
    <span class="hljs-comment">/* ((2 + 3) * 4) - 5 = 15 */</span>
    expect(
      Cont.flatMap(addCPS(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))((addResult) =&gt; {
        <span class="hljs-keyword">return</span> Cont.flatMap(multiplyCPS(addResult,<span class="hljs-number">4</span>))((multiplyResult) =&gt; {
          <span class="hljs-keyword">return</span> Cont.flatMap(subtractCPS(multiplyResult,<span class="hljs-number">5</span>))((result) =&gt; {
            <span class="hljs-keyword">return</span> Cont.unit(result);
          });
        });
      })(identity)
    ).to.eql(
      <span class="hljs-number">15</span>
    );
    next();
  });
  describe(<span class="hljs-string">"callCCを利用する"</span>,() =&gt; {
    it(<span class="hljs-string">'square using callCC'</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-comment">-- Without callCC</span>
<span class="hljs-title">square</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Cont</span> r <span class="hljs-type">Int</span>
<span class="hljs-title">square</span> n = return (n ˆ <span class="hljs-number">2</span>)
<span class="hljs-comment">-- With callCC</span>
<span class="hljs-title">squareCCC</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Cont</span> r <span class="hljs-type">Int</span>
<span class="hljs-title">squareCCC</span> n = callCC $ \k -&gt; k (n ˆ <span class="hljs-number">2</span>)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> squareCPS = (n) =&gt; {
        <span class="hljs-keyword">return</span> Cont.unit(n * n);
      };
      expect(
        squareCPS(<span class="hljs-number">2</span>)(identity)
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      <span class="hljs-keyword">var</span> safeDivideCC = (n,m) =&gt; {
        <span class="hljs-keyword">return</span> Cont.callCC((k) =&gt; {
          <span class="hljs-keyword">if</span>(m !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> k(n / m);
          }
          <span class="hljs-keyword">return</span> k(<span class="hljs-literal">null</span>);
        });
      };
      expect(
        safeDivideCC(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)(identity)
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        safeDivideCC(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>)(identity)
      ).to.be(
        <span class="hljs-literal">null</span>
      );
      next();
    });
    it(<span class="hljs-string">'even'</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;
      };
      expect(
        even(<span class="hljs-number">3</span> * Cont.callCC((k) =&gt; {
          <span class="hljs-keyword">return</span> k(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>);
        }))
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p><a href="index.html">目次に戻る</a> </p>

            </div>
            
        </li>
        
    </ul>
  <!-- <div id="footer">  目次に戻る。 </div> -->
  <!-- </div> -->
</body>
</html>
