<!DOCTYPE html>

<html>
<head>
  <title>monad.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>monad.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="-">モナド</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="maybe-">Maybeモナド</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Maybe = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(Maybe,pattern);
  },
  just : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.just(value);
    };
  },
  nothing : (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.nothing(_);
    };
  },
  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.just(value);
  },
  flatMap : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        }
      });
    };
  },
  get: (maybe) =&gt; {
    <span class="hljs-keyword">return</span> Maybe.match(maybe,{
      just: (value) =&gt; {
        <span class="hljs-keyword">return</span> value;
      },
      nothing: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    });
  },
  isEqual : (maybeA) =&gt; {
    <span class="hljs-keyword">return</span> (maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.match(maybeA,{
        just: (valueA) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (valueB) =&gt; {
              <span class="hljs-keyword">return</span> (valueA === valueB);
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.match(maybeB,{
            just: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });
        }
      });
    };
  },
  map : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> Maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.unit(transform(value));
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.nothing(_);
        }
      });
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3 id="maybe-">Maybeモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">"Maybeモナドをテストする"</span>,() =&gt; {
  it(<span class="hljs-string">"Maybe#flatMap"</span>, (next) =&gt; {
    Maybe.match(Maybe.flatMap(Maybe.just(<span class="hljs-number">1</span>))((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      },
      nothing: (_) =&gt; {
       expect().fail();
      }
    });
    Maybe.match(Maybe.flatMap(Maybe.nothing())((a) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.unit(a);
    }),{
      just: (value) =&gt; {
       expect().fail();
      },
      nothing: (_) =&gt; {
       expect(<span class="hljs-literal">true</span>).to.be.ok();
      }
    });
    next();
  });
  it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeA)((a) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.flatMap(maybeB)((b) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.unit(a + b);
        });
      });
    };
    <span class="hljs-keyword">var</span> justOne = Maybe.just(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> justTwo = Maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justThree = Maybe.just(<span class="hljs-number">3</span>);
    expect(
      Maybe.isEqual(add(justOne,justTwo))(justThree)
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      Maybe.isEqual(add(justOne,Maybe.nothing()))(Maybe.nothing())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="list-">Listモナド</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> List  = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(List,pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  unit: (value) =&gt; {
    <span class="hljs-keyword">return</span> List.cons(value, List.empty());
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
append [] ys = ys
append (x:xs) ys = x : (xs ++ ys)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> List.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(head,List.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]
concat [] = []
concat (xs:xss) = xs ++ concat xss</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (list_of_list) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(list_of_list)(List.empty())(List.append);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">flatten</span> :: [[a]] -&gt; [a]
<span class="hljs-title">flatten</span> =  foldr (++) []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (instanceMM) =&gt; {
    <span class="hljs-keyword">return</span> List.concat(instanceMM);
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUN[T-&gt;U] -&gt; LIST[U]
map [] _ = []
map (x:xs) f = f x : map xs f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> List.match(instanceM,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> List.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> List.cons(transform(head),
                           List.map(tail)(transform));
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">xs</span> &gt;&gt;= f = concat (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; { <span class="hljs-comment">// FUN[T-&gt;LIST[T]]</span>
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> List.concat(List.map(instanceM)(transform));
    };
  },
  <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>1段階のリストしか配列に変更できない</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(alist)([])((item) =&gt; {
      <span class="hljs-keyword">return</span> (accumulator) =&gt; {
        <span class="hljs-keyword">return</span> [item].concat(accumulator);
      };
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUN[T -&gt; U -&gt; U] -&gt; T
foldr []     z _ = z
foldr (x:xs) z f = f x (foldr xs z f) </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (alist) =&gt; {         <span class="hljs-comment">// alist:: LIST[T]</span>
    <span class="hljs-keyword">return</span> (accumulator) =&gt; { <span class="hljs-comment">// accumulator:: T</span>
      <span class="hljs-keyword">return</span> (glue) =&gt; {      <span class="hljs-comment">// glue:: FUN[T -&gt; U -&gt; U] </span>
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> List.match(alist, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(List.foldr(tail)(accumulator)(glue));;
          }
        });
      };
    };
  }
}; <span class="hljs-comment">// end of list monad</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3 id="list-">Listモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Listモナドのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">"'List#empty'"</span>, (next) =&gt; {
    List.match(List.empty,{
      empty: (_) =&gt; {
        expect(<span class="hljs-literal">true</span>).ok();
      },
      cons: (x,xs) =&gt; {
        expect().fail();
      }
    });
    next();
  });
  it(<span class="hljs-string">"'List#isEmpty'"</span>, (next) =&gt; {
    expect(
      List.isEmpty(List.empty())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      List.isEmpty(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#cons'"</span>, (next) =&gt; {
    List.match(List.cons(<span class="hljs-number">1</span>,List.empty()),{
      empty: (_) =&gt; {
        expect().fail()
      },
      cons: (x,xs) =&gt; {
        expect(x).to.eql(<span class="hljs-number">1</span>)
      }
    });
    next();
  });
  it(<span class="hljs-string">"'List#head'"</span>, (next) =&gt; {
    expect(
      List.head(List.cons(<span class="hljs-number">1</span>,List.empty()))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#tail'"</span>, (next) =&gt; {
    expect(
      List.head(List.tail(List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#append'"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.append(List.cons(<span class="hljs-number">1</span>,List.empty()))(List.cons(<span class="hljs-number">2</span>,List.empty()));
    expect(
      List.head(theList)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(theList))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(theList)))
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#concat'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [[1,2],[3,4]] */</span>
    <span class="hljs-keyword">var</span> one_two = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
    <span class="hljs-keyword">var</span> three_four = List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()));

    <span class="hljs-keyword">var</span> list_of_list = List.cons(one_two,
                                 List.cons(three_four, List.empty()));
    <span class="hljs-comment">/* concated_list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> concated_list = List.concat(list_of_list);
    expect(
      List.toArray(concated_list)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    expect(
      List.head(concated_list)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      List.head(List.tail(concated_list))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      List.isEmpty(List.tail(List.tail(concated_list)))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'List#foldr'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)))
    expect(
      List.foldr(theList)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> accumulator + item;
        };
      })
    ).to.eql(
      <span class="hljs-number">10</span>
    )
    next();
  })
  it(<span class="hljs-string">"'List#toArray'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)))
    expect(
      List.toArray(theList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    next();
  });
  it(<span class="hljs-string">"'List#map'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3,4] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
    expect(
      List.toArray(List.map(theList)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      }))
    ).to.eql(
      [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
    );
    next();
  });
  it(<span class="hljs-string">"'List#unit'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1] */</span>
    expect(
      List.toArray(List.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    expect(
      List.toArray(List.unit(<span class="hljs-literal">null</span>))
    ).to.eql(
      [<span class="hljs-literal">null</span>]
    );
    next();
  });
  it(<span class="hljs-string">"'List#flatMap'"</span>, (next) =&gt; {
    <span class="hljs-comment">/* list = [1,2,3] */</span>
    <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>, List.cons(<span class="hljs-number">3</span>, List.empty())));
    expect(
      List.toArray(List.flatMap(theList)((item) =&gt; {
        <span class="hljs-keyword">return</span> List.append(List.unit(item))(List.unit(- item));
      }))
    ).to.eql(
      [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
    );
    next();
  });
  describe(<span class="hljs-string">"Listモナドを活用する"</span>,() =&gt; {
    it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()))));
      expect(
        List.toArray(List.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">if</span>(even(item)) {
            <span class="hljs-keyword">return</span> List.unit(item);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> List.empty();
          }
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> theNumberList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
      <span class="hljs-keyword">var</span> theStringList = List.cons(<span class="hljs-string">"one"</span>,List.cons(<span class="hljs-string">"two"</span>,List.empty()));
      expect(
        List.toArray(List.flatMap(theNumberList)((n) =&gt; {
          <span class="hljs-keyword">return</span> List.flatMap(theStringList)((s) =&gt; {
            <span class="hljs-keyword">return</span> List.unit([n,s]);
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
      );
      next();
    });
    <span class="hljs-comment">/* #@range_begin(list_maybe) */</span>
    describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
      it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.empty());
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>]
        );
        next();
      });
      it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                                List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
        <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
          <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(value);
          });
        });
        expect(
          List.toArray(justList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        );
        next();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(null),
                          list.empty());
  var justList = list.flatMap(theList)((listItem) =&gt; {
    return maybe.flatMap(listItem)((value) =&gt; {
      return list.unit(value);
      // return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
    });
  });
  describe(<span class="hljs-string">"Listモナドを活用する"</span>,() =&gt; {
    it(<span class="hljs-string">"'List#empty'"</span>, (next) =&gt; {
      List.match(List.empty,{
        empty: (_) =&gt; {
          expect(<span class="hljs-literal">true</span>).ok();
        },
        cons: (x,xs) =&gt; {
          expect().fail();
        }
      });
      next();
    });
    it(<span class="hljs-string">"'List#isEmpty'"</span>, (next) =&gt; {
      expect(
        List.isEmpty(List.empty())
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      expect(
        List.isEmpty(List.cons(<span class="hljs-number">1</span>,List.empty()))
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">"'List#cons'"</span>, (next) =&gt; {
      List.match(List.cons(<span class="hljs-number">1</span>,List.empty()),{
        empty: (_) =&gt; {
          expect().fail();
        },
        cons: (x,xs) =&gt; {
          expect(x).to.eql(<span class="hljs-number">1</span>);
        }
      });
      next();
    });
    it(<span class="hljs-string">"'List#head'"</span>, (next) =&gt; {
      expect(
        List.head(List.cons(<span class="hljs-number">1</span>,List.empty()))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      next();
    });
    it(<span class="hljs-string">"'List#tail'"</span>, (next) =&gt; {
      expect(
        List.head(List.tail(List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"'List#append'"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> theList = List.append(List.cons(<span class="hljs-number">1</span>,List.empty()))(List.cons(<span class="hljs-number">2</span>,List.empty()));
      expect(
        List.head(theList)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        List.head(List.tail(theList))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        List.isEmpty(List.tail(List.tail(theList)))
      ).to.eql(
        <span class="hljs-literal">true</span>
      );
      next();
    });
    it(<span class="hljs-string">"'List#concat'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>list = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> one_two = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
      <span class="hljs-keyword">var</span> three_four = List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()));

      <span class="hljs-keyword">var</span> list_of_list = List.cons(one_two,
                                   List.cons(three_four, List.empty()));</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>concated_list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> concated_list = List.concat(list_of_list);
      expect(
        List.toArray(concated_list)
      ).to.eql(
        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
      );
      expect(
        List.head(concated_list)
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        List.head(List.tail(concated_list))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        List.isEmpty(List.tail(List.tail(concated_list)))
      ).to.eql(
        <span class="hljs-literal">false</span>
      );
      next();
    });
    it(<span class="hljs-string">"'List#foldr'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)))
      expect(
        List.foldr(theList)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
          <span class="hljs-keyword">return</span> (accumulator) =&gt; {
            <span class="hljs-keyword">return</span> accumulator + item;
          };
        })
      ).to.eql(
        <span class="hljs-number">10</span>
      )
      next();
    });
    describe(<span class="hljs-string">"'List#toArray'"</span>, () =&gt; {
      it(<span class="hljs-string">"1段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
        expect(
          List.toArray(theList)
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
        );
        next();
      });
      it(<span class="hljs-string">"2段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>list = [[1],[2]] </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> nestedList = List.cons(List.cons(<span class="hljs-number">1</span>,List.empty()),
                                   List.cons(List.cons(<span class="hljs-number">2</span>,List.empty()),
                                             List.empty()));
        expect(
          List.toArray(List.flatMap(nestedList)((alist) =&gt; {
            <span class="hljs-keyword">return</span> List.flatMap(alist)((item) =&gt; {
              <span class="hljs-keyword">return</span> List.unit(item);
            });
          }))
        ).to.eql(
          [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
        );
        next();
      });
    });
    it(<span class="hljs-string">"'List#map'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()),List.empty)));
      expect(
        List.toArray(List.map(theList)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
          <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
      );
      next();
    });
    it(<span class="hljs-string">"'List#unit'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expect(
        List.toArray(List.unit(<span class="hljs-number">1</span>))
      ).to.eql(
        [<span class="hljs-number">1</span>]
      );
      expect(
        List.toArray(List.unit(<span class="hljs-literal">null</span>))
      ).to.eql(
        [<span class="hljs-literal">null</span>]
      );
      next();
    });
    describe(<span class="hljs-string">"List#flatMap"</span>, () =&gt; {
      it(<span class="hljs-string">"条件でフィルターする"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> list1 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                           List.empty()));
        <span class="hljs-keyword">var</span> list2 = List.cons(<span class="hljs-number">1</span>, List.cons(<span class="hljs-number">2</span>,
                                           List.empty()));
        expect(
          List.toArray(List.flatMap(list1)((item1) =&gt; {
            <span class="hljs-keyword">return</span> List.flatMap(list2)((item2) =&gt; {
              <span class="hljs-keyword">if</span>(item1 + item2 === <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">return</span> List.unit([item1, item2]);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> List.empty();
              }
            });
          }))
        ).to.eql(
          [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]
        );
        next();
      });
      it(<span class="hljs-string">"'List#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>, List.empty());
        expect(
          List.toArray(List.flatMap(theList)((item) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
          }))
        ).to.eql(
          [<span class="hljs-number">2</span>]
        );
        <span class="hljs-keyword">var</span> emptyList = List.empty();
        expect(
          List.toArray(List.flatMap(emptyList)((item) =&gt; {
            <span class="hljs-keyword">return</span> List.unit(item * <span class="hljs-number">2</span>); 
          }))
        ).to.eql(
          []
        );
        next();
      });
      it(<span class="hljs-string">"'List#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>, List.cons(<span class="hljs-number">3</span>, List.empty())));
        expect(
          List.toArray(List.flatMap(theList)((item) =&gt; {
            <span class="hljs-keyword">return</span> List.append(List.unit(item))(List.unit(- item));
          }))
        ).to.eql(
          [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
        );
        next();
      });
      it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> even = (n) =&gt; {
          <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        };
        <span class="hljs-keyword">var</span> theList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.cons(<span class="hljs-number">3</span>,List.cons(<span class="hljs-number">4</span>,List.empty()))));
        expect(
          List.toArray(List.flatMap(theList)((item) =&gt; {
            <span class="hljs-keyword">if</span>(even(item)) {
              <span class="hljs-keyword">return</span> List.unit(item);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> List.empty();
            }
          }))
        ).to.eql(
          [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
        );
        next();
      });
      it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
        <span class="hljs-keyword">var</span> theNumberList = List.cons(<span class="hljs-number">1</span>,List.cons(<span class="hljs-number">2</span>,List.empty()));
        <span class="hljs-keyword">var</span> theStringList = List.cons(<span class="hljs-string">"one"</span>,List.cons(<span class="hljs-string">"two"</span>,List.empty()));
        expect(
          List.toArray(List.flatMap(theNumberList)((n) =&gt; {
            <span class="hljs-keyword">return</span> List.flatMap(theStringList)((s) =&gt; {
              <span class="hljs-keyword">return</span> List.unit([n,s]);
            });
          }))
        ).to.eql(
          [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
        );
        next();
      });
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="stream-">Streamモナド</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> stream = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(stream,pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (head,tailThunk) =&gt; {
    expect(tailThunk).to.a(<span class="hljs-string">'function'</span>);
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      expect(pattern).to.an(<span class="hljs-string">'object'</span>);
      <span class="hljs-keyword">return</span> pattern.cons(head,tailThunk);
    };
  },
  <span class="hljs-comment">/* head:: STREAM -&gt; MAYBE[STREAM] */</span>
  head: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (value, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(value);
      }
    });
  },
  <span class="hljs-comment">/* tail:: STREAM -&gt; MAYBE[STREAM] */</span>
  tail: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.nothing();
      },
      cons: (head, tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> Maybe.just(tailThunk());
      }
    });
  },
  isEmpty: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h3 id="stream-toarray">stream#toArray</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> [];
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">if</span>(stream.isEmpty(tailThunk())){
          <span class="hljs-keyword">return</span> [head];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> [head].concat(stream.toArray(tailThunk()));
        }
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h3 id="stream-unit">stream#unit</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* unit:: ANY -&gt; STREAM */</span>
  unit: (value) =&gt; {
    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>){
      <span class="hljs-keyword">return</span> stream.cons(value, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> stream.empty();
    }
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h3 id="stream-map">stream#map</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> stream.match(lazyList,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(transform(head),(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.map(tailThunk())(transform)});
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h2 id="stream-append">stream#append</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ysThunk) =&gt; {
      <span class="hljs-keyword">return</span> stream.match(xs,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ysThunk();
        },
        cons: (head,tailThunk) =&gt; {
          <span class="hljs-keyword">return</span> stream.cons(head,(_) =&gt; {
            <span class="hljs-keyword">return</span> stream.append(tailThunk())(ysThunk);
          });
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h2 id="stream-concat">stream#concat</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* concat:: STREAM[STREAM[T]] -&gt; STREAM[T] */</span>
  concat: (astream) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(astream,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> stream.append(head,tailThunk());
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h2 id="stream-flatten">stream#flatten</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* flatten :: STREAM[STREAM[T]] =&gt; STREAM[T] */</span>
  flatten: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> stream.match(lazyList,{
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      },
      cons: (head,tailThunk) =&gt; {
        <span class="hljs-keyword">return</span> stream.append(head)((_) =&gt; {
          <span class="hljs-keyword">return</span> stream.flatten(tailThunk());
        });
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="stream-flatmap">stream#flatMap</h3>
<pre><code class="lang-haskell"><span class="hljs-title">flatMap</span> xs f = flatten (map f xs)
</code></pre>
<p>flatMap:: STREAM[T] -&gt; FUNC[T-&gt;STREAM[T]] -&gt; STREAM[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (lazyList) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> stream.flatten(stream.map(lazyList)(transform));
    };
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3 id="stream-">Streamモナドのテスト</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'Streamモナドのテスト'</span>, () =&gt; {
  it(<span class="hljs-string">"stream#unit"</span>, (next) =&gt; {
    stream.match(Maybe.nothing(<span class="hljs-literal">null</span>),{
      nothing: (_) =&gt; {
        <span class="hljs-keyword">return</span> expect(
          _
        ).to.eql(
          <span class="hljs-literal">null</span>
        );
      },
      just: (value) =&gt; {
        <span class="hljs-keyword">return</span> expect().fail();
      }
    });
    <span class="hljs-keyword">var</span> lazyList = stream.unit(<span class="hljs-number">1</span>);
    expect(
      Maybe.get(stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(stream.head(stream.unit(<span class="hljs-number">1</span>)))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(stream.head(stream.unit(<span class="hljs-number">0</span>)))
    ).to.eql(
      <span class="hljs-number">0</span>
    );
    next();
  });
  it(<span class="hljs-string">"stream#cons"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    expect(
      Maybe.get(stream.head(lazyList))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"stream#tail"</span>, (next) =&gt; {
    <span class="hljs-comment">/* lazyList = [1,2] */</span>
    <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    expect(
      stream.tail(lazyList)
    ).to.a(<span class="hljs-string">"function"</span>);

    stream.match(stream.tail(lazyList),{
      nothing: (_) =&gt; {
        expect().fail();
      },
      just: (tail) =&gt; {
        stream.match(tail,{
          empty: (_) =&gt; {
            expect().fail();
          },
          cons: (head, tailThunk) =&gt; {
            expect(head).to.eql(<span class="hljs-number">2</span>);
          }
        });
      }
    });
    expect(
      Maybe.get(stream.head(Maybe.get(stream.tail(lazyList))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"stream#toArray"</span>, (next) =&gt; {
    expect(
      stream.toArray(stream.empty())
    ).to.eql(
      []
    );
    expect(
      stream.toArray(stream.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });
  it(<span class="hljs-string">"stream#append"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> xs = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.empty();
    });
    <span class="hljs-keyword">var</span> ysThunk = (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    };
    <span class="hljs-keyword">var</span> theStream = stream.append(xs)(ysThunk);
    expect(
      Maybe.get(stream.head(theStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(stream.head(Maybe.get(stream.tail(theStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"stream#flatten"</span>, (next) =&gt; {
    <span class="hljs-comment">/* innerStream = [1,2] */</span>
    <span class="hljs-keyword">var</span> innerStream = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
      <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
        <span class="hljs-keyword">return</span> stream.empty();
      });
    });
    <span class="hljs-comment">/* outerStream = [[1,2]] */</span>
    <span class="hljs-keyword">var</span> outerStream = stream.unit(innerStream);
    <span class="hljs-keyword">var</span> flattenedStream = stream.flatten(outerStream);
    stream.match(flattenedStream,{
      empty: (_) =&gt; {
        expect().fail()
      },
      cons: (head,tailThunk) =&gt; {
        expect(head).to.eql(<span class="hljs-number">1</span>)
      }
    });
    expect(
      Maybe.get(stream.head(flattenedStream))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      Maybe.get(stream.head(Maybe.get(stream.tail(flattenedStream))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  describe(<span class="hljs-string">"stream#map"</span>, () =&gt; {
    it(<span class="hljs-string">"mapで要素を2倍にする"</span>, (next) =&gt; {
      <span class="hljs-comment">/* lazyList = [1,2] */</span>
      <span class="hljs-keyword">var</span> lazyList = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> doubledLazyList = stream.map(lazyList)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(stream.head(doubledLazyList))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(doubledLazyList))))
      ).to.eql(
        <span class="hljs-number">4</span>
      );
      expect(
        stream.toArray(doubledLazyList)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"無限の整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-comment">/* #@range_begin(ones_infinite_sequence) */</span>
      <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      expect(
        Maybe.get(stream.head(ones))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(ones))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-comment">/* #@range_end(ones_infinite_sequence) */</span>
      <span class="hljs-keyword">var</span> twoes = stream.map(ones)((item) =&gt; {
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(twoes))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(Maybe.get(stream.tail(twoes))))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"整数列を作る"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> integersFrom = (from) =&gt; {
        <span class="hljs-keyword">return</span> stream.cons(from, (_) =&gt; {
          <span class="hljs-keyword">return</span> integersFrom(from + <span class="hljs-number">1</span>);
        });
      };
      expect(
        Maybe.get(stream.head(integersFrom(<span class="hljs-number">0</span>)))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(integersFrom(<span class="hljs-number">0</span>)))))
      ).to.eql(
        <span class="hljs-number">1</span>
      );
      <span class="hljs-keyword">var</span> doubledIntergerMapped = stream.map(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> integer * <span class="hljs-number">2</span>;
      });
      expect(
        Maybe.get(stream.head(doubledIntergerMapped))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(doubledIntergerMapped))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      <span class="hljs-keyword">var</span> doubledInterger = stream.flatMap(integersFrom(<span class="hljs-number">0</span>))((integer) =&gt; {
        <span class="hljs-keyword">return</span> stream.unit(integer * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(stream.head(doubledInterger))
      ).to.eql(
        <span class="hljs-number">0</span>
      );
      expect(
        Maybe.get(stream.head(Maybe.get(stream.tail(doubledInterger))))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"一段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> ones = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> ones;
      });
      <span class="hljs-keyword">var</span> twoes = stream.flatMap(ones)((one) =&gt; {
        expect(one).to.a(<span class="hljs-string">'number'</span>);
        <span class="hljs-keyword">return</span> stream.unit(one * <span class="hljs-number">2</span>);
      });
      expect(
        Maybe.get(stream.head(twoes))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      next();
    });
    it(<span class="hljs-string">"二段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-comment">/*
        scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))
        scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))
        res0: List[Int] = List(2, 4, 6, 8)
      */</span>
      <span class="hljs-keyword">var</span> innerStream12 = stream.cons(<span class="hljs-number">1</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">2</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> innerStream34 = stream.cons(<span class="hljs-number">3</span>, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.cons(<span class="hljs-number">4</span>,(_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
      });
      <span class="hljs-comment">/* nestedStream = [[1,2],[3,4]] */</span>
      <span class="hljs-keyword">var</span> nestedStream = stream.cons(innerStream12, (_) =&gt; {
        <span class="hljs-keyword">return</span> stream.cons(innerStream34,(_) =&gt; {
          <span class="hljs-keyword">return</span> stream.empty();
        });
      });
      <span class="hljs-keyword">var</span> flattenedStream = stream.flatMap(nestedStream)((innerStream) =&gt; {
        <span class="hljs-keyword">return</span> stream.flatMap(innerStream)((n) =&gt; {
          expect(n).to.a(<span class="hljs-string">'number'</span>);
          <span class="hljs-keyword">return</span> stream.unit(n * <span class="hljs-number">2</span>);
        });
      });
      expect(
        Maybe.get(stream.head(flattenedStream))
      ).to.eql(
        <span class="hljs-number">2</span>
      );
      expect(
        stream.toArray(flattenedStream)
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
      );
      next();
    });

  });
}); <span class="hljs-comment">// streamモナド</span>
describe(<span class="hljs-string">"Readerモナドをテストする"</span>,() =&gt; {
  <span class="hljs-keyword">var</span> READER = {
    unit: (x) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        <span class="hljs-keyword">return</span> x;
      };
    },
    flatMap: (instanceM) =&gt; {
      <span class="hljs-keyword">return</span> (transform) =&gt; {
        <span class="hljs-keyword">return</span> (w) =&gt; {
          <span class="hljs-keyword">return</span> transform(instanceM(w))(w);
        };
      };
    }
  };
});</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h2 id="io-">IOモナド</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> IO = {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>unit:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit : (any) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界は明示する必要はありません</span>
      <span class="hljs-keyword">return</span> any;
    };
  },
  <span class="hljs-comment">/* flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U] */</span>
  flatMap : (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
      <span class="hljs-keyword">return</span> IO.unit(IO.run(actionAB(IO.run(instanceA))));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h3 id="io-done-">IO.done関数</h3>
<p>IOアクションを何も実行しない</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
  done : (any) =&gt; {
    <span class="hljs-keyword">return</span> IO.unit();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="io-run-">IO.run関数</h3>
<p>IOアクションを実行する</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* run:: IO[A] =&gt; A */</span>
  run : (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> instanceM();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>readFile:: STRING =&gt; IO[STRING]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  readFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
      <span class="hljs-keyword">return</span> IO.unit(content)(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>println:: STRING =&gt; IO[null]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  println : (message) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-built_in">console</span>.log(message);
      <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
    };
  },
  writeFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (content) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        fs.writeFileSync(path,content);
        <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  seq: (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (instanceB) =&gt; {
      <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
        <span class="hljs-keyword">return</span> instanceB;
      });
    };
  },
  seqs: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.foldr(alist)(List.empty())(IO.done());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>IO.putc:: CHAR =&gt; IO[]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  putc: (character) =&gt; {
    <span class="hljs-keyword">return</span> (io) =&gt; {
      process.stdout.write(character);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>IO.puts:: LIST[CHAR] =&gt; IO[]</p>
<pre><code class="lang-haskell"><span class="hljs-title">puts</span> list = seqs (map putc list)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  puts: (alist) =&gt; {
    <span class="hljs-keyword">return</span> List.match(alist, {
      empty: () =&gt; {
        <span class="hljs-keyword">return</span> IO.done();
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>IO.getc :: IO[CHAR]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getc: () =&gt; {
    <span class="hljs-keyword">var</span> continuation = () =&gt; {
      <span class="hljs-keyword">var</span> chunk = process.stdin.read();
      <span class="hljs-keyword">return</span> chunk;
    }; 
    process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
  }
};

describe(<span class="hljs-string">"IOモナドをテストする"</span>,() =&gt; {
});


describe(<span class="hljs-string">'Treeモナド'</span>, () =&gt; {
  <span class="hljs-keyword">var</span> tree  = {
    match: (data, pattern) =&gt; {
      <span class="hljs-keyword">return</span> data.call(tree,pattern);
    },
    leaf: (value) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.leaf(value);
      };
    },
    node: (treeL, treeR) =&gt; {
      <span class="hljs-keyword">return</span> (pattern) =&gt; {
        <span class="hljs-keyword">return</span> pattern.node(treeL, treeR);
      };
    },
    unit: (value) =&gt; {
      <span class="hljs-keyword">return</span> tree.leaf(value);
    },
    flatMap: (instanceM) =&gt; {
      <span class="hljs-keyword">return</span> (transform) =&gt; {
        <span class="hljs-keyword">return</span> tree.match(instanceM,{
          leaf: (value) =&gt; {
            <span class="hljs-keyword">return</span> transform(value);
          },
          node: (treeL, treeR) =&gt; {
            <span class="hljs-keyword">return</span> tree.node(tree.flatMap(treeL)(transform),
                             tree.flatMap(treeL)(transform));
          }
        }); 
      };
    },
    map: (instanceM) =&gt; {
      <span class="hljs-keyword">return</span> (transform) =&gt; {
        <span class="hljs-keyword">return</span> tree.match(instanceM,{
          leaf: (value) =&gt; {
            <span class="hljs-keyword">return</span> tree.leaf(transform(value));
          },
          node: (treeL, treeR) =&gt; {
            <span class="hljs-keyword">return</span> tree.node(tree.map(treeL)(transform),
                             tree.map(treeL)(transform));
          }
        }); 
      };
    }
  };
});

describe(<span class="hljs-string">'Consoleモナド'</span>, () =&gt; {
  <span class="hljs-comment">/* unit:: A -&gt; IO A */</span>
  <span class="hljs-keyword">var</span> unit = (any) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">return</span> any;
    };
  };
  <span class="hljs-comment">/* flatMap:: IO a -&gt; (a -&gt; IO b) -&gt; IO b */</span>
  <span class="hljs-keyword">var</span> flatMap = (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO b</span>
      <span class="hljs-keyword">return</span> unit(run(actionAB(run(instanceA))));
    };
  };

  <span class="hljs-comment">/* run:: IO A -&gt; A */</span>
  <span class="hljs-keyword">var</span> run = (instance) =&gt; {
    <span class="hljs-keyword">return</span> instance();
  };
  expect(run(unit(<span class="hljs-number">1</span>))).to.eql(<span class="hljs-number">1</span>);
});

describe(<span class="hljs-string">"Maybeと一緒に使う"</span>, () =&gt; {
  it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.cons(Maybe.just(<span class="hljs-number">2</span>),List.empty()));
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((listItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(listItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
    );
    next();
  });
  it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = List.cons(Maybe.just(<span class="hljs-number">1</span>),
                            List.empty());
    <span class="hljs-keyword">var</span> justList = List.flatMap(theList)((maybeItem) =&gt; {
      <span class="hljs-keyword">return</span> Maybe.flatMap(maybeItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> List.unit(value);
      });
    });
    expect(
      List.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(1),
                          list.empty());
  // var justList = list.map(theList)(maybe.unit);
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
});</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>describe(“Variantモナド”, () =&gt; {
  var variant = {
    unit: (value, key) =&gt; {
      return (pattern) =&gt; {
        return pattern<a href="value">key</a>;
      };
    },
    flatMap: (instance) =&gt; {
      return (transform) =&gt; {
        return instance(transform);
      };
    },
    match: (instance, pattern) =&gt; {
      return flip(variant.flatMap)(pattern)(instance);
    }
  };
  it(“Maybe”, (next) =&gt; {
    var just = (value) =&gt; {
      return variant.unit(value, ‘just’);
    }; 
    var nothing = (<em>) =&gt; {
      return variant.unit(null, ‘nothing’);
    }; 
    var isEqual = (maybeA) =&gt; {
      return (maybeB) =&gt; {
        return variant.match(maybeA,{
          just: (valueA) =&gt; {
            return variant.match(maybeB,{
              just: (valueB) =&gt; {
                return (valueA === valueB);
              },
              nothing: (</em>) =&gt; {
                return false;
              }
            });
          },
          nothing: (<em>) =&gt; {
            return variant.match(maybeB,{
              just: (</em>) =&gt; {
                return false;
              },
              nothing: (_) =&gt; {
                return true;
              }
            });
          }
        });
      };
    };
    var add = (maybeA,maybeB) =&gt; {
      return variant.flatMap(maybeA)((a) =&gt; {
        return variant.flatMap(maybeB)((b) =&gt; {
          return variant.unit(a + b);
        });
      });
    };
    var justOne = just(1);
    var justTwo = just(2);
    var justThree = just(3);
    expect(
      isEqual(add(justOne,justTwo))(justThree)
    ).to.eql(
      true
    );
    next();
  });
});</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
