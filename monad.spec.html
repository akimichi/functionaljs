<!DOCTYPE html>

<html>
<head>
  <title>monad.spec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>monad.spec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> expect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'expect.js'</span>);

<span class="hljs-keyword">var</span> maybe = {
  match: (data, pattern) =&gt; {
     <span class="hljs-keyword">return</span> data.call(maybe,pattern);
  },
  just : (value) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.just(value);
    };
  },
  nothing : (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.nothing(_);
    };
  },
  unit : (value) =&gt; {
    <span class="hljs-keyword">return</span> maybe.just(value);
  },
  flatMap : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> transform(value);
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.nothing(_);
        }
      });
    };
  },
  isEqual : (maybeA) =&gt; {
    <span class="hljs-keyword">return</span> (maybeB) =&gt; {
      <span class="hljs-keyword">return</span> maybe.match(maybeA,{
        just: (valueA) =&gt; {
          <span class="hljs-keyword">return</span> maybe.match(maybeB,{
            just: (valueB) =&gt; {
              <span class="hljs-keyword">return</span> (valueA === valueB);
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.match(maybeB,{
            just: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            },
            nothing: (_) =&gt; {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });
        }
      });
    };
  },
  map : (maybeInstance) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> maybe.match(maybeInstance,{
        just: (value) =&gt; {
          <span class="hljs-keyword">return</span> maybe.unit(transform(value));
        },
        nothing: (_) =&gt; {
          <span class="hljs-keyword">return</span> maybe.nothing(_);
        }
      });
    };
  }
};

<span class="hljs-keyword">var</span> list  = {
  match: (data, pattern) =&gt; {
    <span class="hljs-keyword">return</span> data.call(list,pattern);
  },
  empty: (_) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.empty();
    };
  },
  cons: (value, alist) =&gt; {
    <span class="hljs-keyword">return</span> (pattern) =&gt; {
      <span class="hljs-keyword">return</span> pattern.cons(value, alist);
    };
  },
  unit: (value) =&gt; {
    <span class="hljs-keyword">return</span> list.cons(value, list.empty());
  },
  head: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> head;
      }
    });
  },
  tail: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> tail;
      }
    });
  },
  isEmpty: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: (_) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>append:: LIST[T] -&gt; LIST[T] -&gt; LIST[T]
append [] ys = ys
append (x:xs) ys = x : (xs ++ ys)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  append: (xs) =&gt; {
    <span class="hljs-keyword">return</span> (ys) =&gt; {
      <span class="hljs-keyword">return</span> list.match(xs, {
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> ys;
        },
        cons: (head, tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(head,list.append(tail)(ys)); 
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>concat:: LIST[LIST[T]] -&gt; LIST[T]
concat [] = []
concat (xs:xss) = xs ++ concat xss</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  concat: (list_of_list) =&gt; {
    <span class="hljs-keyword">return</span> list.foldr(list_of_list)(list.empty())(list.append);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>return list.match(list_of<em>list, {
  empty: (</em>) =&gt; {
    return list.empty();
  },
  cons: (head, tail) =&gt; {
    return list.append(head)(list.concat(tail));
  }
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">flatten</span> :: [[a]] -&gt; [a]
<span class="hljs-title">flatten</span> =  foldr (++) []
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatten: (instanceMM) =&gt; {
    <span class="hljs-keyword">return</span> list.concat(instanceMM);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>return list.foldr(list.join)(list.empty());
return list.match(instanceMM,{
  empty: (_) =&gt; {
    return list.empty();
  },
  cons: (head,tail) =&gt; {
    return list.append(head)(list.flatten(tail));
  }
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>map:: LIST[T] -&gt; FUN[T-&gt;U] -&gt; LIST[U]
map [] _ = []
map (x:xs) f = f x : map xs f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; {
      <span class="hljs-keyword">return</span> list.match(instanceM,{
        empty: (_) =&gt; {
          <span class="hljs-keyword">return</span> list.empty();
        },
        cons: (head,tail) =&gt; {
          <span class="hljs-keyword">return</span> list.cons(transform(head),
                           list.map(tail)(transform));
        }
      });
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <pre><code class="lang-haskell"><span class="hljs-title">xs</span> &gt;&gt;= f = concat (map f xs)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> (transform) =&gt; { <span class="hljs-comment">// FUN[T-&gt;LIST[T]]</span>
      expect(transform).to.a(<span class="hljs-string">'function'</span>);
      <span class="hljs-keyword">return</span> list.concat(list.map(instanceM)(transform));
    };
  },
  <span class="hljs-comment">/* #@range_end(list_monad_definition) */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>1段階のリストしか配列に変更できない</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toArray: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.foldr(alist)([])((item) =&gt; {
      <span class="hljs-keyword">return</span> (accumulator) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>return list.match(item,{
  empty: () =&gt; {
    return [].concat(accumulator);
  },
  cons: (head, tail) =&gt; {
    return [list.toArray(item)].concat(accumulator);
  },
  otherwise: (arg) =&gt; {
    return [item].concat(accumulator);
  }
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> [item].concat(accumulator);
      };
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>foldr:: LIST[T] -&gt; T -&gt; FUN[T -&gt; U -&gt; U] -&gt; T
foldr []     z _ = z
foldr (x:xs) z f = f x (foldr xs z f) </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  foldr: (alist) =&gt; {         <span class="hljs-comment">// alist:: LIST[T]</span>
    <span class="hljs-keyword">return</span> (accumulator) =&gt; { <span class="hljs-comment">// accumulator:: T</span>
      <span class="hljs-keyword">return</span> (glue) =&gt; {      <span class="hljs-comment">// glue:: FUN[T -&gt; U -&gt; U] </span>
        expect(glue).to.a(<span class="hljs-string">'function'</span>);
        <span class="hljs-keyword">return</span> list.match(alist, {
          empty: (_) =&gt; {
            <span class="hljs-keyword">return</span> accumulator;
          },
          cons: (head, tail) =&gt; {
            <span class="hljs-keyword">return</span> glue(head)(list.foldr(tail)(accumulator)(glue));;
          }
        });
      };
    };
  }
}; <span class="hljs-comment">// end of list</span>


describe(<span class="hljs-string">"Readerモナドをテストする"</span>,() =&gt; {
  <span class="hljs-keyword">var</span> READER = {
    unit: (x) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        <span class="hljs-keyword">return</span> x;
      };
    },
    flatMap: (instanceM) =&gt; {
      <span class="hljs-keyword">return</span> (transform) =&gt; {
        <span class="hljs-keyword">return</span> (w) =&gt; {
          <span class="hljs-keyword">return</span> transform(instanceM(w))(w);
        };
      };
    }
  };
});</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2 id="-io-monad-module">‘IO’ monad module</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> IO = {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>unit:: T =&gt; IO[T]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unit : (any) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt;  { <span class="hljs-comment">// 外界は明示する必要はありません</span>
      <span class="hljs-keyword">return</span> any;
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>flatMap:: IO[T] =&gt; FUN[T =&gt; IO[U]] =&gt; IO[U]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap : (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (actionAB) =&gt; { <span class="hljs-comment">// actionAB:: a -&gt; IO[b]</span>
      <span class="hljs-keyword">return</span> IO.unit(IO.run(actionAB(IO.run(instanceA))));
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>IO.done関数
    IOアクションを何も実行しない</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* done:: T =&gt; IO[T] */</span>
  done : (any) =&gt; {
    <span class="hljs-keyword">return</span> IO.unit();
  },
  <span class="hljs-comment">/* IO.run関数
     IOアクションを実行する
  */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>run:: IO[A] =&gt; A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  run : (instanceM) =&gt; {
    <span class="hljs-keyword">return</span> instanceM();
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>readFile:: STRING =&gt; IO[STRING]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  readFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-keyword">var</span> content = fs.readFileSync(path, <span class="hljs-string">'utf8'</span>);
      <span class="hljs-keyword">return</span> IO.unit(content)(_);
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>println:: STRING =&gt; IO[null]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  println : (message) =&gt; {
    <span class="hljs-keyword">return</span> (_) =&gt; {
      <span class="hljs-built_in">console</span>.log(message);
      <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
    };
  },
  writeFile : (path) =&gt; {
    <span class="hljs-keyword">return</span> (content) =&gt; {
      <span class="hljs-keyword">return</span> (_) =&gt; {
        fs.writeFileSync(path,content);
        <span class="hljs-keyword">return</span> IO.unit(<span class="hljs-literal">null</span>)(_);
      };
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>IO.seq:: IO[a] =&gt; IO[b] =&gt; IO[b]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  seq: (instanceA) =&gt; {
    <span class="hljs-keyword">return</span> (instanceB) =&gt; {
      <span class="hljs-keyword">return</span> IO.flatMap(instanceA)((a) =&gt; {
        <span class="hljs-keyword">return</span> instanceB;
      });
    };
  },
  seqs: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.foldr(alist)(list.empty())(IO.done());
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>IO.putc:: CHAR =&gt; IO[]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  putc: (character) =&gt; {
    <span class="hljs-keyword">return</span> (io) =&gt; {
      process.stdout.write(character);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>IO.puts:: LIST[CHAR] =&gt; IO[]</p>
<pre><code class="lang-haskell"><span class="hljs-title">puts</span> list = seqs (map putc list)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>  puts: (alist) =&gt; {
    <span class="hljs-keyword">return</span> list.match(alist, {
      empty: () =&gt; {
        <span class="hljs-keyword">return</span> IO.done();
      },
      cons: (head, tail) =&gt; {
        <span class="hljs-keyword">return</span> IO.seq(IO.putc(head))(IO.puts(tail));
      }
    });
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>IO.getc :: IO[CHAR]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getc: () =&gt; {
    <span class="hljs-keyword">var</span> continuation = () =&gt; {
      <span class="hljs-keyword">var</span> chunk = process.stdin.read();
      <span class="hljs-keyword">return</span> chunk;
    }; 
    process.stdin.setEncoding(<span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> process.stdin.on(<span class="hljs-string">'readable'</span>, continuation);
  }
};

describe(<span class="hljs-string">"IOモナドをテストする"</span>,() =&gt; {
});

describe(<span class="hljs-string">"maybeモナドをテストする"</span>,() =&gt; {
  it(<span class="hljs-string">"maybe#flatMap"</span>, (next) =&gt; {
    maybe.match(maybe.flatMap(maybe.just(<span class="hljs-number">1</span>))((a) =&gt; {
      <span class="hljs-keyword">return</span> maybe.unit(a);
    }),{
      just: (value) =&gt; {
        expect(
          value
        ).to.eql(
          <span class="hljs-number">1</span>
        );
      },
      nothing: (_) =&gt; {
       expect().fail();
      }
    });
    maybe.match(maybe.flatMap(maybe.nothing())((a) =&gt; {
      <span class="hljs-keyword">return</span> maybe.unit(a);
    }),{
      just: (value) =&gt; {
       expect().fail();
      },
      nothing: (_) =&gt; {
       expect(<span class="hljs-literal">true</span>).to.be.ok();
      }
    });
    next();
  });
  it(<span class="hljs-string">"add(maybe, maybe)"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> add = (maybeA,maybeB) =&gt; {
      <span class="hljs-keyword">return</span> maybe.flatMap(maybeA)((a) =&gt; {
        <span class="hljs-keyword">return</span> maybe.flatMap(maybeB)((b) =&gt; {
          <span class="hljs-keyword">return</span> maybe.unit(a + b);
        });
      });
    };
    <span class="hljs-keyword">var</span> justOne = maybe.just(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> justTwo = maybe.just(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> justThree = maybe.just(<span class="hljs-number">3</span>);
    expect(
      maybe.isEqual(add(justOne,justTwo))(justThree)
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      maybe.isEqual(add(justOne,maybe.nothing()))(maybe.nothing())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
});

describe(<span class="hljs-string">"listモナドを活用する"</span>,() =&gt; {
  it(<span class="hljs-string">"'list#empty'"</span>, (next) =&gt; {
    list.match(list.empty,{
      empty: (_) =&gt; {
        expect(<span class="hljs-literal">true</span>).ok();
      },
      cons: (x,xs) =&gt; {
        expect().fail();
      }
    });
    next();
  });
  it(<span class="hljs-string">"'list#isEmpty'"</span>, (next) =&gt; {
    expect(
      list.isEmpty(list.empty())
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    expect(
      list.isEmpty(list.cons(<span class="hljs-number">1</span>,list.empty()))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'list#cons'"</span>, (next) =&gt; {
    list.match(list.cons(<span class="hljs-number">1</span>,list.empty()),{
      empty: (_) =&gt; {
        expect().fail();
      },
      cons: (x,xs) =&gt; {
        expect(x).to.eql(<span class="hljs-number">1</span>);
      }
    });
    next();
  });
  it(<span class="hljs-string">"'list#head'"</span>, (next) =&gt; {
    expect(
      list.head(list.cons(<span class="hljs-number">1</span>,list.empty()))
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    next();
  });
  it(<span class="hljs-string">"'list#tail'"</span>, (next) =&gt; {
    expect(
      list.head(list.tail(list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()))))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    next();
  });
  it(<span class="hljs-string">"'list#append'"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = list.append(list.cons(<span class="hljs-number">1</span>,list.empty()))(list.cons(<span class="hljs-number">2</span>,list.empty()));
    expect(
      list.head(theList)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      list.head(list.tail(theList))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      list.isEmpty(list.tail(list.tail(theList)))
    ).to.eql(
      <span class="hljs-literal">true</span>
    );
    next();
  });
  it(<span class="hljs-string">"'list#concat'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>list = [[1,2],[3,4]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> one_two = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()));
    <span class="hljs-keyword">var</span> three_four = list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()));

    <span class="hljs-keyword">var</span> list_of_list = list.cons(one_two,
                                 list.cons(three_four, list.empty()));</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>concated_list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> concated_list = list.concat(list_of_list);
    expect(
      list.toArray(concated_list)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
    );
    expect(
      list.head(concated_list)
    ).to.eql(
      <span class="hljs-number">1</span>
    );
    expect(
      list.head(list.tail(concated_list))
    ).to.eql(
      <span class="hljs-number">2</span>
    );
    expect(
      list.isEmpty(list.tail(list.tail(concated_list)))
    ).to.eql(
      <span class="hljs-literal">false</span>
    );
    next();
  });
  it(<span class="hljs-string">"'list#foldr'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)))
    expect(
      list.foldr(theList)(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
        <span class="hljs-keyword">return</span> (accumulator) =&gt; {
          <span class="hljs-keyword">return</span> accumulator + item;
        };
      })
    ).to.eql(
      <span class="hljs-number">10</span>
    )
    next();
  });
  describe(<span class="hljs-string">"'list#toArray'"</span>, () =&gt; {
    it(<span class="hljs-string">"1段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)));
       expect(
         list.toArray(theList)
       ).to.eql(
         [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
       );
       next();
     });
    it(<span class="hljs-string">"2段階のリストを配列に変換する"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>list = [[1],[2]] </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> nestedList = list.cons(list.cons(<span class="hljs-number">1</span>,list.empty()),
                                 list.cons(list.cons(<span class="hljs-number">2</span>,list.empty()),
                                           list.empty()));
       expect(
         list.toArray(list.flatMap(nestedList)((alist) =&gt; {
           <span class="hljs-keyword">return</span> list.flatMap(alist)((item) =&gt; {
             <span class="hljs-keyword">return</span> list.unit(item);
           });
         }))
       ).to.eql(
         [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
       );
       next();
     });
     });
  it(<span class="hljs-string">"'list#map'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>list = [1,2,3,4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()),list.empty)));
    expect(
      list.toArray(list.map(theList)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>)</span>{
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
      }))
    ).to.eql(
      [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
    );
    next();
  });
  it(<span class="hljs-string">"'list#unit'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(
      list.toArray(list.unit(<span class="hljs-number">1</span>))
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    expect(
      list.toArray(list.unit(<span class="hljs-literal">null</span>))
    ).to.eql(
      [<span class="hljs-literal">null</span>]
    );
    next();
  });
  describe(<span class="hljs-string">"list#flatMap"</span>, () =&gt; {
    it(<span class="hljs-string">"条件でフィルターする"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> list1 = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,
                                         list.empty()));
      <span class="hljs-keyword">var</span> list2 = list.cons(<span class="hljs-number">1</span>, list.cons(<span class="hljs-number">2</span>,
                                         list.empty()));
      expect(
        list.toArray(list.flatMap(list1)((item1) =&gt; {
          <span class="hljs-keyword">return</span> list.flatMap(list2)((item2) =&gt; {
            <span class="hljs-keyword">if</span>(item1 + item2 === <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">return</span> list.unit([item1, item2]);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> list.empty();
            }
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]
      );
      next();
    });
    it(<span class="hljs-string">"'list#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>list = [1]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>, list.empty());
      expect(
        list.toArray(list.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> list.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>]
      );
      <span class="hljs-keyword">var</span> emptyList = list.empty();
      expect(
        list.toArray(list.flatMap(emptyList)((item) =&gt; {
          <span class="hljs-keyword">return</span> list.unit(item * <span class="hljs-number">2</span>); 
        }))
      ).to.eql(
        []
      );
      next();
    });
    it(<span class="hljs-string">"'list#flatMap'"</span>, (next) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>list = [1,2,3]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>, list.cons(<span class="hljs-number">3</span>, list.empty())));
      expect(
        list.toArray(list.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">return</span> list.append(list.unit(item))(list.unit(- item));
        }))
      ).to.eql(
        [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">3</span>]
      );
      next();
    });
    it(<span class="hljs-string">"フィルターとして使う"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> even = (n) =&gt; {
        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      };
      <span class="hljs-keyword">var</span> theList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.cons(<span class="hljs-number">3</span>,list.cons(<span class="hljs-number">4</span>,list.empty()))));
      expect(
        list.toArray(list.flatMap(theList)((item) =&gt; {
          <span class="hljs-keyword">if</span>(even(item)) {
            <span class="hljs-keyword">return</span> list.unit(item);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> list.empty();
          }
        }))
      ).to.eql(
        [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
      );
      next();
    });
    it(<span class="hljs-string">"2段階のflatMap"</span>, (next) =&gt; {
      <span class="hljs-keyword">var</span> theNumberList = list.cons(<span class="hljs-number">1</span>,list.cons(<span class="hljs-number">2</span>,list.empty()));
      <span class="hljs-keyword">var</span> theStringList = list.cons(<span class="hljs-string">"one"</span>,list.cons(<span class="hljs-string">"two"</span>,list.empty()));
      expect(
        list.toArray(list.flatMap(theNumberList)((n) =&gt; {
          <span class="hljs-keyword">return</span> list.flatMap(theStringList)((s) =&gt; {
            <span class="hljs-keyword">return</span> list.unit([n,s]);
          });
        }))
      ).to.eql(
        [[<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">1</span>,<span class="hljs-string">"two"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"one"</span>],[<span class="hljs-number">2</span>,<span class="hljs-string">"two"</span>]]
      );
      next();
    });
  });
});

describe(<span class="hljs-string">"maybeと一緒に使う"</span>, () =&gt; {
  it(<span class="hljs-string">"[just(1),just(2)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = list.cons(maybe.just(<span class="hljs-number">1</span>),
                            list.cons(maybe.just(<span class="hljs-number">2</span>),list.empty()));
    <span class="hljs-keyword">var</span> justList = list.flatMap(theList)((listItem) =&gt; {
      <span class="hljs-keyword">return</span> maybe.flatMap(listItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> list.unit(value);
      });
    });
    expect(
      list.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
    );
    next();
  });
  it(<span class="hljs-string">"[just(1)]"</span>, (next) =&gt; {
    <span class="hljs-keyword">var</span> theList = list.cons(maybe.just(<span class="hljs-number">1</span>),
                            list.empty());
    <span class="hljs-keyword">var</span> justList = list.flatMap(theList)((maybeItem) =&gt; {
      <span class="hljs-keyword">return</span> maybe.flatMap(maybeItem)((value) =&gt; {
        <span class="hljs-keyword">return</span> list.unit(value);
      });
    });
    expect(
      list.toArray(justList)
    ).to.eql(
      [<span class="hljs-number">1</span>]
    );
    next();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>it(“[nothing()]”, (next) =&gt; {
  // var theList = list.unit(maybe.nothing());
  var theList = list.cons(maybe.nothing(1),
                          list.empty());
  // var justList = list.map(theList)(maybe.unit);
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    []
  );
  next();
});
it(“[just(1),nothing()]”, (next) =&gt; {
  // theList:: LIST[MAYBE[NUM]]
  //           [just(1), nothing()]
  var theList = list.cons(maybe.just(1),
                          list.cons(maybe.nothing(),list.empty()));
  var justList = list.flatMap(theList)((maybeItem) =&gt; {
    return maybe.flatMap(maybeItem)((value) =&gt; {
      return list.unit(value);
    });
  });
  expect(
    list.toArray(justList)
  ).to.eql(
    [2,4]
  );
  // expect(
  //   list.toArray(list.flatMap.call(list,theList)((maybeItem) =&gt; {
  //     return maybe.flatMap.call(maybe,maybeItem)((value) =&gt; {
  //       return list.unit.call(list,value);
  //     });
  //   }))
  // ).to.eql(
  //   [2,4]
  // );
  next();
});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/* #@range_end(list_maybe) */</span>
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
